C251 COMPILER V5.60.0,  main                                                               19/10/24  22:13:28  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Compiler\Keil_v5\C251\BIN\C251.EXE Bootloader\src\main.c XSMALL FUNCTIONS(REENTRANT) FLOAT64 OPT
                    -IMIZE(3,SPEED) INCDIR(.\Bootloader\inc) DEBUG PRINT(.\main.lst) TABS(2) OBJECT(.\Objects\main.obj) 

stmt  level    source

    1          /* Bootloader */
    2          
    3          #define BOOTLOADER_VERSION 10
    4          
    5          #define USE_P01
    6          /* Includes ------------------------------------------------------------------*/
    7          #include "nstdbool.h"
    8          #include "main.h"
    9          
   10          //#define USE_ADC_INPUT      // will go right to application and ignore eeprom
   11          
   12          #include "nstdint.h"
   13          #include <stdlib.h>
   14          #include <string.h>
   15          #include "bootloader.h"
   16          
   17          #define STC32_FLASH_START 0x00000000
   18          #define FIRMWARE_RELATIVE_START 0x0000
   19          #define EEPROM_RELATIVE_START 0x0000
   20          
   21          uint8_t bootloader_version = BOOTLOADER_VERSION;
   22          
   23          typedef void (*pFunction)(void);
   24          
   25          #define APPLICATION_ADDRESS     (uint32_t)(STC32_FLASH_START + FIRMWARE_RELATIVE_START) // 4k
   26          
   27          #define EEPROM_START_ADD         (uint32_t)(STC32_FLASH_START + EEPROM_RELATIVE_START)
   28          #define FLASH_END_ADD           (uint32_t)(STC32_FLASH_START + 0xFFFF)               // 32 k
   29          
   30          
   31          #define CMD_RUN             0x00
   32          #define CMD_PROG_FLASH      0x01
   33          #define CMD_ERASE_FLASH     0x02
   34          #define CMD_READ_FLASH_SIL  0x03
   35          #define CMD_VERIFY_FLASH    0x03
   36          #define CMD_VERIFY_FLASH_ARM 0x04
   37          #define CMD_READ_EEPROM     0x04
   38          #define CMD_PROG_EEPROM     0x05
   39          #define CMD_READ_SRAM       0x06
   40          #define CMD_READ_FLASH_ATM  0x07
   41          #define CMD_KEEP_ALIVE      0xFD
   42          #define CMD_SET_ADDRESS     0xFF
   43          #define CMD_SET_BUFFER      0xFE
   44          
   45          
   46          #ifdef USE_P01
   47          
   48          #define input_pin        P01
   49          #define input_port       P0
   50          #define PIN_NUMBER       0
   51          #define PORT_LETTER      0
   52          
   53          #endif
   54          
   55          #ifdef USE_PB4
               // #define input_pin       LL_GPIO_PIN_4
               // #define input_port        GPIOB
               // #define PIN_NUMBER        4
C251 COMPILER V5.60.0,  main                                                               19/10/24  22:13:28  PAGE 2   

               // #define PORT_LETTER       1
               #endif
   61          
   62          
   63          uint16_t low_pin_count = 0;
   64          char receviedByte;
   65          int receivedCount;
   66          int count = 0;
   67          char messagereceived = 0;
   68          uint16_t invalid_command = 0;
   69          uint16_t address_expected_increment;
   70          int cmd = 0;
   71          char eeprom_req = 0;
   72          int received;
   73          uint8_t port_letter;
   74          
   75          
   76          uint8_t pin_code = PORT_LETTER << 4 | PIN_NUMBER;
   77          uint8_t deviceInfo[9] = { 0 };      // stm32 device info
   78          
   79          size_t str_len;
   80          char connected = 0;
   81          uint8_t rxBuffer[258];
   82          uint8_t payLoadBuffer[256];
   83          char rxbyte=0;
   84          uint32_t address;
   85          int tick = 0;
   86          
   87          typedef union {
   88              uint8_t bytes[2];
   89              uint16_t word;
   90          } uint8_16_u;
   91          uint16_t len;
   92          uint8_t received_crc_low_byte;
   93          uint8_t received_crc_high_byte;
   94          uint8_t calculated_crc_low_byte;
   95          uint8_t calculated_crc_high_byte;
   96          uint16_t payload_buffer_size;
   97          char incoming_payload_no_command = 0;
   98          
   99          char bootloaderactive = 1;
  100          
  101          uint32_t JumpAddress;
  102          // pFunction JumpToApplication;
  103          #define JumpToApplication()   IAP_CONTR = 0x20
  104          
  105          
  106          void SystemClock_Config(void);
  107          //static void MX_GPIO_Init(void);
  108          static void PWMB_Timer_Init(void);
  109          
  110          /* USER CODE BEGIN PFP */
  111          static void GPIO_INPUT_INIT(void);
  112          
  113          void processmessage(void);
  114          void serialwriteChar(char dat);
  115          void sendString(uint8_t dat[], int len);
  116          void recieveBuffer();
  117          
  118          #define BAUDRATE              19200
  119          #define BITTIME          1000000/BAUDRATE
  120          #define HALFBITTIME       500000/BAUDRATE
  121          
  122          //ÂæÖÊîπÔºà‰ΩøÁî®ÂÆöÊó∂Âô®ÂÅöÂª∂Êó∂ÂáΩÊï∞Ôºâ
  123          void delayMicroseconds(uint32_t micros){
  124   1        // TIM2->CNT = 0;
C251 COMPILER V5.60.0,  main                                                               19/10/24  22:13:28  PAGE 3   

  125   1        PWMB_CNTRH = 0x00;
  126   1        PWMB_CNTRL = 0x00;
  127   1        while (((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) < micros){
  128   2        }
  129   1      }
  130          
  131          void jump(){
  132   1      
  133   1        uint8_t value;
  134   1      
  135   1        EA = 0;
  136   1      
  137   1        IAP_ENABLE();                           //ËÆæÁΩÆÁ≠âÂæÖÊó∂Èó¥ÔºåÂÖÅËÆ∏IAPÊìç‰ΩúÔºåÈÄÅ‰∏ÄÊ¨°Â∞±Â§ü
  138   1          IAP_READ();                             
  139   1      
  140   1        IAP_ADDRE = (uint8_t)(EEPROM_START_ADD >> 16); 
  141   1        IAP_ADDRH = (uint8_t)(EEPROM_START_ADD >> 8);  
  142   1        IAP_ADDRL = (uint8_t)EEPROM_START_ADD;         
  143   1        IAP_TRIG = 0x5A;
  144   1        IAP_TRIG = 0xA5;                   
  145   1        _nop_();   
  146   1        _nop_();
  147   1        _nop_();
  148   1        _nop_();
  149   1        while(CMD_FAIL);
  150   1      
  151   1        value = IAP_DATA;            //ËØªÂá∫ÁöÑÊï∞ÊçÆÈÄÅÂæÄ
  152   1      
  153   1        IAP_DISABLE();
  154   1      
  155   1      #ifdef USE_ADC_INPUT
               #else
  157   1        if (value != 0x01){      // check first byte of eeprom to see if its programmed, if not do not jump
  158   2          invalid_command = 0;
  159   2          return;
  160   2        }
  161   1      #endif
  162   1         JumpToApplication();
  163   1      }
  164          
  165          
  166          void makeCrc(uint8_t* pBuff, uint16_t length){
  167   1        int i;
  168   1        uint8_t xb;
  169   1        static uint8_16_u CRC_16;
  170   1        
  171   1        CRC_16.word=0;
  172   1        for(i = 0; i < length; i++) {
  173   2          uint8_t j;
  174   2          xb = pBuff[i];
  175   2          for ( j = 0; j < 8; j++)
  176   2          {
  177   3            if (((xb & 0x01) ^ (CRC_16.word & 0x0001)) !=0 ) {
  178   4              CRC_16.word = CRC_16.word >> 1;
  179   4              CRC_16.word = CRC_16.word ^ 0xA001;
  180   4            } else {
  181   4              CRC_16.word = CRC_16.word >> 1;
  182   4            }
  183   3            xb = xb >> 1;
  184   3          }
  185   2        }
  186   1        calculated_crc_low_byte = CRC_16.bytes[0];
  187   1        calculated_crc_high_byte = CRC_16.bytes[1];
  188   1      }
  189          
  190          char checkCrc(uint8_t* pBuff, uint16_t length){
C251 COMPILER V5.60.0,  main                                                               19/10/24  22:13:28  PAGE 4   

  191   1      
  192   1        char received_crc_low_byte2 = pBuff[length];          // one higher than len in buffer
  193   1        char received_crc_high_byte2 = pBuff[length+1];
  194   1        makeCrc(pBuff,length);
  195   1        if((calculated_crc_low_byte==received_crc_low_byte2)   && (calculated_crc_high_byte==received_crc_high_b
             -yte2)){
  196   2          return 1;
  197   2        }else{
  198   2          return 0;
  199   2        }
  200   1      
  201   1      }
  202          
  203          //ÂæÖÊîπÔºàÊé•Êî∂ÂºïËÑöÂàùÂßãÂåñÔºâ‰∏äÊãâËæìÂÖ•
  204          void setReceive(void){
  205   1      
  206   1        GPIO_INPUT_INIT();
  207   1        received = 0;
  208   1      
  209   1      }
  210          //ÂæÖÊîπÔºàÂèëÈÄÅÂºïËÑöÂàùÂßãÂåñÔºâ
  211          void setTransmit(void){
  212   1        // LL_GPIO_SetPinMode(input_port, input_pin, LL_GPIO_MODE_OUTPUT);       // set as reciever // clear bit
             -s and set receive bits..
  213   1        P0M0 |= 0x02; P0M1 &= ~0x02;  //Êé®ÊåΩËæìÂá∫
  214   1        P0PU &= ~0x02; P0PD &= ~0x02;   //Êó†‰∏ä‰∏ãÊãâ
  215   1      }
  216          
  217          void send_ACK(void){
  218   1          setTransmit();
  219   1          serialwriteChar(0x30);             // good ack!
  220   1        setReceive();
  221   1      }
  222          
  223          void send_BAD_ACK(void){
  224   1        setTransmit();
  225   1        serialwriteChar(0xC1);                // bad command message.
  226   1        setReceive();
  227   1      }
  228          
  229          void send_BAD_CRC_ACK(){
  230   1          setTransmit();
  231   1        serialwriteChar(0xC2);                // bad command message.
  232   1        setReceive();
  233   1      }
  234          
  235          void sendDeviceInfo(){
  236   1        setTransmit();
  237   1        sendString(deviceInfo,9);
  238   1        setReceive();
  239   1      }
  240          
  241          bool checkAddressWritable(uint32_t address) {
  242   1        return address >= APPLICATION_ADDRESS;
  243   1      }
  244          
  245          void decodeInput(){
  246   1        if(incoming_payload_no_command){
  247   2          len = payload_buffer_size;
  248   2        //  received_crc_low_byte = rxBuffer[len];          // one higher than len in buffer
  249   2        //  received_crc_high_byte = rxBuffer[len+1];
  250   2          if(checkCrc(rxBuffer,len)){
  251   3            int i;
  252   3            memset(payLoadBuffer, 0, sizeof(payLoadBuffer));             // reset buffer
  253   3      
  254   3            for(i = 0; i < len; i++){
C251 COMPILER V5.60.0,  main                                                               19/10/24  22:13:28  PAGE 5   

  255   4              payLoadBuffer[i]= rxBuffer[i];
  256   4            }
  257   3            send_ACK();
  258   3            incoming_payload_no_command = 0;
  259   3            return;
  260   3          }else{
  261   3            send_BAD_CRC_ACK();
  262   3            return;
  263   3          }
  264   2        }
  265   1      
  266   1        cmd = rxBuffer[0];
  267   1      
  268   1        if(rxBuffer[16] == 0x7d){
  269   2          if(rxBuffer[8] == 13 && rxBuffer[9] == 66){
  270   3            sendDeviceInfo();
  271   3            rxBuffer[20]= 0;
  272   3      
  273   3          }
  274   2          return;
  275   2        }
  276   1      
  277   1        if(rxBuffer[20] == 0x7d){
  278   2          if(rxBuffer[12] == 13 && rxBuffer[13] == 66){
  279   3            sendDeviceInfo();
  280   3            rxBuffer[20]= 0;
  281   3            return;
  282   3          }
  283   2      
  284   2        }
  285   1        if(rxBuffer[40] == 0x7d){
  286   2          if(rxBuffer[32] == 13 && rxBuffer[33] == 66){
  287   3            sendDeviceInfo();
  288   3            rxBuffer[20]= 0;
  289   3            return;
  290   3          }
  291   2        }
  292   1      
  293   1        if(cmd == CMD_RUN){         // starts the main app
  294   2          if((rxBuffer[1] == 0) && (rxBuffer[2] == 0) && (rxBuffer[3] == 0)){
  295   3            invalid_command = 101;
  296   3          }
  297   2        }
  298   1      
  299   1        if(cmd == CMD_PROG_FLASH){
  300   2          len = 2;
  301   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  302   3            send_BAD_CRC_ACK();
  303   3      
  304   3            return;
  305   3          }
  306   2      
  307   2          if (!checkAddressWritable(address)) {
  308   3            send_BAD_ACK();
  309   3      
  310   3            return;
  311   3          }
  312   2      
  313   2          save_flash_nolib((uint8_t*)payLoadBuffer, payload_buffer_size,address);
  314   2          send_ACK();
  315   2      
  316   2          return;
  317   2        }
  318   1      
  319   1        if(cmd == CMD_SET_ADDRESS){             //  command set addressinput format is: CMD, 00 , High byte addr
             -ess, Low byte address, crclb ,crchb
C251 COMPILER V5.60.0,  main                                                               19/10/24  22:13:28  PAGE 6   

  320   2          len = 4;  // package without 2 byte crc
  321   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  322   3            send_BAD_CRC_ACK();
  323   3      
  324   3            return;
  325   3          }
  326   2      
  327   2      
  328   2            // will send Ack 0x30 and read input after transfer out callback
  329   2          invalid_command = 0;
  330   2          address = STC32_FLASH_START + (rxBuffer[2] << 8 | rxBuffer[3]);
  331   2          send_ACK();
  332   2      
  333   2          return;
  334   2        }
  335   1      
  336   1        if(cmd == CMD_SET_BUFFER){        // for writing buffer rx buffer 0 = command byte.  command set address
             -, input , format is CMD, 00 , 00 or 01 (if buffer is 256), buffer_size,
  337   2          len = 4;  // package without 2 byte crc
  338   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  339   3            send_BAD_CRC_ACK();
  340   3      
  341   3            return;
  342   3          }
  343   2      
  344   2              // no ack with command set buffer;
  345   2              if(rxBuffer[2] == 0x01){
  346   3                payload_buffer_size = 256;                          // if nothing in this buffer
  347   3              }else{
  348   3                payload_buffer_size = rxBuffer[3];
  349   3              }
  350   2            incoming_payload_no_command = 1;
  351   2            address_expected_increment = 256;
  352   2              setReceive();
  353   2      
  354   2              return;
  355   2        }
  356   1      
  357   1        if(cmd == CMD_KEEP_ALIVE){
  358   2          len = 2;
  359   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  360   3            send_BAD_CRC_ACK();
  361   3      
  362   3            return;
  363   3          }
  364   2      
  365   2            setTransmit();
  366   2          serialwriteChar(0xC1);                // bad command message.
  367   2          setReceive();
  368   2      
  369   2          return;
  370   2        }
  371   1      
  372   1        if(cmd == CMD_ERASE_FLASH){
  373   2          len = 2;
  374   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  375   3            send_BAD_CRC_ACK();
  376   3      
  377   3            return;
  378   3          }
  379   2      
  380   2          if (!checkAddressWritable(address)) {
  381   3            send_BAD_ACK();
  382   3      
  383   3            return;
  384   3          }
C251 COMPILER V5.60.0,  main                                                               19/10/24  22:13:28  PAGE 7   

  385   2      
  386   2          send_ACK();
  387   2          return;
  388   2        }
  389   1      
  390   1        if(cmd == CMD_READ_EEPROM){
  391   2          eeprom_req = 1;
  392   2        }
  393   1      
  394   1        if(cmd == CMD_READ_FLASH_SIL){     // for sending contents of flash memory at the memory location set in
             - bootloader.c need to still set memory with data from set mem command
  395   2          uint16_t out_buffer_size;
  396   2          uint8_t *read_data;
  397   2          len = 2;
  398   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  399   3            send_BAD_CRC_ACK();
  400   3      
  401   3            return;
  402   3          }
  403   2      
  404   2          count++;
  405   2          out_buffer_size = rxBuffer[1];//
  406   2          if(out_buffer_size == 0){
  407   3            out_buffer_size = 256;
  408   3          }
  409   2          address_expected_increment = 128;
  410   2          read_data = (uint8_t*)malloc(out_buffer_size + 3);
  411   2          setTransmit();                            // make buffer 3 larger to fit CRC and ACK
  412   2          memset(read_data, 0, sizeof(read_data));
  413   2              //    read_flash((uint8_t*)read_data , address);                  // make sure read_flash reads t
             -wo less than buffer.
  414   2          read_flash_bin((uint8_t*)read_data , address, out_buffer_size);
  415   2      
  416   2              makeCrc(read_data,out_buffer_size);
  417   2              read_data[out_buffer_size] = calculated_crc_low_byte;
  418   2              read_data[out_buffer_size + 1] = calculated_crc_high_byte;
  419   2              read_data[out_buffer_size + 2] = 0x30;
  420   2              sendString(read_data, out_buffer_size+3);
  421   2      
  422   2          setReceive();
  423   2          free(read_data);
  424   2          return;
  425   2        }
  426   1      
  427   1          setTransmit();
  428   1      
  429   1        serialwriteChar(0xC1);                // bad command message.
  430   1        invalid_command++;
  431   1        setReceive();
  432   1      }
  433          
  434          void serialreadChar()
  435          {
  436   1        int bits_to_read;
  437   1        rxbyte=0;
  438   1        // PWMB_PSCRH = 0x00;
  439   1        PWMB_PSCRL = 0x03; // set to 1/4mhz
  440   1        while(~(input_pin)){ // wait for rx to go high
  441   2          if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 50000){
  442   3              invalid_command = 101;
  443   3              return;
  444   3          }
  445   2        }
  446   1        PWMB_PSCRL = 0x00; // set to 1/4mhz
  447   1        while(input_pin){   // wait for it go go low
  448   2          if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 250 && messagereceived){
C251 COMPILER V5.60.0,  main                                                               19/10/24  22:13:28  PAGE 8   

  449   3            return;
  450   3          }
  451   2        }
  452   1      
  453   1        delayMicroseconds(HALFBITTIME);//wait to get the center of bit time
  454   1      
  455   1        bits_to_read = 0;
  456   1        while (bits_to_read < 8) {
  457   2          delayMicroseconds(BITTIME);
  458   2          rxbyte = rxbyte | ((uint8_t)(input_pin) >> PIN_NUMBER) << bits_to_read;
  459   2        bits_to_read++;
  460   2        }
  461   1      
  462   1        delayMicroseconds(HALFBITTIME); //wait till the stop bit time begins
  463   1        messagereceived = 1;
  464   1        receviedByte = rxbyte;
  465   1        //return rxbyte;
  466   1      
  467   1      }
  468          
  469          void serialwriteChar(char dat)
  470          {
  471   1      
  472   1        //BRR Âè™ÂÜôÂØÑÂ≠òÂô®ÔºöÂè™ËÉΩÊîπÂèòÁÆ°ËÑöÁä∂ÊÄÅ‰∏∫‰ΩéÁîµÂπ≥ÔºåÂØπÂØÑÂ≠òÂô® ÁÆ°ËÑöÂØπ‰∫é‰ΩçÂÜô 1 Áõ∏Â∫îÁ
             -Æ°ËÑö‰ºö‰∏∫‰ΩéÁîµÂπ≥„ÄÇÂÜô 0 Êó†Âä®‰Ωú„ÄÇ
  473   1        // input_port->BRR = input_pin;; //initiate start bit
  474   1        char bits_to_read = 0;
  475   1      
  476   1        input_pin = 0;          //initiate start bit
  477   1      
  478   1        
  479   1        while (bits_to_read < 8) {
  480   2      
  481   2          delayMicroseconds(BITTIME);
  482   2      
  483   2          if (dat & 0x01) {
  484   3            // input_port->BSRR = input_pin;
  485   3            input_pin = 1;
  486   3          }else{
  487   3            // input_port->BRR = input_pin;
  488   3            input_pin = 0;
  489   3          }
  490   2          bits_to_read++;
  491   2          dat = dat >> 1;
  492   2        }
  493   1      
  494   1        delayMicroseconds(BITTIME);
  495   1      
  496   1        // input_port->BSRR = input_pin; //write the stop bit
  497   1      
  498   1      
  499   1        input_pin = 1;          //write the stop bit
  500   1      
  501   1      
  502   1        // if more than one byte a delay is needed after stop bit,
  503   1        //if its the only one no delay, the sendstring function adds delay after each bit
  504   1      
  505   1        //if(cmd == 255 || cmd == 254 || cmd == 1  || incoming_payload_no_command){
  506   1        //
  507   1        //}else{
  508   1        //  delayMicroseconds(BITTIME);
  509   1        //}
  510   1      }
  511          
  512          void sendString(uint8_t *dat, int len){
  513   1        int i;
C251 COMPILER V5.60.0,  main                                                               19/10/24  22:13:28  PAGE 9   

  514   1        for(i = 0; i < len; i++){
  515   2          serialwriteChar(dat[i]);
  516   2          delayMicroseconds(BITTIME);
  517   2        }
  518   1      }
  519          
  520          void recieveBuffer(void){
  521   1      
  522   1        int i = 0;
  523   1        count = 0;
  524   1        messagereceived = 0;
  525   1        memset(rxBuffer, 0, sizeof(rxBuffer));
  526   1      
  527   1      
  528   1        for(i = 0; i < sizeof(rxBuffer); i++){
  529   2          serialreadChar();
  530   2          if(incoming_payload_no_command){
  531   3            if(count == payload_buffer_size+2){
  532   4              break;
  533   4            }
  534   3            rxBuffer[i] = rxbyte;
  535   3            count++;
  536   3          }else{
  537   3            if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 250){
  538   4            count = 0;
  539   4            break;
  540   4            }else{
  541   4            rxBuffer[i] = rxbyte;
  542   4            if(i == 257){
  543   5              invalid_command+=20;       // needs one hundred to trigger a jump but will be reset on next set addre
             -ss commmand
  544   5      
  545   5              }
  546   4            }
  547   3          }
  548   2        }
  549   1        decodeInput();
  550   1      }
  551          
  552          void update_EEPROM(void){
  553   1        read_flash_bin(rxBuffer , EEPROM_START_ADD , 48);
  554   1        if(BOOTLOADER_VERSION != rxBuffer[2]){
  555   2          if (rxBuffer[2] == 0xFF || rxBuffer[2] == 0x00){
  556   3            return;
  557   3          }
  558   2          rxBuffer[2] = BOOTLOADER_VERSION;
  559   2          save_flash_nolib(rxBuffer, 48, EEPROM_START_ADD);
  560   2        }
  561   1      }
  562          
  563          void checkForSignal(void){
  564   1        //uint8_t floating_or_signal= 0;
  565   1        // LL_GPIO_SetPinPull(input_port, input_pin, LL_GPIO_PULL_DOWN);
  566   1        int i;
  567   1      
  568   1        P0PU &= ~0x02; //ÂÖ≥Èó≠‰∏äÊãâÁîµÈòª
  569   1        P0PD |= 0x02; //ÂºÄÂêØ‰∏ãÊãâÁîµÈòª
  570   1      
  571   1        delayMicroseconds(500);
  572   1      
  573   1        for(i = 0 ; i < 500; i ++){
  574   2          if(~input_pin){
  575   3            low_pin_count++;
  576   3          }else{
  577   3        //   high_pin_count++;
  578   3          }
C251 COMPILER V5.60.0,  main                                                               19/10/24  22:13:28  PAGE 10  

  579   2          delayMicroseconds(10);
  580   2        }
  581   1      
  582   1        if(low_pin_count == 0){
  583   2          return;           // all high while pin is pulled low, bootloader signal
  584   2        }
  585   1      
  586   1        low_pin_count = 0;
  587   1      
  588   1        P0PU &= ~0x02; //ÂÖ≥Èó≠‰∏äÊãâÁîµÈòª
  589   1        P0PD &= ~0x02; //ÂÖ≥Èó≠‰∏ãÊãâÁîµÈòª 
  590   1        // LL_GPIO_SetPinPull(input_port, input_pin, LL_GPIO_PULL_NO);
  591   1        delayMicroseconds(500);
  592   1      
  593   1        for(i = 0 ; i < 500; i ++){
  594   2          if(~input_pin){
  595   3            low_pin_count++;
  596   3          }
  597   2          delayMicroseconds(10);
  598   2        }
  599   1      
  600   1        if(low_pin_count == 0){
  601   2          return;            // when floated all
  602   2        }
  603   1      
  604   1        if(low_pin_count > 0){
  605   2          jump();
  606   2        }
  607   1      }
  608          
  609          
  610          void Uart1_Init(void) //921600bps@48MHz
  611          {
  612   1        SCON = 0x50;    //8‰ΩçÊï∞ÊçÆ,ÂèØÂèòÊ≥¢ÁâπÁéá
  613   1        AUXR |= 0x01;   //‰∏≤Âè£1ÈÄâÊã©ÂÆöÊó∂Âô®2‰∏∫Ê≥¢ÁâπÁéáÂèëÁîüÂô®
  614   1        AUXR |= 0x04;   //ÂÆöÊó∂Âô®Êó∂Èíü1TÊ®°Âºè
  615   1        T2L = 0xF3;     //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
  616   1        T2H = 0xFF;     //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
  617   1        AUXR |= 0x10;   //ÂÆöÊó∂Âô®2ÂºÄÂßãËÆ°Êó∂
  618   1      }
  619          
  620          #include <stdio.h>
  621          
  622          
  623          int main(void)
  624          {
  625   1      
  626   1        //Prevent warnings
  627   1        (void)bootloader_version;
*** WARNING C138 IN LINE 627 OF Bootloader\src\main.c: expression with possibly no effect
  628   1      
  629   1          // LL_APB1_GRP2_EnableClock(LL_APB1_GRP2_PERIPH_SYSCFG);
  630   1          // LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
  631   1      
  632   1          // FLASH->ACR |= FLASH_ACR_PRFTBE;   // prefetch buffer enable
  633   1      
  634   1          SystemClock_Config();
  635   1        Uart1_Init();
  636   1      
  637   1        P3M0 |= 0x03; P3M1 &= ~0x03; 
  638   1        P2M0 |= 0x03; P2M1 &= ~0x03; 
  639   1      
  640   1        PWMB_Timer_Init();
  641   1      
  642   1      
  643   1        while (1)
C251 COMPILER V5.60.0,  main                                                               19/10/24  22:13:28  PAGE 11  

  644   1        {
  645   2          // printf("SystemClock_Config\n");
  646   2          printf("%u\n",((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL));
  647   2        }
  648   1      
  649   1      //      GPIO_INPUT_INIT();     // init the pin with a pulldown
  650   1      
  651   1      //      checkForSignal();
  652   1      
  653   1      
  654   1      //  P0PD &= ~0x02;
  655   1      //  P0PU |= 0x02;     //‰∏äÊãâËæìÂÖ•
  656   1      //      // LL_GPIO_SetPinPull(input_port, input_pin, LL_GPIO_PULL_UP);
  657   1      
  658   1      // #ifdef USE_ADC_INPUT  // go right to application
  659   1      //    jump();
  660   1      // #endif
  661   1      //    deviceInfo[3] = pin_code;
  662   1      //    update_EEPROM();
  663   1      
  664   1      // //  sendDeviceInfo();
  665   1      //    while (1)
  666   1      //    {
  667   1      //      recieveBuffer();
  668   1      //      if (invalid_command > 100){
  669   1      //        jump();
  670   1      //      }
  671   1      //    }
  672   1      
  673   1      }
  674          
  675          
  676          
  677          void SystemClock_Config(void)
  678          {
  679   1        EA = 0;
  680   1      
  681   1        CKCON = 0x00;           // ËÆæÁΩÆÂ§ñÈÉ®Êï∞ÊçÆÊÄªÁ∫ø‰∏∫ÊúÄÂø´
  682   1        WTST = 1;                 // ËÆæÁΩÆÁ®ãÂ∫è‰ª£Á†ÅÁ≠âÂæÖÂèÇÊï∞ÔºåËµãÂÄº‰∏∫0ÂèØÂ∞ÜCPUÊâßË°åÁ®ãÂ∫èÁöÑÈÄüÂ∫¶ËÆæ
             -ÁΩÆ‰∏∫ÊúÄÂø´
  683   1        P_SW2 = 0x80;         // ÂºÄÂêØÁâπÊÆäÂú∞ÂùÄËÆøÈóÆ
  684   1      
  685   1        CLKDIV = 0x04;      //‰∏ªÊó∂ÈíüMCLKËæìÂá∫Âà∞Á≥ªÁªüÊó∂Èíü(SYSCLK)ÂàÜÈ¢ë1
  686   1             
  687   1        IRTRIM = CHIPID12;        //ÂÜÖÈÉ®Êó∂ÈíüÊ∫êÈÄâÊã©24M
  688   1        HIRCSEL1 = 1;
  689   1        HIRCSEL0 = 0;
  690   1      
  691   1        HIRCCR = 0x80;
  692   1        while (!(HIRCCR & 0x01));
  693   1        
  694   1        // MCLKOCR = 72;          //ÂàÜÈ¢ë72,ËæìÂá∫Êó∂ÈíüÁöÑÂàÜÈ¢ë
  695   1      
  696   1        CLKSEL = 0x40;      //PLL,È´òÈÄüIOÔºåÁ≥ªÁªüÊó∂ÈíüÊ∫êÁöÑÁõ∏ÂÖ≥ËÆæÁΩÆ(ÂÖàÈÄâÊã©ÂÜÖÈÉ®IRC‰Ωú‰∏∫Á≥ªÁªüÊó∂Èíü)
  697   1      
  698   1        USBCLK &= 0x0F;
  699   1        USBCLK |= 0xA0;
  700   1        NOP(5);         //Á≠âÂæÖÊó∂ÈíüÁ®≥ÂÆö
  701   1      
  702   1        //PLL‰∫ßÁîü96MhzÊó∂Èíü
  703   1      
  704   1        CLKDIV = 0X01;      //‰∏ªÊó∂ÈíüMCLKËæìÂá∫Âà∞Á≥ªÁªüÊó∂Èíü(SYSCLK)ÂàÜÈ¢ë1
  705   1      
  706   1        CLKSEL |= 0x08;     //MCLKÈÄâÊã©PLL/2‰∏∫Êó∂ÈíüÊ∫ê->48Mhz
  707   1      
  708   1        HSCLKDIV = 0x01;    //È´òÈÄüPWM,SPI,I2S,TFPUÊó∂Èíü96MHz
C251 COMPILER V5.60.0,  main                                                               19/10/24  22:13:28  PAGE 12  

  709   1      
  710   1        USBCKS = 1;       
  711   1        USBCKS2 = 0;      //USBÊó∂ÈíüÈÄâÊã©48Mhz
  712   1      
  713   1        EA = 1;
  714   1      }
  715          
  716          
  717          static void PWMB_Timer_Init(void)
  718          {
  719   1        PWMB_ENO = 0x00;    //Á¶ÅÊ≠¢PWMBÁöÑPWMËæìÂá∫
  720   1        PWMB_IOAUX = 0x00;    //Á¶ÅÊ≠¢PWMB
  721   1      
  722   1        PWMB_ARRH = 0xFF;
  723   1        PWMB_ARRL = 0xFF;   //ËÆæÁΩÆPWMBÂë®Êúü‰∏∫65535
  724   1        PWMB_CNTRH = 0x00;
  725   1        PWMB_CNTRL = 0x00;    //Ê∏ÖÈõ∂ËÆ°Êï∞Âô®
  726   1        PWMB_PSCRH = 0x00;    
  727   1        PWMB_PSCRL = 0x2F;    //PWMBÊó∂ÈíüÊ∫êÂàÜÈ¢ëÂà∞1Mhz
  728   1        PWMB_IER = 0x00;    //Á¶ÅÊ≠¢PWMB‰∏≠Êñ≠
  729   1        PWMB_CR1 = 0x01;    //‰ΩøËÉΩËÆ°Êï∞Âô®
  730   1      }
  731          
  732          
  733          
  734          static void GPIO_INPUT_INIT(void)
  735          {
  736   1      #ifdef USE_PB4
               #endif
  738   1      #ifdef USE_PA2
               #endif
  740   1      
  741   1          P0M0 &= ~0x02; 
  742   1        P0M1 |= 0x02;   
  743   1          P0NCS &= ~0x02; 
  744   1          P0IE |= 0x02; 
  745   1        P0PU |= 0x02; 
  746   1        //È´òÈòª‰∏äÊãâËæìÂÖ•
  747   1      }
  748          
  749          
  750          #pragma FUNCTIONS (static)
  751          char putchar(char c)
  752          {
  753   1        // serialwriteChar(c);
  754   1        SBUF = c;
  755   1        while (!TI);
  756   1        TI = 0;
  757   1        return c;
  758   1      }
  759          
  760          
  761          
  762          
  763          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2388     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       569     ------
C251 COMPILER V5.60.0,  main                                                               19/10/24  22:13:28  PAGE 13  

  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        87     ------
End of Module Information.


C251 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)

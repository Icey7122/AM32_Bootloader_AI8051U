C251 COMPILER V5.60.0,  main                                                               21/10/24  00:33:04  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Compiler\Keil_v5\C251\BIN\C251.EXE Bootloader\src\main.c XSMALL FUNCTIONS(REENTRANT) FLOAT64 WAR
                    -NINGLEVEL(3) BROWSE INCDIR(.\Bootloader\inc) DEBUG PRINT(.\main.lst) TABS(2) OBJECT(.\Objects\main.obj) 

stmt  level    source

    1          /* Bootloader */
    2          
    3          #define BOOTLOADER_VERSION 10
    4          
    5          #define USE_P01
    6          /* Includes ------------------------------------------------------------------*/
    7          #include "nstdbool.h"
    8          #include "main.h"
    9          #include <stdio.h>
   10          //#define USE_ADC_INPUT      // will go right to application and ignore eeprom
   11          
   12          #include "nstdint.h"
   13          #include <stdlib.h>
   14          #include <string.h>
   15          #include "bootloader.h"
   16          
   17          #define DEBUG(x) printf(x) 
   18          
   19          #define STC32_FLASH_START 0x00000000
   20          #define FIRMWARE_RELATIVE_START 0x0000
   21          #define EEPROM_RELATIVE_START 0xFFFF - 0x400
   22          
   23          uint8_t bootloader_version = BOOTLOADER_VERSION;
   24          
   25          typedef void (*pFunction)(void);
   26          
   27          #define APPLICATION_ADDRESS     (uint32_t)(STC32_FLASH_START + FIRMWARE_RELATIVE_START) // 4k
   28          
   29          #define EEPROM_START_ADD         (uint32_t)(STC32_FLASH_START + EEPROM_RELATIVE_START)
   30          #define FLASH_END_ADD           (uint32_t)(STC32_FLASH_START + 0xFFFF)               // 32 k
   31          
   32          
   33          #define CMD_RUN             0x00
   34          #define CMD_PROG_FLASH      0x01
   35          #define CMD_ERASE_FLASH     0x02
   36          #define CMD_READ_FLASH_SIL  0x03
   37          #define CMD_VERIFY_FLASH    0x03
   38          #define CMD_VERIFY_FLASH_ARM 0x04
   39          #define CMD_READ_EEPROM     0x04
   40          #define CMD_PROG_EEPROM     0x05
   41          #define CMD_READ_SRAM       0x06
   42          #define CMD_READ_FLASH_ATM  0x07
   43          #define CMD_KEEP_ALIVE      0xFD
   44          #define CMD_SET_ADDRESS     0xFF
   45          #define CMD_SET_BUFFER      0xFE
   46          
   47          
   48          #ifdef USE_P01
   49          
   50          #define input_pin        P01
   51          #define input_port       P0
   52          #define PIN_NUMBER       0
   53          #define PORT_LETTER      0
   54          
   55          #endif
   56          
   57          #ifdef USE_PB4
               // #define input_pin       LL_GPIO_PIN_4
C251 COMPILER V5.60.0,  main                                                               21/10/24  00:33:04  PAGE 2   

               // #define input_port        GPIOB
               // #define PIN_NUMBER        4
               // #define PORT_LETTER       1
               #endif
   63          
   64          
   65          uint16_t low_pin_count = 0;
   66          char receviedByte;
   67          int receivedCount;
   68          int count = 0;
   69          char messagereceived = 0;
   70          uint16_t invalid_command = 0;
   71          uint16_t address_expected_increment;
   72          int cmd = 0;
   73          char eeprom_req = 0;
   74          int received;
   75          uint8_t port_letter;
   76          
   77          
   78          uint8_t pin_code = 0;
   79          uint8_t deviceInfo[9] = { 0 };      // stm32 device info
   80          
   81          size_t str_len;
   82          char connected = 0;
   83          uint8_t rxBuffer[258];
   84          uint8_t payLoadBuffer[256];
   85          char rxbyte=0;
   86          uint32_t address;
   87          int tick = 0;
   88          
   89          typedef union {
   90              uint8_t bytes[2];
   91              uint16_t word;
   92          } uint8_16_u;
   93          uint16_t len;
   94          uint8_t received_crc_low_byte;
   95          uint8_t received_crc_high_byte;
   96          uint8_t calculated_crc_low_byte;
   97          uint8_t calculated_crc_high_byte;
   98          uint16_t payload_buffer_size;
   99          char incoming_payload_no_command = 0;
  100          
  101          char bootloaderactive = 1;
  102          
  103          uint32_t JumpAddress;
  104          // pFunction JumpToApplication;
  105          #define JumpToApplication()   IAP_CONTR = 0x20
  106          
  107          
  108          void SystemClock_Config(void);
  109          static void PWMB_Timer_Init(void);
  110          
  111          /* USER CODE BEGIN PFP */
  112          static void GPIO_INPUT_INIT(void);
  113          
  114          void processmessage(void);
  115          void serialwriteChar(char dat);
  116          void sendString(uint8_t dat[], int len);
  117          void recieveBuffer();
  118          
  119          #define BAUDRATE              19200
  120          #define BITTIME          1000000/BAUDRATE
  121          #define HALFBITTIME       500000/BAUDRATE
  122          
  123          //ÂæÖÊîπÔºà‰ΩøÁî®ÂÆöÊó∂Âô®ÂÅöÂª∂Êó∂ÂáΩÊï∞Ôºâ
  124          void delayMicroseconds(uint32_t micros){
C251 COMPILER V5.60.0,  main                                                               21/10/24  00:33:04  PAGE 3   

  125   1        // TIM2->CNT = 0;
  126   1        PWMB_CNTRH = 0x00;
  127   1        PWMB_CNTRL = 0x00;
  128   1        while (((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) < micros){
  129   2        }
  130   1      }
  131          
  132          void jump(){
  133   1      
  134   1        uint8_t value;
  135   1      
  136   1        EA = 0;
  137   1      
  138   1        IAP_ENABLE();                           //ËÆæÁΩÆÁ≠âÂæÖÊó∂Èó¥ÔºåÂÖÅËÆ∏IAPÊìç‰ΩúÔºåÈÄÅ‰∏ÄÊ¨°Â∞±Â§ü
  139   1          IAP_READ();                             
  140   1      
  141   1        IAP_ADDRE = (uint8_t)(EEPROM_START_ADD >> 16); 
  142   1        IAP_ADDRH = (uint8_t)(EEPROM_START_ADD >> 8);  
  143   1        IAP_ADDRL = (uint8_t)EEPROM_START_ADD;         
  144   1        IAP_TRIG = 0x5A;
  145   1        IAP_TRIG = 0xA5;                   
  146   1        _nop_();   
  147   1        _nop_();
  148   1        _nop_();
  149   1        _nop_();
  150   1        while(CMD_FAIL);
  151   1      
  152   1        value = IAP_DATA;            //ËØªÂá∫ÁöÑÊï∞ÊçÆÈÄÅÂæÄ
  153   1      
  154   1        IAP_DISABLE();
  155   1      
  156   1      #ifdef USE_ADC_INPUT
               #else
  158   1        if (value != 0x01){      // check first byte of eeprom to see if its programmed, if not do not jump
  159   2          invalid_command = 0;
  160   2          return;
  161   2        }
  162   1      #endif
  163   1         JumpToApplication();
  164   1      }
  165          
  166          
  167          void makeCrc(uint8_t* pBuff, uint16_t length){
  168   1        uint16_t i;
  169   1        uint8_t xb;
  170   1        static uint8_16_u CRC_16;
  171   1        
  172   1        CRC_16.word=0;
  173   1        for(i = 0; i < length; i++) {
  174   2          uint8_t j;
  175   2          xb = pBuff[i];
  176   2          for ( j = 0; j < 8; j++)
  177   2          {
  178   3            if (((xb & 0x01) ^ (CRC_16.word & 0x0001)) !=0 ) {
  179   4              CRC_16.word = CRC_16.word >> 1;
  180   4              CRC_16.word = CRC_16.word ^ 0xA001;
  181   4            } else {
  182   4              CRC_16.word = CRC_16.word >> 1;
  183   4            }
  184   3            xb = xb >> 1;
  185   3          }
  186   2        }
  187   1        calculated_crc_low_byte = CRC_16.bytes[0];
  188   1        calculated_crc_high_byte = CRC_16.bytes[1];
  189   1      }
  190          
C251 COMPILER V5.60.0,  main                                                               21/10/24  00:33:04  PAGE 4   

  191          char checkCrc(uint8_t* pBuff, uint16_t length){
  192   1      
  193   1        char received_crc_low_byte2 = pBuff[length];          // one higher than len in buffer
  194   1        char received_crc_high_byte2 = pBuff[length+1];
  195   1        makeCrc(pBuff,length);
  196   1        if((calculated_crc_low_byte==received_crc_low_byte2)   && (calculated_crc_high_byte==received_crc_high_b
             -yte2)){
  197   2          return 1;
  198   2        }else{
  199   2          return 0;
  200   2        }
  201   1      
  202   1      }
  203          
  204          //ÂæÖÊîπÔºàÊé•Êî∂ÂºïËÑöÂàùÂßãÂåñÔºâ‰∏äÊãâËæìÂÖ•
  205          void setReceive(void){
  206   1        GPIO_INPUT_INIT();
  207   1        received = 0;
  208   1      }
  209          //ÂæÖÊîπÔºàÂèëÈÄÅÂºïËÑöÂàùÂßãÂåñÔºâ
  210          void setTransmit(void){
  211   1        // LL_GPIO_SetPinMode(input_port, input_pin, LL_GPIO_MODE_OUTPUT);       // set as reciever // clear bit
             -s and set receive bits..
  212   1        P0PU &= ~0x02; P0PD &= ~0x02;   //Êó†‰∏ä‰∏ãÊãâ
  213   1        P0M0 |= 0x02; P0M1 &= ~0x02;  //Êé®ÊåΩËæìÂá∫
  214   1      }
  215          
  216          void send_ACK(void){
  217   1          setTransmit();
  218   1          serialwriteChar(0x30);             // good ack!
  219   1        setReceive();
  220   1      }
  221          
  222          void send_BAD_ACK(void){
  223   1        setTransmit();
  224   1        serialwriteChar(0xC1);                // bad command message.
  225   1        setReceive();
  226   1      }
  227          
  228          void send_BAD_CRC_ACK(){
  229   1          setTransmit();
  230   1        serialwriteChar(0xC2);                // bad command message.
  231   1        setReceive();
  232   1      }
  233          
  234          void sendDeviceInfo(){
  235   1        setTransmit();
  236   1        sendString(deviceInfo,9);
  237   1        setReceive();
  238   1      }
  239          
  240          bool checkAddressWritable(uint32_t address) {
  241   1        return address >= APPLICATION_ADDRESS;
  242   1      }
  243          
  244          void decodeInput(){
  245   1        if(incoming_payload_no_command){
  246   2          len = payload_buffer_size;
  247   2        //  received_crc_low_byte = rxBuffer[len];          // one higher than len in buffer
  248   2        //  received_crc_high_byte = rxBuffer[len+1];
  249   2          if(checkCrc(rxBuffer,len)){
  250   3            uint16_t i;
  251   3            memset(payLoadBuffer, 0, sizeof(payLoadBuffer));             // reset buffer
  252   3      
  253   3            for(i = 0; i < len; i++){
  254   4              payLoadBuffer[i]= rxBuffer[i];
C251 COMPILER V5.60.0,  main                                                               21/10/24  00:33:04  PAGE 5   

  255   4            }
  256   3            send_ACK();
  257   3            incoming_payload_no_command = 0;
  258   3            return;
  259   3          }else{
  260   3            send_BAD_CRC_ACK();
  261   3            return;
  262   3          }
  263   2        }
  264   1      
  265   1        cmd = rxBuffer[0];
  266   1        printf("cmd:%X\n",cmd);
  267   1      
  268   1        if(rxBuffer[16] == 0x7d){
  269   2          if(rxBuffer[8] == 13 && rxBuffer[9] == 66){
  270   3            sendDeviceInfo();
  271   3            rxBuffer[20]= 0;
  272   3      
  273   3          }
  274   2          return;
  275   2        }
  276   1      
  277   1        if(rxBuffer[20] == 0x7d){
  278   2          if(rxBuffer[12] == 13 && rxBuffer[13] == 66){
  279   3            sendDeviceInfo();
  280   3            rxBuffer[20]= 0;
  281   3            return;
  282   3          }
  283   2      
  284   2        }
  285   1        if(rxBuffer[40] == 0x7d){
  286   2          if(rxBuffer[32] == 13 && rxBuffer[33] == 66){
  287   3            sendDeviceInfo();
  288   3            rxBuffer[20]= 0;
  289   3            return;
  290   3          }
  291   2        }
  292   1      
  293   1        if(cmd == CMD_RUN){         // starts the main app
  294   2          if((rxBuffer[1] == 0) && (rxBuffer[2] == 0) && (rxBuffer[3] == 0)){
  295   3            invalid_command = 101;
  296   3          }
  297   2        }
  298   1      
  299   1        if(cmd == CMD_PROG_FLASH){
  300   2          len = 2;
  301   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  302   3            send_BAD_CRC_ACK();
  303   3      
  304   3            return;
  305   3          }
  306   2      
  307   2          if (!checkAddressWritable(address)) {
  308   3            send_BAD_ACK();
  309   3      
  310   3            return;
  311   3          }
  312   2      
  313   2          save_flash_nolib((uint8_t*)payLoadBuffer, payload_buffer_size,address);
  314   2          send_ACK();
  315   2      
  316   2          return;
  317   2        }
  318   1      
  319   1        if(cmd == CMD_SET_ADDRESS){             //  command set addressinput format is: CMD, 00 , High byte addr
             -ess, Low byte address, crclb ,crchb
C251 COMPILER V5.60.0,  main                                                               21/10/24  00:33:04  PAGE 6   

  320   2          len = 4;  // package without 2 byte crc
  321   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  322   3            send_BAD_CRC_ACK();
  323   3      
  324   3            return;
  325   3          }
  326   2      
  327   2      
  328   2            // will send Ack 0x30 and read input after transfer out callback
  329   2          invalid_command = 0;
  330   2          address = STC32_FLASH_START + (rxBuffer[2] << 8 | rxBuffer[3]);
  331   2          send_ACK();
  332   2      
  333   2          return;
  334   2        }
  335   1      
  336   1        if(cmd == CMD_SET_BUFFER){        // for writing buffer rx buffer 0 = command byte.  command set address
             -, input , format is CMD, 00 , 00 or 01 (if buffer is 256), buffer_size,
  337   2          len = 4;  // package without 2 byte crc
  338   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  339   3            send_BAD_CRC_ACK();
  340   3      
  341   3            return;
  342   3          }
  343   2      
  344   2              // no ack with command set buffer;
  345   2              if(rxBuffer[2] == 0x01){
  346   3                payload_buffer_size = 256;                          // if nothing in this buffer
  347   3              }else{
  348   3                payload_buffer_size = rxBuffer[3];
  349   3              }
  350   2            incoming_payload_no_command = 1;
  351   2            address_expected_increment = 256;
  352   2              setReceive();
  353   2      
  354   2              return;
  355   2        }
  356   1      
  357   1        if(cmd == CMD_KEEP_ALIVE){
  358   2          len = 2;
  359   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  360   3            send_BAD_CRC_ACK();
  361   3      
  362   3            return;
  363   3          }
  364   2      
  365   2            setTransmit();
  366   2          serialwriteChar(0xC1);                // bad command message.
  367   2          setReceive();
  368   2      
  369   2          return;
  370   2        }
  371   1      
  372   1        if(cmd == CMD_ERASE_FLASH){
  373   2          len = 2;
  374   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  375   3            send_BAD_CRC_ACK();
  376   3      
  377   3            return;
  378   3          }
  379   2      
  380   2          if (!checkAddressWritable(address)) {
  381   3            send_BAD_ACK();
  382   3      
  383   3            return;
  384   3          }
C251 COMPILER V5.60.0,  main                                                               21/10/24  00:33:04  PAGE 7   

  385   2      
  386   2          send_ACK();
  387   2          return;
  388   2        }
  389   1      
  390   1        if(cmd == CMD_READ_EEPROM){
  391   2          eeprom_req = 1;
  392   2        }
  393   1      
  394   1        if(cmd == CMD_READ_FLASH_SIL){     // for sending contents of flash memory at the memory location set in
             - bootloader.c need to still set memory with data from set mem command
  395   2          uint16_t out_buffer_size;
  396   2          uint8_t xdata* read_data;
  397   2          len = 2;
  398   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  399   3            send_BAD_CRC_ACK();
  400   3      
  401   3            return;
  402   3          }
  403   2      
  404   2          count++;
  405   2          out_buffer_size = rxBuffer[1];//
  406   2          if(out_buffer_size == 0){
  407   3            out_buffer_size = 256;
  408   3          }
  409   2          address_expected_increment = 128;
  410   2          read_data = (uint8_t xdata*)malloc(out_buffer_size + 3);
  411   2          setTransmit();                            // make buffer 3 larger to fit CRC and ACK
  412   2          memset(read_data, 0, sizeof(read_data));
  413   2              //    read_flash((uint8_t*)read_data , address);                  // make sure read_flash reads t
             -wo less than buffer.
  414   2          read_flash_bin((uint8_t*)read_data , address, out_buffer_size);
  415   2      
  416   2              makeCrc(read_data,out_buffer_size);
  417   2              read_data[out_buffer_size] = calculated_crc_low_byte;
  418   2              read_data[out_buffer_size + 1] = calculated_crc_high_byte;
  419   2              read_data[out_buffer_size + 2] = 0x30;
  420   2              sendString(read_data, out_buffer_size+3);
  421   2      
  422   2          setReceive();
  423   2          free(read_data);
  424   2          return;
  425   2        }
  426   1      
  427   1          setTransmit();
  428   1      
  429   1        serialwriteChar(0xC1);                // bad command message.
  430   1        invalid_command++;
  431   1        setReceive();
  432   1      }
  433          
  434          void serialreadChar()
  435          {
  436   1        uint8_t bits_to_read;
  437   1        rxbyte=0;
  438   1      
  439   1        PWMB_PSCRL = 0xBF; // set to 1/4mhz
  440   1        PWMB_CNTRH = 0;
  441   1        PWMB_CNTRL = 0;
  442   1        while(~input_pin){ // wait for rx to go high
  443   2          if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 50000){
  444   3            invalid_command = 101;
  445   3            return;
  446   3          }
  447   2        }
  448   1      
C251 COMPILER V5.60.0,  main                                                               21/10/24  00:33:04  PAGE 8   

  449   1      
  450   1        PWMB_PSCRL = 0x2F; // set Buck to 1MHz
  451   1        PWMB_CNTRH = 0;
  452   1        PWMB_CNTRL = 0;
  453   1        while(input_pin){   // wait for it go go low
  454   2          if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 250 && messagereceived){
  455   3            return;
  456   3          }
  457   2        }
  458   1      
  459   1        delayMicroseconds(HALFBITTIME);//wait to get the center of bit time
  460   1      
  461   1        bits_to_read = 0;
  462   1        while (bits_to_read < 8) {
  463   2          delayMicroseconds(BITTIME);
  464   2          rxbyte = rxbyte | (uint8_t)input_pin << bits_to_read;
  465   2          bits_to_read++;
  466   2        }
  467   1      
  468   1        delayMicroseconds(HALFBITTIME); //wait till the stop bit time begins
  469   1        messagereceived = 1;
  470   1        receviedByte = rxbyte;
  471   1        
  472   1      }
  473          
  474          void serialwriteChar(char dat)
  475          {
  476   1      
  477   1        //BRR Âè™ÂÜôÂØÑÂ≠òÂô®ÔºöÂè™ËÉΩÊîπÂèòÁÆ°ËÑöÁä∂ÊÄÅ‰∏∫‰ΩéÁîµÂπ≥ÔºåÂØπÂØÑÂ≠òÂô® ÁÆ°ËÑöÂØπ‰∫é‰ΩçÂÜô 1 Áõ∏Â∫îÁ
             -Æ°ËÑö‰ºö‰∏∫‰ΩéÁîµÂπ≥„ÄÇÂÜô 0 Êó†Âä®‰Ωú„ÄÇ
  478   1        // input_port->BRR = input_pin;; //initiate start bit
  479   1        char bits_to_read = 0;
  480   1      
  481   1        input_pin = 0;          //initiate start bit
  482   1      
  483   1        
  484   1        while (bits_to_read < 8) {
  485   2      
  486   2          delayMicroseconds(BITTIME);
  487   2      
  488   2          if (dat & 0x01) {
  489   3            // input_port->BSRR = input_pin;
  490   3            input_pin = 1;
  491   3          }else{
  492   3            // input_port->BRR = input_pin;
  493   3            input_pin = 0;
  494   3          }
  495   2          bits_to_read++;
  496   2          dat = dat >> 1;
  497   2        }
  498   1      
  499   1        delayMicroseconds(BITTIME);
  500   1      
  501   1        // input_port->BSRR = input_pin; //write the stop bit
  502   1      
  503   1      
  504   1        input_pin = 1;          //write the stop bit
  505   1      
  506   1      
  507   1        // if more than one byte a delay is needed after stop bit,
  508   1        //if its the only one no delay, the sendstring function adds delay after each bit
  509   1      
  510   1        //if(cmd == 255 || cmd == 254 || cmd == 1  || incoming_payload_no_command){
  511   1        //
  512   1        //}else{
  513   1        //  delayMicroseconds(BITTIME);
C251 COMPILER V5.60.0,  main                                                               21/10/24  00:33:04  PAGE 9   

  514   1        //}
  515   1      }
  516          
  517          void sendString(uint8_t *dat, int len){
  518   1        int i;
  519   1        for(i = 0; i < len; i++){
  520   2          serialwriteChar(dat[i]);
  521   2          delayMicroseconds(BITTIME);
  522   2        }
  523   1      }
  524          
  525          void recieveBuffer(void){
  526   1      
  527   1        int i = 0;
  528   1        count = 0;
  529   1        messagereceived = 0;
  530   1        memset(rxBuffer, 0, sizeof(rxBuffer));
  531   1      
  532   1        for(i = 0; i < sizeof(rxBuffer); i++){
  533   2          serialreadChar();
  534   2          if(incoming_payload_no_command){
  535   3            if(count == payload_buffer_size+2){
*** WARNING C173 IN LINE 535 OF Bootloader\src\main.c: '==': signed/unsigned type mismatch
  536   4              
  537   4              break;
  538   4            }
  539   3            rxBuffer[i] = rxbyte;
  540   3            count++;
  541   3          }else{
  542   3            if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 250){
  543   4            count = 0;
  544   4            break;
  545   4            }else{
  546   4            rxBuffer[i] = rxbyte;
  547   4            if(i == 257){
  548   5              invalid_command+=20;       // needs one hundred to trigger a jump but will be reset on next set addre
             -ss commmand
  549   5      
  550   5              }
  551   4            }
  552   3          }
  553   2        }
  554   1      
  555   1        for(i = 0; i < 30; i++)
  556   1          printf("Buffer[%d]:%c\r\n",i,rxBuffer[i]);
  557   1      
  558   1        decodeInput();
  559   1      }
  560          
  561          void update_EEPROM(void){
  562   1        
  563   1        read_flash_bin(rxBuffer , EEPROM_START_ADD , 48);
  564   1      
  565   1        // printf("Buffer:%s\n",rxBuffer);
  566   1        if(BOOTLOADER_VERSION != rxBuffer[2]){
  567   2          if (rxBuffer[2] == 0xFF || rxBuffer[2] == 0x00){
  568   3            return;
  569   3          }
  570   2          rxBuffer[2] = BOOTLOADER_VERSION;
  571   2          save_flash_nolib(rxBuffer, 48, EEPROM_START_ADD);
  572   2        }
  573   1      }
  574          
  575          void checkForSignal(void){
  576   1        //uint8_t floating_or_signal= 0;
  577   1        // LL_GPIO_SetPinPull(input_port, input_pin, LL_GPIO_PULL_DOWN);
C251 COMPILER V5.60.0,  main                                                               21/10/24  00:33:04  PAGE 10  

  578   1        int i;
  579   1      
  580   1        P0PU &= ~0x02; //ÂÖ≥Èó≠‰∏äÊãâÁîµÈòª
  581   1        P0PD |= 0x02; //ÂºÄÂêØ‰∏ãÊãâÁîµÈòª
  582   1      
  583   1        delayMicroseconds(500);
  584   1      
  585   1        for(i = 0 ; i < 500; i ++){
  586   2      
  587   2          if(~input_pin){
  588   3            low_pin_count++;
  589   3          }else{
  590   3        //   high_pin_count++;
  591   3          }
  592   2          delayMicroseconds(10);
  593   2        }
  594   1      
  595   1        if(low_pin_count == 0){
  596   2          return;           // all high while pin is pulled low, bootloader signal
  597   2        }
  598   1      
  599   1        low_pin_count = 0;
  600   1      
  601   1        P0PU &= ~0x02; //ÂÖ≥Èó≠‰∏äÊãâÁîµÈòª
  602   1        P0PD &= ~0x02; //ÂÖ≥Èó≠‰∏ãÊãâÁîµÈòª 
  603   1        // LL_GPIO_SetPinPull(input_port, input_pin, LL_GPIO_PULL_NO);
  604   1        delayMicroseconds(500);
  605   1      
  606   1        for(i = 0 ; i < 500; i ++){
  607   2          if(~input_pin){
  608   3            low_pin_count++;
  609   3          }
  610   2          delayMicroseconds(10);
  611   2        }
  612   1      
  613   1        if(low_pin_count == 0){
  614   2          return;            // when floated all
  615   2        }
  616   1      
  617   1        if(low_pin_count > 0){
  618   2          jump();
  619   2        }
  620   1      }
  621          
  622          
  623          void Uart1_Init(void) //921600bps@48MHz
  624          {
  625   1        SCON = 0x50;    //8‰ΩçÊï∞ÊçÆ,ÂèØÂèòÊ≥¢ÁâπÁéá
  626   1        AUXR |= 0x01;   //‰∏≤Âè£1ÈÄâÊã©ÂÆöÊó∂Âô®2‰∏∫Ê≥¢ÁâπÁéáÂèëÁîüÂô®
  627   1        AUXR |= 0x04;   //ÂÆöÊó∂Âô®Êó∂Èíü1TÊ®°Âºè
  628   1        T2L = 0xF3;     //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
  629   1        T2H = 0xFF;     //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
  630   1        AUXR |= 0x10;   //ÂÆöÊó∂Âô®2ÂºÄÂßãËÆ°Êó∂
  631   1      
  632   1      
  633   1        P3M0 |= 0x03; P3M1 &= ~0x03; 
  634   1        P2M0 |= 0x03; P2M1 &= ~0x03; 
  635   1      }
  636          
  637          
  638          uint8_t xdata MEMPOOL[512];
  639          
  640          int main(void)
  641          {
  642   1        
  643   1        //Prevent warnings
C251 COMPILER V5.60.0,  main                                                               21/10/24  00:33:04  PAGE 11  

  644   1        (void)bootloader_version;
*** WARNING C138 IN LINE 644 OF Bootloader\src\main.c: expression with possibly no effect
  645   1      
  646   1          SystemClock_Config();
  647   1      
  648   1        IAP_TPS =48;  //ËÆæÁΩÆIAPÁ≠âÂæÖÊó∂Èó¥
  649   1      
  650   1        PWMB_Timer_Init();
  651   1      
  652   1          GPIO_INPUT_INIT();     // init the pin with a pulldown
  653   1      
  654   1        Uart1_Init();
  655   1      
  656   1        init_mempool(MEMPOOL,512);
  657   1        
  658   1          checkForSignal();
  659   1        
  660   1        P0PD &= ~0x02;
  661   1        P0PU |= 0x02;     //‰∏äÊãâËæìÂÖ•
  662   1      
  663   1          deviceInfo[3] = 0x14;
  664   1      
  665   1        update_EEPROM();
  666   1          while (1)
  667   1          {
  668   2            recieveBuffer();
  669   2            if (invalid_command > 100){
  670   3              // jump();
  671   3            
  672   3            }
  673   2          P20 = ~P20;
  674   2          }
  675   1      }
  676          
  677          
  678          
  679          void SystemClock_Config(void)
  680          {
  681   1        EA = 0;
  682   1      
  683   1        CKCON = 0x00;           // ËÆæÁΩÆÂ§ñÈÉ®Êï∞ÊçÆÊÄªÁ∫ø‰∏∫ÊúÄÂø´
  684   1        WTST = 1;                 // ËÆæÁΩÆÁ®ãÂ∫è‰ª£Á†ÅÁ≠âÂæÖÂèÇÊï∞ÔºåËµãÂÄº‰∏∫0ÂèØÂ∞ÜCPUÊâßË°åÁ®ãÂ∫èÁöÑÈÄüÂ∫¶ËÆæ
             -ÁΩÆ‰∏∫ÊúÄÂø´
  685   1        P_SW2 = 0x80;         // ÂºÄÂêØÁâπÊÆäÂú∞ÂùÄËÆøÈóÆ
  686   1      
  687   1        CLKDIV = 0x04;      //‰∏ªÊó∂ÈíüMCLKËæìÂá∫Âà∞Á≥ªÁªüÊó∂Èíü(SYSCLK)ÂàÜÈ¢ë1
  688   1        
  689   1        IRTRIM = CHIPID12;        //ÂÜÖÈÉ®Êó∂ÈíüÊ∫êÈÄâÊã©24M
  690   1        HIRCSEL1 = 1;
  691   1        HIRCSEL0 = 0;       //27MhzÈ¢ëÊÆµ
  692   1      
  693   1        HIRCCR = 0x80;
  694   1        while (!(HIRCCR & 0x01));
  695   1        
  696   1        // MCLKOCR = 72;          //ÂàÜÈ¢ë72,ËæìÂá∫Êó∂ÈíüÁöÑÂàÜÈ¢ë
  697   1      
  698   1        CLKSEL = 0x40;      //PLL,È´òÈÄüIOÔºåÁ≥ªÁªüÊó∂ÈíüÊ∫êÁöÑÁõ∏ÂÖ≥ËÆæÁΩÆ(ÂÖàÈÄâÊã©ÂÜÖÈÉ®IRC‰Ωú‰∏∫Á≥ªÁªüÊó∂Èíü)
  699   1      
  700   1        USBCLK &= 0x0F;
  701   1        USBCLK |= 0xA0;
  702   1        NOP(5);         //Á≠âÂæÖÊó∂ÈíüÁ®≥ÂÆö
  703   1      
  704   1        //PLL‰∫ßÁîü96MhzÊó∂Èíü
  705   1      
  706   1        CLKDIV = 0X01;      //‰∏ªÊó∂ÈíüMCLKËæìÂá∫Âà∞Á≥ªÁªüÊó∂Èíü(SYSCLK)ÂàÜÈ¢ë1
  707   1      
C251 COMPILER V5.60.0,  main                                                               21/10/24  00:33:04  PAGE 12  

  708   1        CLKSEL |= 0x08;     //MCLKÈÄâÊã©PLL/2‰∏∫Êó∂ÈíüÊ∫ê->48Mhz
  709   1      
  710   1        HSCLKDIV = 0x01;    //È´òÈÄüPWM,SPI,I2S,TFPUÊó∂Èíü96MHz
  711   1      
  712   1        USBCKS = 1;       
  713   1        USBCKS2 = 0;      //USBÊó∂ÈíüÈÄâÊã©48Mhz
  714   1      
  715   1        EA = 1;
  716   1      }
  717          
  718          
  719          static void PWMB_Timer_Init(void)
  720          {
  721   1      //Áî±‰∫éÊú™ÂºÄÂêØÈ´òÈÄüPWMÊâÄ‰ª•PWMBÁöÑÊó∂ÈíüÊ∫ê‰∏∫48Mhz
  722   1      
  723   1        PWMB_ENO = 0x00;    //Á¶ÅÊ≠¢PWMBÁöÑPWMËæìÂá∫
  724   1        PWMB_IOAUX = 0x00;    //Á¶ÅÊ≠¢PWMB
  725   1      
  726   1        PWMB_ARRH = 0xFF;
  727   1        PWMB_ARRL = 0xFF;   //ËÆæÁΩÆPWMBÂë®Êúü‰∏∫65535
  728   1        PWMB_CNTRH = 0x00;
  729   1        PWMB_CNTRL = 0x00;    //Ê∏ÖÈõ∂ËÆ°Êï∞Âô®
  730   1        PWMB_PSCRH = 0x00;    
  731   1        PWMB_PSCRL = 47;    //PWMBÊó∂ÈíüÊ∫êÂàÜÈ¢ëÂà∞1Mhz
  732   1        PWMB_IER = 0x00;    //Á¶ÅÊ≠¢PWMB‰∏≠Êñ≠
  733   1        PWMB_CR1 = 0x01;    //‰ΩøËÉΩËÆ°Êï∞Âô®
  734   1      }
  735          
  736          
  737          
  738          static void GPIO_INPUT_INIT(void)
  739          {
  740   1      #ifdef USE_PB4
               #endif
  742   1      #ifdef USE_PA2
               #endif
  744   1      
  745   1        P0M0 = 0x00; P0M1 = 0xff; 
  746   1      
  747   1          P0IE |= 0x02; 
  748   1        P0PU |= 0x02; 
  749   1        //È´òÈòª‰∏äÊãâËæìÂÖ•
  750   1      }
  751          
  752          
  753          #pragma FUNCTIONS (static)
  754          char putchar(char c)
  755          {
  756   1        // serialwriteChar(c);
  757   1        SBUF = c;
  758   1        while (!TI);
  759   1        TI = 0;
  760   1        return c;
  761   1      }
  762          
  763          
  764          
  765          
  766          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2208     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
C251 COMPILER V5.60.0,  main                                                               21/10/24  00:33:04  PAGE 13  

  pdata size           =    ------     ------
  xdata size           =       512     ------
  xdata-const size     =    ------     ------
  edata size           =       569     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       107     ------
End of Module Information.


C251 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)

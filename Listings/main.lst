C251 COMPILER V5.60.0,  main                                                               21/10/24  11:38:10  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Compiler\Keil_v5\C251\BIN\C251.EXE Bootloader\src\main.c XSMALL FUNCTIONS(REENTRANT) FLOAT64 WAR
                    -NINGLEVEL(3) OPTIMIZE(3,SPEED) BROWSE INCDIR(.\Bootloader\inc) DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects
                    -\main.obj) 

stmt  level    source

    1          /* Bootloader */
    2          
    3          #define BOOTLOADER_VERSION 10
    4          
    5          #define USE_P01
    6          /* Includes ------------------------------------------------------------------*/
    7          #include "nstdbool.h"
    8          #include "main.h"
    9          #include <stdio.h>
   10          //#define USE_ADC_INPUT      // will go right to application and ignore eeprom
   11          
   12          #include "nstdint.h"
   13          #include <stdlib.h>
   14          #include <string.h>
   15          #include "bootloader.h"
   16          
   17          #define STC32_FLASH_START     0x0000
   18          #define FIRMWARE_RELATIVE_START 0x1000
   19          #define EEPROM_RELATIVE_START   0xFFFF - 0x400
   20          
   21          uint8_t code bootloader_version = BOOTLOADER_VERSION;
   22          
   23          typedef void (*pFunction)(void);
   24          
   25          #define APPLICATION_ADDRESS     (uint32_t)(STC32_FLASH_START + FIRMWARE_RELATIVE_START) // 4k
   26          
   27          #define EEPROM_START_ADD         (uint32_t)(STC32_FLASH_START + EEPROM_RELATIVE_START)
   28          #define FLASH_END_ADD           (uint32_t)(STC32_FLASH_START + 0xFFFF)               // 32 k
   29          
   30          
   31          #define CMD_RUN             0x00
   32          #define CMD_PROG_FLASH      0x01
   33          #define CMD_ERASE_FLASH     0x02
   34          #define CMD_READ_FLASH_SIL  0x03
   35          #define CMD_VERIFY_FLASH    0x03
   36          #define CMD_VERIFY_FLASH_ARM 0x04
   37          #define CMD_READ_EEPROM     0x04
   38          #define CMD_PROG_EEPROM     0x05
   39          #define CMD_READ_SRAM       0x06
   40          #define CMD_READ_FLASH_ATM  0x07
   41          #define CMD_KEEP_ALIVE      0xFD
   42          #define CMD_SET_ADDRESS     0xFF
   43          #define CMD_SET_BUFFER      0xFE
   44          
   45          
   46          #ifdef USE_P01
   47          
   48          #define input_pin        P01
   49          #define input_port       P0
   50          #define PIN_NUMBER       0
   51          #define PORT_LETTER      0
   52          
   53          #endif
   54          
   55          #ifdef USE_PB4
               // #define input_pin       LL_GPIO_PIN_4
               // #define input_port        GPIOB
C251 COMPILER V5.60.0,  main                                                               21/10/24  11:38:10  PAGE 2   

               // #define PIN_NUMBER        4
               // #define PORT_LETTER       1
               #endif
   61          
   62          
   63          uint16_t low_pin_count = 0;
   64          char receviedByte;
   65          int receivedCount;
   66          int count = 0;
   67          char messagereceived = 0;
   68          uint16_t invalid_command = 0;
   69          uint16_t address_expected_increment;
   70          int cmd = 0;
   71          char eeprom_req = 0;
   72          int received;
   73          uint8_t port_letter;
   74          
   75          
   76          uint8_t pin_code = 0;
   77          uint8_t deviceInfo[9] = { 0x34,0x37,0x31,0x00,0x1f,0x06,0x06,0x01,0x30 };      // stm32 device info
   78          
   79          size_t str_len;
   80          char connected = 0;
   81          uint8_t rxBuffer[258];
   82          uint8_t payLoadBuffer[256];
   83          char rxbyte=0;
   84          uint32_t address;
   85          int tick = 0;
   86          
   87          typedef union {
   88              uint8_t bytes[2];
   89              uint16_t word;
   90          } uint8_16_u;
   91          uint16_t len;
   92          uint8_t received_crc_low_byte;
   93          uint8_t received_crc_high_byte;
   94          uint8_t calculated_crc_low_byte;
   95          uint8_t calculated_crc_high_byte;
   96          uint16_t payload_buffer_size;
   97          char incoming_payload_no_command = 0;
   98          
   99          char bootloaderactive = 1;
  100          
  101          uint32_t JumpAddress;
  102          // pFunction JumpToApplication;
  103          #define JumpToApplication()   IAP_CONTR = 0x20
  104          
  105          
  106          void SystemClock_Config(void);
  107          static void PWMB_Timer_Init(void);
  108          
  109          /* USER CODE BEGIN PFP */
  110          static void GPIO_INPUT_INIT(void);
  111          
  112          void processmessage(void);
  113          void serialwriteChar(char dat);
  114          void sendString(uint8_t dat[], int len);
  115          void recieveBuffer();
  116          
  117          #define BAUDRATE              19200
  118          #define BITTIME          1000000/BAUDRATE
  119          #define HALFBITTIME       500000/BAUDRATE
  120          
  121          //ÂæÖÊîπÔºà‰ΩøÁî®ÂÆöÊó∂Âô®ÂÅöÂª∂Êó∂ÂáΩÊï∞Ôºâ
  122          void delayMicroseconds(uint32_t micros){
  123   1        // TIM2->CNT = 0;
C251 COMPILER V5.60.0,  main                                                               21/10/24  11:38:10  PAGE 3   

  124   1        PWMB_CNTRH = 0x00;
  125   1        PWMB_CNTRL = 0x00;
  126   1        while (((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) < micros){
  127   2        }
  128   1      }
  129          
  130          void jump(){
  131   1      
  132   1        uint8_t value;
  133   1      
  134   1        EA = 0;
  135   1      
  136   1        IAP_ENABLE();                           //ËÆæÁΩÆÁ≠âÂæÖÊó∂Èó¥ÔºåÂÖÅËÆ∏IAPÊìç‰ΩúÔºåÈÄÅ‰∏ÄÊ¨°Â∞±Â§ü
  137   1          IAP_READ();                             
  138   1      
  139   1        IAP_ADDRE = (uint8_t)(EEPROM_START_ADD >> 16); 
  140   1        IAP_ADDRH = (uint8_t)(EEPROM_START_ADD >> 8);  
  141   1        IAP_ADDRL = (uint8_t)EEPROM_START_ADD;         
  142   1        IAP_TRIG = 0x5A;
  143   1        IAP_TRIG = 0xA5;                   
  144   1        _nop_();   
  145   1        _nop_();
  146   1        _nop_();
  147   1        _nop_();
  148   1        while(CMD_FAIL);
  149   1      
  150   1        value = IAP_DATA;            //ËØªÂá∫ÁöÑÊï∞ÊçÆÈÄÅÂæÄ
  151   1      
  152   1        IAP_DISABLE();
  153   1      
  154   1      #ifdef USE_ADC_INPUT
               #else
  156   1        if (value != 0x01){      // check first byte of eeprom to see if its programmed, if not do not jump
  157   2          invalid_command = 0;
  158   2          return;
  159   2        }
  160   1      #endif
  161   1         JumpToApplication();
  162   1      }
  163          
  164          
  165          void makeCrc(uint8_t* pBuff, uint16_t length){
  166   1        uint16_t i;
  167   1        uint8_t xb;
  168   1        static uint8_16_u CRC_16;
  169   1        
  170   1        CRC_16.word=0;
  171   1        for(i = 0; i < length; i++) {
  172   2          uint8_t j;
  173   2          xb = pBuff[i];
  174   2          for ( j = 0; j < 8; j++)
  175   2          {
  176   3            if (((xb & 0x01) ^ (CRC_16.word & 0x0001)) !=0 ) {
  177   4              CRC_16.word = CRC_16.word >> 1;
  178   4              CRC_16.word = CRC_16.word ^ 0xA001;
  179   4            } else {
  180   4              CRC_16.word = CRC_16.word >> 1;
  181   4            }
  182   3            xb = xb >> 1;
  183   3          }
  184   2        }
  185   1        calculated_crc_low_byte = CRC_16.bytes[1];        //C251ÊòØÂ§ßÁ´ØÁºñËØëÊ®°Âºè
  186   1        calculated_crc_high_byte = CRC_16.bytes[0];
  187   1      }
  188          
  189          char checkCrc(uint8_t* pBuff, uint16_t length){
C251 COMPILER V5.60.0,  main                                                               21/10/24  11:38:10  PAGE 4   

  190   1      
  191   1        uint8_t received_crc_low_byte2 = pBuff[length];          // one higher than len in buffer
  192   1        uint8_t received_crc_high_byte2 = pBuff[length+1];
  193   1        makeCrc(pBuff,length);
  194   1        if((calculated_crc_low_byte==received_crc_low_byte2)   && (calculated_crc_high_byte==received_crc_high_b
             -yte2)){
  195   2          return 1;
  196   2        }else{
  197   2          return 0;
  198   2        }
  199   1      
  200   1      }
  201          
  202          //ÂæÖÊîπÔºàÊé•Êî∂ÂºïËÑöÂàùÂßãÂåñÔºâ‰∏äÊãâËæìÂÖ•
  203          void setReceive(void){
  204   1        GPIO_INPUT_INIT();
  205   1        received = 0;
  206   1      }
  207          //ÂæÖÊîπÔºàÂèëÈÄÅÂºïËÑöÂàùÂßãÂåñÔºâ
  208          void setTransmit(void){
  209   1        // LL_GPIO_SetPinMode(input_port, input_pin, LL_GPIO_MODE_OUTPUT);       // set as reciever // clear bit
             -s and set receive bits..
  210   1        P0PU &= ~0x02; P0PD &= ~0x02;   //Êó†‰∏ä‰∏ãÊãâ
  211   1        P0M0 |= 0x02; P0M1 &= ~0x02;  //Êé®ÊåΩËæìÂá∫
  212   1      }
  213          
  214          void send_ACK(void){
  215   1          setTransmit();
  216   1          serialwriteChar(0x30);             // good ack!
  217   1        setReceive();
  218   1      }
  219          
  220          void send_BAD_ACK(void){
  221   1        setTransmit();
  222   1        serialwriteChar(0xC1);                // bad command message.
  223   1        setReceive();
  224   1      }
  225          
  226          void send_BAD_CRC_ACK(){
  227   1          setTransmit();
  228   1        serialwriteChar(0xC2);                // bad command message.
  229   1        setReceive();
  230   1      }
  231          
  232          void sendDeviceInfo(){
  233   1        setTransmit();
  234   1        sendString(deviceInfo,9);
  235   1        setReceive();
  236   1      }
  237          
  238          bool checkAddressWritable(uint32_t address) {
  239   1        return address >= APPLICATION_ADDRESS;
  240   1      }
  241          
  242          void decodeInput(void){
  243   1        if(incoming_payload_no_command){
  244   2          len = payload_buffer_size;
  245   2        //  received_crc_low_byte = rxBuffer[len];          // one higher than len in buffer
  246   2        //  received_crc_high_byte = rxBuffer[len+1];
  247   2          if(checkCrc(rxBuffer,len)){
  248   3            uint16_t i;
  249   3            memset(payLoadBuffer, 0, sizeof(payLoadBuffer));             // reset buffer
  250   3      
  251   3            for(i = 0; i < len; i++){
  252   4              payLoadBuffer[i]= rxBuffer[i];
  253   4            }
C251 COMPILER V5.60.0,  main                                                               21/10/24  11:38:10  PAGE 5   

  254   3            send_ACK();
  255   3            incoming_payload_no_command = 0;
  256   3            return;
  257   3          }else{
  258   3            send_BAD_CRC_ACK();
  259   3            return;
  260   3          }
  261   2        }
  262   1      
  263   1        cmd = rxBuffer[0];
  264   1      
  265   1        if(rxBuffer[16] == 0x7d){
  266   2          if(rxBuffer[8] == 13 && rxBuffer[9] == 66){
  267   3            sendDeviceInfo();
  268   3            rxBuffer[20]= 0;
  269   3      
  270   3          }
  271   2          return;
  272   2        }
  273   1      
  274   1        if(rxBuffer[20] == 0x7d){
  275   2          if(rxBuffer[12] == 13 && rxBuffer[13] == 66){
  276   3            sendDeviceInfo();
  277   3            rxBuffer[20]= 0;
  278   3            return;
  279   3          }
  280   2      
  281   2        }
  282   1        if(rxBuffer[40] == 0x7d){
  283   2          if(rxBuffer[32] == 13 && rxBuffer[33] == 66){
  284   3            sendDeviceInfo();
  285   3            rxBuffer[20]= 0;
  286   3            return;
  287   3          }
  288   2        }
  289   1      
  290   1        if(cmd == CMD_RUN){         // starts the main app
  291   2          if((rxBuffer[1] == 0) && (rxBuffer[2] == 0) && (rxBuffer[3] == 0)){
  292   3            invalid_command = 101;
  293   3          }
  294   2        }
  295   1      
  296   1        if(cmd == CMD_PROG_FLASH){
  297   2          len = 2;
  298   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  299   3            send_BAD_CRC_ACK();
  300   3      
  301   3            return;
  302   3          }
  303   2      
  304   2          if (!checkAddressWritable(address)) {
  305   3            send_BAD_ACK();
  306   3      
  307   3            return;
  308   3          }
  309   2      
  310   2          save_flash_nolib((uint8_t*)payLoadBuffer, payload_buffer_size,address);
  311   2          send_ACK();
  312   2      
  313   2          return;
  314   2        }
  315   1      
  316   1        if(cmd == CMD_SET_ADDRESS){             //  command set addressinput format is: CMD, 00 , High byte addr
             -ess, Low byte address, crclb ,crchb
  317   2          len = 4;  // package without 2 byte crc
  318   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
C251 COMPILER V5.60.0,  main                                                               21/10/24  11:38:10  PAGE 6   

  319   3            send_BAD_CRC_ACK();
  320   3            return;
  321   3          }
  322   2      
  323   2      
  324   2            // will send Ack 0x30 and read input after transfer out callback
  325   2          invalid_command = 0;
  326   2          address = STC32_FLASH_START + (rxBuffer[2] << 8 | rxBuffer[3]);
  327   2          send_ACK();
  328   2      
  329   2          return;
  330   2        }
  331   1      
  332   1        if(cmd == CMD_SET_BUFFER){        // for writing buffer rx buffer 0 = command byte.  command set address
             -, input , format is CMD, 00 , 00 or 01 (if buffer is 256), buffer_size,
  333   2          len = 4;  // package without 2 byte crc
  334   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  335   3            send_BAD_CRC_ACK();
  336   3      
  337   3            return;
  338   3          }
  339   2      
  340   2              // no ack with command set buffer;
  341   2              if(rxBuffer[2] == 0x01){
  342   3                payload_buffer_size = 256;                          // if nothing in this buffer
  343   3              }else{
  344   3                payload_buffer_size = rxBuffer[3];
  345   3              }
  346   2            incoming_payload_no_command = 1;
  347   2            address_expected_increment = 256;
  348   2              setReceive();
  349   2      
  350   2              return;
  351   2        }
  352   1      
  353   1        if(cmd == CMD_KEEP_ALIVE){
  354   2          len = 2;
  355   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  356   3            send_BAD_CRC_ACK();
  357   3      
  358   3            return;
  359   3          }
  360   2      
  361   2            setTransmit();
  362   2          serialwriteChar(0xC1);                // bad command message.
  363   2          setReceive();
  364   2      
  365   2          return;
  366   2        }
  367   1      
  368   1        if(cmd == CMD_ERASE_FLASH){
  369   2          len = 2;
  370   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  371   3            send_BAD_CRC_ACK();
  372   3      
  373   3            return;
  374   3          }
  375   2      
  376   2          if (!checkAddressWritable(address)) {
  377   3            send_BAD_ACK();
  378   3      
  379   3            return;
  380   3          }
  381   2      
  382   2          send_ACK();
  383   2          return;
C251 COMPILER V5.60.0,  main                                                               21/10/24  11:38:10  PAGE 7   

  384   2        }
  385   1      
  386   1        if(cmd == CMD_READ_EEPROM){
  387   2          eeprom_req = 1;
  388   2        }
  389   1      
  390   1        if(cmd == CMD_READ_FLASH_SIL){     // for sending contents of flash memory at the memory location set in
             - bootloader.c need to still set memory with data from set mem command
  391   2          uint16_t out_buffer_size;
  392   2          uint8_t xdata* read_data;
  393   2          len = 2;
  394   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  395   3            send_BAD_CRC_ACK();
  396   3      
  397   3            return;
  398   3          }
  399   2      
  400   2          count++;
  401   2          out_buffer_size = rxBuffer[1];//
  402   2          if(out_buffer_size == 0){
  403   3            out_buffer_size = 256;
  404   3          }
  405   2          address_expected_increment = 128;
  406   2          read_data = (uint8_t xdata*)malloc(out_buffer_size + 3);
  407   2          setTransmit();                            // make buffer 3 larger to fit CRC and ACK
  408   2          memset(read_data, 0, sizeof(read_data));
  409   2              //    read_flash((uint8_t*)read_data , address);                  // make sure read_flash reads t
             -wo less than buffer.
  410   2          read_flash_bin((uint8_t*)read_data , address, out_buffer_size);
  411   2      
  412   2              makeCrc(read_data,out_buffer_size);
  413   2              read_data[out_buffer_size] = calculated_crc_low_byte;
  414   2              read_data[out_buffer_size + 1] = calculated_crc_high_byte;
  415   2              read_data[out_buffer_size + 2] = 0x30;
  416   2              sendString(read_data, out_buffer_size+3);
  417   2      
  418   2          setReceive();
  419   2          free(read_data);
  420   2      
  421   2          return;
  422   2        }
  423   1      
  424   1          setTransmit();
  425   1      
  426   1        serialwriteChar(0xC1);                // bad command message.
  427   1        invalid_command++;
  428   1        setReceive();
  429   1      }
  430          
  431          void serialreadChar()
  432          {
  433   1        int bits_to_read;
  434   1        rxbyte=0;
  435   1      
  436   1        PWMB_PSCRL = 0xBF; // set to 1/4mhz
  437   1        PWMB_CNTRH = 0;
  438   1        PWMB_CNTRL = 0;
  439   1        while(~input_pin){ // wait for rx to go high
  440   2          if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 50000){
  441   3            invalid_command = 101;
  442   3            return;
  443   3          }
  444   2        }
  445   1      
  446   1      
  447   1        PWMB_PSCRL = 0x2F; // set Buck to 1MHz
C251 COMPILER V5.60.0,  main                                                               21/10/24  11:38:10  PAGE 8   

  448   1        PWMB_CNTRH = 0;
  449   1        PWMB_CNTRL = 0;
  450   1        while(input_pin){   // wait for it go go low
  451   2          if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 250 && messagereceived){
  452   3            return;
  453   3          }
  454   2        }
  455   1      
  456   1        delayMicroseconds(HALFBITTIME);//wait to get the center of bit time
  457   1      
  458   1        bits_to_read = 0;
  459   1        while (bits_to_read < 8) {
  460   2          delayMicroseconds(BITTIME);
  461   2          rxbyte = rxbyte | (uint8_t)input_pin << bits_to_read;
  462   2          bits_to_read++;
  463   2        }
  464   1      
  465   1        delayMicroseconds(HALFBITTIME); //wait till the stop bit time begins
  466   1        messagereceived = 1;
  467   1        receviedByte = rxbyte;
  468   1        
  469   1      }
  470          
  471          void serialwriteChar(char dat)
  472          {
  473   1      
  474   1        //BRR Âè™ÂÜôÂØÑÂ≠òÂô®ÔºöÂè™ËÉΩÊîπÂèòÁÆ°ËÑöÁä∂ÊÄÅ‰∏∫‰ΩéÁîµÂπ≥ÔºåÂØπÂØÑÂ≠òÂô® ÁÆ°ËÑöÂØπ‰∫é‰ΩçÂÜô 1 Áõ∏Â∫îÁ
             -Æ°ËÑö‰ºö‰∏∫‰ΩéÁîµÂπ≥„ÄÇÂÜô 0 Êó†Âä®‰Ωú„ÄÇ
  475   1        // input_port->BRR = input_pin;; //initiate start bit
  476   1        char bits_to_read = 0;
  477   1      
  478   1        input_pin = 0;          //initiate start bit
  479   1      
  480   1        
  481   1        while (bits_to_read < 8) {
  482   2      
  483   2          delayMicroseconds(BITTIME);
  484   2      
  485   2          if (dat & 0x01) {
  486   3            // input_port->BSRR = input_pin;
  487   3            input_pin = 1;
  488   3          }else{
  489   3            // input_port->BRR = input_pin;
  490   3            input_pin = 0;
  491   3          }
  492   2          bits_to_read++;
  493   2          dat = dat >> 1;
  494   2        }
  495   1      
  496   1        delayMicroseconds(BITTIME);
  497   1      
  498   1        // input_port->BSRR = input_pin; //write the stop bit
  499   1      
  500   1      
  501   1        input_pin = 1;          //write the stop bit
  502   1      
  503   1      
  504   1        // if more than one byte a delay is needed after stop bit,
  505   1        //if its the only one no delay, the sendstring function adds delay after each bit
  506   1      
  507   1        //if(cmd == 255 || cmd == 254 || cmd == 1  || incoming_payload_no_command){
  508   1        //
  509   1        //}else{
  510   1        //  delayMicroseconds(BITTIME);
  511   1        //}
  512   1      }
C251 COMPILER V5.60.0,  main                                                               21/10/24  11:38:10  PAGE 9   

  513          
  514          void sendString(uint8_t *dat, int len){
  515   1        int i;
  516   1        for(i = 0; i < len; i++){
  517   2          serialwriteChar(dat[i]);
  518   2          delayMicroseconds(BITTIME);
  519   2        }
  520   1      }
  521          
  522          void recieveBuffer(void){
  523   1      
  524   1        int i = 0;
  525   1        count = 0;
  526   1        messagereceived = 0;
  527   1        memset(rxBuffer, 0, sizeof(rxBuffer));
  528   1      
  529   1        for(i = 0; i < sizeof(rxBuffer); i++){
  530   2          serialreadChar();
  531   2          if(incoming_payload_no_command){
  532   3            if(count == payload_buffer_size+2){
*** WARNING C173 IN LINE 532 OF Bootloader\src\main.c: '==': signed/unsigned type mismatch
  533   4              
  534   4              break;
  535   4            }
  536   3            rxBuffer[i] = rxbyte;
  537   3            count++;
  538   3          }else{
  539   3            if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 250){
  540   4            count = 0;
  541   4            break;
  542   4            }else{
  543   4            rxBuffer[i] = rxbyte;
  544   4            if(i == 257){
  545   5              invalid_command+=20;       // needs one hundred to trigger a jump but will be reset on next set addre
             -ss commmand
  546   5      
  547   5              }
  548   4            }
  549   3          }
  550   2        }
  551   1      
  552   1        decodeInput();
  553   1      }
  554          
  555          void update_EEPROM(void){
  556   1        
  557   1        read_flash_bin(rxBuffer , EEPROM_START_ADD , 48);
  558   1      
  559   1        if(BOOTLOADER_VERSION != rxBuffer[2]){
  560   2          if (rxBuffer[2] == 0xFF || rxBuffer[2] == 0x00){
  561   3            return;
  562   3          }
  563   2          rxBuffer[2] = BOOTLOADER_VERSION;
  564   2          save_flash_nolib(rxBuffer, 48, EEPROM_START_ADD);
  565   2        }
  566   1      }
  567          
  568          void checkForSignal(void){
  569   1        //uint8_t floating_or_signal= 0;
  570   1        // LL_GPIO_SetPinPull(input_port, input_pin, LL_GPIO_PULL_DOWN);
  571   1        int i;
  572   1      
  573   1        P0PU &= ~0x02; //ÂÖ≥Èó≠‰∏äÊãâÁîµÈòª
  574   1        P0PD |= 0x02; //ÂºÄÂêØ‰∏ãÊãâÁîµÈòª
  575   1      
  576   1        delayMicroseconds(500);
C251 COMPILER V5.60.0,  main                                                               21/10/24  11:38:10  PAGE 10  

  577   1      
  578   1        for(i = 0 ; i < 500; i ++){
  579   2      
  580   2          if(~input_pin){
  581   3            low_pin_count++;
  582   3          }else{
  583   3        //   high_pin_count++;
  584   3          }
  585   2          delayMicroseconds(10);
  586   2        }
  587   1      
  588   1        if(low_pin_count == 0){
  589   2          return;           // all high while pin is pulled low, bootloader signal
  590   2        }
  591   1      
  592   1        low_pin_count = 0;
  593   1      
  594   1        P0PU &= ~0x02; //ÂÖ≥Èó≠‰∏äÊãâÁîµÈòª
  595   1        P0PD &= ~0x02; //ÂÖ≥Èó≠‰∏ãÊãâÁîµÈòª 
  596   1        // LL_GPIO_SetPinPull(input_port, input_pin, LL_GPIO_PULL_NO);
  597   1        delayMicroseconds(500);
  598   1      
  599   1        for(i = 0 ; i < 500; i ++){
  600   2          if(~input_pin){
  601   3            low_pin_count++;
  602   3          }
  603   2          delayMicroseconds(10);
  604   2        }
  605   1      
  606   1        if(low_pin_count == 0){
  607   2          return;            // when floated all
  608   2        }
  609   1      
  610   1        if(low_pin_count > 0){
  611   2          jump();
  612   2        }
  613   1      }
  614          
  615          
  616          void Uart1_Init(void) //921600bps@48MHz
  617          {
  618   1        SCON = 0x50;    //8‰ΩçÊï∞ÊçÆ,ÂèØÂèòÊ≥¢ÁâπÁéá
  619   1        AUXR |= 0x01;   //‰∏≤Âè£1ÈÄâÊã©ÂÆöÊó∂Âô®2‰∏∫Ê≥¢ÁâπÁéáÂèëÁîüÂô®
  620   1        AUXR |= 0x04;   //ÂÆöÊó∂Âô®Êó∂Èíü1TÊ®°Âºè
  621   1        T2L = 0xF3;     //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
  622   1        T2H = 0xFF;     //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
  623   1        AUXR |= 0x10;   //ÂÆöÊó∂Âô®2ÂºÄÂßãËÆ°Êó∂
  624   1      
  625   1      
  626   1        P3M0 |= 0x03; P3M1 &= ~0x03; 
  627   1        P2M0 |= 0x03; P2M1 &= ~0x03; 
  628   1      }
  629          
  630          
  631          
  632          int main(void)
  633          {
  634   1      
  635   1        //Prevent warnings
  636   1        static uint8_t xdata MEMPOOL[1024];   //ÂÜÖÂ≠òÊ±†
  637   1        (void)bootloader_version;
*** WARNING C138 IN LINE 637 OF Bootloader\src\main.c: expression with possibly no effect
  638   1        
  639   1      
  640   1          SystemClock_Config();
  641   1        init_mempool(MEMPOOL, sizeof(MEMPOOL)); //ÂàùÂßãÂåñÂÜÖÂ≠òÊ±†
C251 COMPILER V5.60.0,  main                                                               21/10/24  11:38:10  PAGE 11  

  642   1      
  643   1        IAP_TPS =48;  //ËÆæÁΩÆIAPÁ≠âÂæÖÊó∂Èó¥
  644   1      
  645   1        PWMB_Timer_Init();
  646   1      
  647   1          GPIO_INPUT_INIT();     // init the pin with a pullup
  648   1      
  649   1        // Uart1_Init();
  650   1      
  651   1          checkForSignal();
  652   1        
  653   1        P0PD &= ~0x02;
  654   1        P0PU |= 0x02;     //‰∏äÊãâËæìÂÖ•
  655   1      
  656   1          deviceInfo[3] = pin_code;
  657   1      
  658   1        update_EEPROM();
  659   1          while (1)
  660   1          {
  661   2            recieveBuffer();
  662   2            if (invalid_command > 100){
  663   3              jump();
  664   3            }
  665   2          }
  666   1      }
  667          
  668          
  669          
  670          void SystemClock_Config(void)
  671          {
  672   1        EA = 0;
  673   1      
  674   1        CKCON = 0x00;           // ËÆæÁΩÆÂ§ñÈÉ®Êï∞ÊçÆÊÄªÁ∫ø‰∏∫ÊúÄÂø´
  675   1        WTST = 1;                 // ËÆæÁΩÆÁ®ãÂ∫è‰ª£Á†ÅÁ≠âÂæÖÂèÇÊï∞ÔºåËµãÂÄº‰∏∫0ÂèØÂ∞ÜCPUÊâßË°åÁ®ãÂ∫èÁöÑÈÄüÂ∫¶ËÆæ
             -ÁΩÆ‰∏∫ÊúÄÂø´
  676   1        P_SW2 = 0x80;         // ÂºÄÂêØÁâπÊÆäÂú∞ÂùÄËÆøÈóÆ
  677   1      
  678   1        CLKDIV = 0x04;      //‰∏ªÊó∂ÈíüMCLKËæìÂá∫Âà∞Á≥ªÁªüÊó∂Èíü(SYSCLK)ÂàÜÈ¢ë1
  679   1        
  680   1        IRTRIM = CHIPID12;        //ÂÜÖÈÉ®Êó∂ÈíüÊ∫êÈÄâÊã©24M
  681   1        HIRCSEL1 = 1;
  682   1        HIRCSEL0 = 0;       //27MhzÈ¢ëÊÆµ
  683   1      
  684   1        HIRCCR = 0x80;
  685   1        while (!(HIRCCR & 0x01));
  686   1        
  687   1        // MCLKOCR = 72;          //ÂàÜÈ¢ë72,ËæìÂá∫Êó∂ÈíüÁöÑÂàÜÈ¢ë
  688   1      
  689   1        CLKSEL = 0x40;      //PLL,È´òÈÄüIOÔºåÁ≥ªÁªüÊó∂ÈíüÊ∫êÁöÑÁõ∏ÂÖ≥ËÆæÁΩÆ(ÂÖàÈÄâÊã©ÂÜÖÈÉ®IRC‰Ωú‰∏∫Á≥ªÁªüÊó∂Èíü)
  690   1      
  691   1        USBCLK &= 0x0F;
  692   1        USBCLK |= 0xA0;
  693   1        NOP(5);         //Á≠âÂæÖÊó∂ÈíüÁ®≥ÂÆö
  694   1      
  695   1        //PLL‰∫ßÁîü96MhzÊó∂Èíü
  696   1      
  697   1        CLKDIV = 0X01;      //‰∏ªÊó∂ÈíüMCLKËæìÂá∫Âà∞Á≥ªÁªüÊó∂Èíü(SYSCLK)ÂàÜÈ¢ë1
  698   1      
  699   1        CLKSEL |= 0x08;     //MCLKÈÄâÊã©PLL/2‰∏∫Êó∂ÈíüÊ∫ê->48Mhz
  700   1      
  701   1        HSCLKDIV = 0x01;    //È´òÈÄüPWM,SPI,I2S,TFPUÊó∂Èíü96MHz
  702   1      
  703   1        USBCKS = 1;       
  704   1        USBCKS2 = 0;      //USBÊó∂ÈíüÈÄâÊã©48Mhz
  705   1      
  706   1        EA = 1;
C251 COMPILER V5.60.0,  main                                                               21/10/24  11:38:10  PAGE 12  

  707   1      }
  708          
  709          
  710          static void PWMB_Timer_Init(void)
  711          {
  712   1      //Áî±‰∫éÊú™ÂºÄÂêØÈ´òÈÄüPWMÊâÄ‰ª•PWMBÁöÑÊó∂ÈíüÊ∫ê‰∏∫48Mhz
  713   1      
  714   1        PWMB_ENO = 0x00;    //Á¶ÅÊ≠¢PWMBÁöÑPWMËæìÂá∫
  715   1        PWMB_IOAUX = 0x00;    //Á¶ÅÊ≠¢PWMB
  716   1      
  717   1        PWMB_ARRH = 0xFF;
  718   1        PWMB_ARRL = 0xFF;   //ËÆæÁΩÆPWMBÂë®Êúü‰∏∫65535
  719   1        PWMB_CNTRH = 0x00;
  720   1        PWMB_CNTRL = 0x00;    //Ê∏ÖÈõ∂ËÆ°Êï∞Âô®
  721   1        PWMB_PSCRH = 0x00;    
  722   1        PWMB_PSCRL = 47;    //PWMBÊó∂ÈíüÊ∫êÂàÜÈ¢ëÂà∞1Mhz
  723   1        PWMB_IER = 0x00;    //Á¶ÅÊ≠¢PWMB‰∏≠Êñ≠
  724   1        PWMB_CR1 = 0x01;    //‰ΩøËÉΩËÆ°Êï∞Âô®
  725   1      }
  726          
  727          
  728          
  729          static void GPIO_INPUT_INIT(void)
  730          {
  731   1      #ifdef USE_PB4
               #endif
  733   1      #ifdef USE_PA2
               #endif
  735   1      
  736   1        P0M0 = 0x00; P0M1 = 0xff; 
  737   1      
  738   1          P0IE |= 0x02; 
  739   1        P0PU |= 0x02; 
  740   1        //È´òÈòª‰∏äÊãâËæìÂÖ•
  741   1      }
  742          
  743          
  744          #pragma FUNCTIONS (static)
  745          char putchar(char c)
  746          {
  747   1        // serialwriteChar(c);
  748   1        SBUF = c;
  749   1        while (!TI);
  750   1        TI = 0;
  751   1        return c;
  752   1      }
  753          
  754          
  755          
  756          
  757          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2436     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =      1024     ------
  xdata-const size     =    ------     ------
  edata size           =       568     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
C251 COMPILER V5.60.0,  main                                                               21/10/24  11:38:10  PAGE 13  

  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        78     ------
End of Module Information.


C251 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)

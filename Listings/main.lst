C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Compiler\Keil_v5\C251\BIN\C251.EXE bootloader\main.c XSMALL FUNCTIONS(REENTRANT) FLOAT64 WARNING
                    -LEVEL(3) OPTIMIZE(3,SPEED) BROWSE INCDIR(.\Inc;.\Mcu\8051U\Inc) DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Object
                    -s\main.obj) 

stmt  level    source

    1          /*
    2            bootloader for AM32 ESC firmware
    3          
    4            based on https://github.com/AlkaMotors/AT32F421_AM32_Bootloader
    5           */
    6          #include "main.h"
    7          #include <stdio.h>
    8          
    9          #include "version.h"
   10          
   11          /* Includes ------------------------------------------------------------------*/
   12          #include "nstdbool.h"
   13          #include <stdio.h>
   14          #include <stdlib.h>
   15          
   16          //#pragma GCC optimize("O0")
   17          
   18          #include "eeprom.h"
   19          
   20          
   21          #define USE_P00
   22          
   23          //#define USE_ADC_INPUT      // will go right to application and ignore eeprom
   24          //#define UPDATE_EEPROM_ENABLE
   25          
   26          // use this to check the clock config for the MCU (with a logic
   27          // analyser on the input pin)
   28          //#define BOOTLOADER_TEST_CLOCK
   29          
   30          // use this to check the string output code. When enabled
   31          // the string HELLO_WORLD is output every 10ms
   32          // #define BOOTLOADER_TEST_STRING
   33          
   34          // when there is no app fw yet, disable jump()
   35          //#define DISABLE_JUMP
   36          
   37          // optionally enable stats on serial bit-banging
   38          //#define SERIAL_STATS
   39          
   40          /*
   41            enable checking for software reset for jump.
   42            generally on a software reset we do want to stay in the bootloader
   43            if the signal pin is floating, but disabling this can be useful for
   44            CAN testing
   45          */
   46          #define CHECK_SOFTWARE_RESET 1
   47          
   48          /*
   49            enable checking for eeprom configured before jump
   50            disabling this can be useful for CAN development
   51          */
   52          #define CHECK_EEPROM_BEFORE_JUMP 1
   53          
   54          /*
   55            should we update the bootloader version in eeprom?
   56           */
   57          #define UPDATE_EEPROM_ENABLE 1
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 2   

   58          
   59          #include <string.h>
   60          
   61          #ifndef MCU_FLASH_START
   62          #define MCU_FLASH_START 0xFF0000
   63          #endif
   64          
   65          #ifndef FIRMWARE_RELATIVE_START
   66          #define FIRMWARE_RELATIVE_START 0x1000
   67          #endif
   68          
   69          #ifdef USE_P00
   70          #define input_pin        P00
   71          #define input_port       P0
   72          #define PIN_NUMBER       0
   73          #define PORT_LETTER      0
   74          
   75          #define PULL_NO_RESIGTER  P0PU &= ~0x01; P0PD &= ~0x01;P0M0 = 0x00; P0M1 = 0x01
   76          #define PULL_UP_RESIGTER  P0PU |= 0x01; P0PD &= ~0x01;P0M0 = 0x00; P0M1 = 0x01
   77          #define PULL_DOWN_RESIGTER  P0PU &= ~0x01; P0PD |= 0x01;P0M0 = 0x00; P0M1 = 0x01
   78          #define PUSHPULL_RESIGTER   P0PU &= ~0x01; P0PD &= ~0x01;P0M0 |= 0x01; P0M1 &= ~0x01
   79          #define GPIO_INIT_RESIGTER  P0M0 = 0x00; P0M1 = 0x01; P0IE |= 0x01; P0NCS = 0x00; P0PU |= 0x01
   80          
   81          #elif defined(USE_P02)
               #define input_pin        P02
               #define input_port       P0
               #define PIN_NUMBER       2
               #define PORT_LETTER      0
               
               #define PULL_NO_RESIGTER  P0PU &= ~0x04; P0PD &= ~0x04;P0M0 = 0x00; P0M1 = 0x04
               #define PULL_UP_RESIGTER  P0PU |= 0x04; P0PD &= ~0x04;P0M0 = 0x00; P0M1 = 0x04
               #define PULL_DOWN_RESIGTER  P0PU &= ~0x04; P0PD |= 0x04;P0M0 = 0x00; P0M1 = 0x04
               #define PUSHPULL_RESIGTER   P0PU &= ~0x04; P0PD &= ~0x04;P0M0 |= 0x04; P0M1 &= ~0x04
               #define GPIO_INIT_RESIGTER  P0M0 = 0x00; P0M1 = 0x04; P0IE |= 0x04; P0NCS = 0x00; P0PU |= 0x04
               
               #elif defined(USE_P04)
               #define input_pin         P04
               #define input_port        P0
               #define PIN_NUMBER        4
               #define PORT_LETTER       0
               
               #define PULL_NO_RESIGTER  P0PU &= ~0x10; P0PD &= ~0x10;P0M0 = 0x00; P0M1 = 0x10
               #define PULL_UP_RESIGTER  P0PU |= 0x10; P0PD &= ~0x10;P0M0 = 0x00; P0M1 = 0x10
               #define PULL_DOWN_RESIGTER  P0PU &= ~0x10; P0PD |= 0x10;P0M0 = 0x00; P0M1 = 0x10
               #define PUSHPULL_RESIGTER   P0PU &= ~0x10; P0PD &= ~0x10;P0M0 |= 0x10; P0M1 &= ~0x10
               #define GPIO_INIT_RESIGTER  P0M0 = 0x00; P0M1 = 0x10; P0IE |= 0x10; P0NCS = 0x00; P0PU |= 0x10
               
               #elif defined(USE_P06)
               #define input_pin         P06
               #define input_port        P0
               #define PIN_NUMBER        6
               #define PORT_LETTER       0
               
               #define PULL_NO_RESIGTER  P0PU &= ~0x40; P0PD &= ~0x40;P0M0 = 0x00; P0M1 = 0x40
               #define PULL_UP_RESIGTER  P0PU |= 0x40; P0PD &= ~0x40;P0M0 = 0x00; P0M1 = 0x40
               #define PULL_DOWN_RESIGTER  P0PU &= ~0x40; P0PD |= 0x40;P0M0 = 0x00; P0M1 = 0x40
               #define PUSHPULL_RESIGTER   P0PU &= ~0x40; P0PD &= ~0x40;P0M0 |= 0x40; P0M1 &= ~0x40
               #define GPIO_INIT_RESIGTER  P0M0 = 0x00; P0M1 = 0x40; P0IE |= 0x40; P0NCS = 0x00; P0PU |= 0x40
               
               #elif defined(USE_P10)
               #define input_pin         P10
               #define input_port        P1
               #define PIN_NUMBER        0
               #define PORT_LETTER       0
               
               #define PULL_NO_RESIGTER  P1PU &= ~0x01; P1PD &= ~0x01;P1M0 = 0x00; P1M1 = 0x01
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 3   

               #define PULL_UP_RESIGTER  P1PU |= 0x01; P1PD &= ~0x01;P1M0 = 0x00; P1M1 = 0x01
               #define PULL_DOWN_RESIGTER  P1PU &= ~0x01; P1PD |= 0x01;P1M0 = 0x00; P1M1 = 0x01
               #define PUSHPULL_RESIGTER   P1PU &= ~0x01; P1PD &= ~0x01;P1M0 |= 0x01; P1M1 &= ~0x01
               #define GPIO_INIT_RESIGTER  P1M0 = 0x00; P1M1 = 0x01; P1IE |= 0x01; P1NCS = 0x00; P1PU |= 0x01
               
               #elif defined(USE_P12)
               #define input_pin         P12
               #define input_port        P1
               #define PIN_NUMBER        2
               #define PORT_LETTER       0
               
               #define PULL_NO_RESIGTER  P1PU &= ~0x04; P1PD &= ~0x04;P1M0 = 0x00; P1M1 = 0x04
               #define PULL_UP_RESIGTER  P1PU |= 0x04; P1PD &= ~0x04;P1M0 = 0x00; P1M1 = 0x04
               #define PULL_DOWN_RESIGTER  P1PU &= ~0x04; P1PD |= 0x04;P1M0 = 0x00; P1M1 = 0x04
               #define PUSHPULL_RESIGTER   P1PU &= ~0x04; P1PD &= ~0x04;P1M0 |= 0x04; P1M1 &= ~0x04
               #define GPIO_INIT_RESIGTER  P1M0 = 0x00; P1M1 = 0x04; P1IE |= 0x04; P1NCS = 0x00; P1PU |= 0x04
               
               #elif defined(USE_P14)
               #define input_pin         P14
               #define input_port        P1
               #define PIN_NUMBER        4
               #define PORT_LETTER       0
               
               #define PULL_NO_RESIGTER  P1PU &= ~0x10; P1PD &= ~0x10;P1M0 = 0x00; P1M1 = 0x10
               #define PULL_UP_RESIGTER  P1PU |= 0x10; P1PD &= ~0x10;P1M0 = 0x00; P1M1 = 0x10
               #define PULL_DOWN_RESIGTER  P1PU &= ~0x10; P1PD |= 0x10;P1M0 = 0x00; P1M1 = 0x10
               #define PUSHPULL_RESIGTER   P1PU &= ~0x10; P1PD &= ~0x10;P1M0 |= 0x10; P1M1 &= ~0x10
               #define GPIO_INIT_RESIGTER  P1M0 = 0x00; P1M1 = 0x10; P1IE |= 0x10; P1NCS = 0x00; P1PU |= 0x10
               
               #elif defined(USE_P16)
               #define input_pin         P16
               #define input_port        P1
               #define PIN_NUMBER        6
               #define PORT_LETTER       0
               
               #define PULL_NO_RESIGTER  P1PU &= ~0x40; P1PD &= ~0x40;P1M0 = 0x00; P1M1 = 0x40
               #define PULL_UP_RESIGTER  P1PU |= 0x40; P1PD &= ~0x40;P1M0 = 0x00; P1M1 = 0x40
               #define PULL_DOWN_RESIGTER  P1PU &= ~0x40; P1PD |= 0x40;P1M0 = 0x00; P1M1 = 0x40
               #define PUSHPULL_RESIGTER   P1PU &= ~0x40; P1PD &= ~0x40;P1M0 |= 0x40; P1M1 &= ~0x40
               #define GPIO_INIT_RESIGTER  P1M0 = 0x00; P1M1 = 0x40; P1IE |= 0x40; P1NCS = 0x00; P1PU |= 0x40
               
               #elif defined(USE_P20)
               #define input_pin         P20
               #define input_port        P2
               #define PIN_NUMBER        0
               #define PORT_LETTER       0
               
               #define PULL_NO_RESIGTER  P2PU &= ~0x01; P2PD &= ~0x01;P2M0 = 0x00; P2M1 = 0x01
               #define PULL_UP_RESIGTER  P2PU |= 0x01; P2PD &= ~0x01;P2M0 = 0x00; P2M1 = 0x01
               #define PULL_DOWN_RESIGTER  P2PU &= ~0x01; P2PD |= 0x01;P2M0 = 0x00; P2M1 = 0x01
               #define PUSHPULL_RESIGTER   P2PU &= ~0x01; P2PD &= ~0x01;P2M0 |= 0x01; P2M1 &= ~0x01
               #define GPIO_INIT_RESIGTER  P2M0 = 0x00; P2M1 = 0x01; P2IE |= 0x01; P2NCS = 0x00; P2PU |= 0x01
               
               #elif defined(USE_P22)
               #define input_pin         P22
               #define input_port        P2
               #define PIN_NUMBER        2
               #define PORT_LETTER       0
               
               #define PULL_NO_RESIGTER  P2PU &= ~0x04; P2PD &= ~0x04;P2M0 = 0x00; P2M1 = 0x04
               #define PULL_UP_RESIGTER  P2PU |= 0x04; P2PD &= ~0x04;P2M0 = 0x00; P2M1 = 0x04
               #define PULL_DOWN_RESIGTER  P2PU &= ~0x04; P2PD |= 0x04;P2M0 = 0x00; P2M1 = 0x04
               #define PUSHPULL_RESIGTER   P2PU &= ~0x04; P2PD &= ~0x04;P2M0 |= 0x04; P2M1 &= ~0x04
               #define GPIO_INIT_RESIGTER  P2M0 = 0x00; P2M1 = 0x04; P2IE |= 0x04; P2NCS = 0x00; P2PU |= 0x04
               
               #elif defined(USE_P24)
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 4   

               #define input_pin         P24
               #define input_port        P2
               #define PIN_NUMBER        4
               #define PORT_LETTER       0
               
               #define PULL_NO_RESIGTER  P2PU &= ~0x10; P2PD &= ~0x10;P2M0 = 0x00; P2M1 = 0x10
               #define PULL_UP_RESIGTER  P2PU |= 0x10; P2PD &= ~0x10;P2M0 = 0x00; P2M1 = 0x10
               #define PULL_DOWN_RESIGTER  P2PU &= ~0x10; P2PD |= 0x10;P2M0 = 0x00; P2M1 = 0x10
               #define PUSHPULL_RESIGTER   P2PU &= ~0x10; P2PD &= ~0x10;P2M0 |= 0x10; P2M1 &= ~0x10
               #define GPIO_INIT_RESIGTER  P2M0 = 0x00; P2M1 = 0x10; P2IE |= 0x10; P2NCS = 0x00; P2PU |= 0x10
               
               #elif defined(USE_P26)
               #define input_pin         P26
               #define input_port        P2
               #define PIN_NUMBER        6
               #define PORT_LETTER       0
               
               #define PULL_NO_RESIGTER  P2PU &= ~0x40; P2PD &= ~0x40;P2M0 = 0x00; P2M1 = 0x40
               #define PULL_UP_RESIGTER  P2PU |= 0x40; P2PD &= ~0x40;P2M0 = 0x00; P2M1 = 0x40
               #define PULL_DOWN_RESIGTER  P2PU &= ~0x40; P2PD |= 0x40;P2M0 = 0x00; P2M1 = 0x40
               #define PUSHPULL_RESIGTER   P2PU &= ~0x40; P2PD &= ~0x40;P2M0 |= 0x40; P2M1 &= ~0x40
               #define GPIO_INIT_RESIGTER  P2M0 = 0x00; P2M1 = 0x40; P2IE |= 0x40; P2NCS = 0x00; P2PU |= 0x40
               
               #else
               #error "Bootloader comms pin not defined"
               #endif
  216          
  217          static uint16_t invalid_command;
  218          
  219          #include "blutil.h"
  220          
  221          #ifndef BOARD_FLASH_SIZE
               #error "must define BOARD_FLASH_SIZE"
               #endif
  224          
  225          #define PIN_CODE (PORT_LETTER << 4 | PIN_NUMBER)
  226          
  227          /*
  228            currently only support 32, 64 or 128 k flash
  229           */
  230          #if BOARD_FLASH_SIZE == 32
               #define EEPROM_START_ADD (uint32_t)(MCU_FLASH_START+0x7c00)
               #define FLASH_SIZE_CODE 0x1f
               #define ADDRESS_SHIFT 0
               
               #elif BOARD_FLASH_SIZE == 64
  236          #define EEPROM_START_ADD (uint32_t)(MCU_FLASH_START+0xf800)
  237          #define FLASH_SIZE_CODE 0x35
  238          #define ADDRESS_SHIFT 0
  239          
  240          #elif BOARD_FLASH_SIZE == 128
               #define EEPROM_START_ADD (uint32_t)(MCU_FLASH_START+0x1f800)
               #define FLASH_SIZE_CODE 0x2B
               #define ADDRESS_SHIFT 2 // addresses from the bl client are shifted 2 bits before being used
               #else
               #error "unsupported BOARD_FLASH_SIZE"
               #endif
  247          
  248          /*
  249            the devinfo structure tells the configuration client our pin code,
  250            flash size and device type. It can also be used by the main firmware
  251            to confirm we have the right eeprom address and pin code. We have 2
  252            32bit magic values so the main firmware can confirm the bootloader
  253            supports this feature
  254           */
  255          #define DEVINFO_MAGIC1 0x5925e3da
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 5   

  256          #define DEVINFO_MAGIC2 0x4eb863d9
  257          
  258          static const struct {
  259              uint32_t magic1;
  260              uint32_t magic2;
  261              const uint8_t deviceInfo[9];
  262          } devinfo _at_ (MCU_FLASH_START + FIRMWARE_RELATIVE_START - 32) = {
  263                  {DEVINFO_MAGIC1},
  264                  {DEVINFO_MAGIC2},
  265                  {'4','7','1',PIN_CODE,FLASH_SIZE_CODE,0x06,0x06,0x01,0x30}
  266          };
  267          
  268          typedef void (*pFunction)(void);
  269          
  270          #define APPLICATION_ADDRESS     (uint32_t)(MCU_FLASH_START + FIRMWARE_RELATIVE_START)
  271          
  272          #define CMD_RUN             0x00
  273          #define CMD_PROG_FLASH      0x01
  274          #define CMD_ERASE_FLASH     0x02
  275          #define CMD_READ_FLASH_SIL  0x03
  276          #define CMD_VERIFY_FLASH    0x03
  277          #define CMD_VERIFY_FLASH_ARM 0x04
  278          #define CMD_READ_EEPROM     0x04
  279          #define CMD_PROG_EEPROM     0x05
  280          #define CMD_READ_SRAM       0x06
  281          #define CMD_READ_FLASH_ATM  0x07
  282          #define CMD_KEEP_ALIVE      0xFD
  283          #define CMD_SET_ADDRESS     0xFF
  284          #define CMD_SET_BUFFER      0xFE
  285          
  286          static uint16_t low_pin_count;
  287          static char receiveByte;
  288          static int count;
  289          static char messagereceived;
  290          static uint16_t address_expected_increment;
  291          static int cmd;
  292          static char eeprom_req;
  293          static int received;
  294          
  295          static uint8_t xdata rxBuffer[258];
  296          static uint8_t xdata payLoadBuffer[256];
  297          static char rxbyte;
  298          static uint32_t address;
  299          
  300          typedef union {
  301              uint8_t bytes[2];
  302              uint16_t word;
  303          } uint8_16_u;
  304          
  305          static uint16_t len;
  306          static uint8_t calculated_crc_low_byte;
  307          static uint8_t calculated_crc_high_byte;
  308          static uint16_t payload_buffer_size;
  309          static char incoming_payload_no_command;
  310          
  311          /* USER CODE BEGIN PFP */
  312          static void sendString(const uint8_t dat[], int len);
  313          static void receiveBuffer();
  314          static void serialwriteChar(uint8_t dat);
  315          
  316          #define BAUDRATE      19200
  317          #define BITTIME          52 // 1000000/BAUDRATE
  318          #define HALFBITTIME      26 // 500000/BAUDRATE
  319          
  320          static void delayMicroseconds(uint32_t micros)
  321          {
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 6   

  322   1          bl_timer_reset();
  323   1          while (bl_timer_us() < micros) {
  324   2          }
  325   1      }
  326          /*
  327            jump to the application firmware
  328           */
  329          static void jump()
  330          {
  331   1      #ifndef DISABLE_JUMP
  332   1      #if CHECK_EEPROM_BEFORE_JUMP
  333   1        uint8_t value = *(unsigned char far*)EEPROM_START_ADD;
  334   1      #endif
  335   1      #ifndef DISABLE_APP_HEADER_CHECKS
  336   1          const uint32_t *app = (unsigned char far*)(MCU_FLASH_START + FIRMWARE_RELATIVE_START);
  337   1          const uint32_t ram_start = 0x000000;
  338   1          const uint32_t ram_limit_kb = 64;
  339   1          const uint32_t ram_end = ram_start+ram_limit_kb*1024;
  340   1        const uint32_t flash_limit_kb = 256;
  341   1      #endif
  342   1      #if CHECK_EEPROM_BEFORE_JUMP
  343   1        if (value != 0x01) {      // check first byte of eeprom to see if its programmed, if not do not jump
  344   2          invalid_command = 0;
  345   2          return;
  346   2          }
  347   1      #endif
  348   1      #ifndef DISABLE_APP_HEADER_CHECKS
  349   1          /*
  350   1            first word of the app is the stack pointer - make sure that it is in range
  351   1           */
  352   1          if (app[0] < ram_start || app[0] > ram_end) {
  353   2        invalid_command = 0;
  354   2        return;
  355   2          }
  356   1          /*
  357   1            2nd word is the entry point of the main app. Ensure that is in range
  358   1           */
  359   1        if (app[1] < APPLICATION_ADDRESS || app[1] > APPLICATION_ADDRESS+flash_limit_kb*1024) {
  360   2        // outside a 256k range, really unlikely to be a valid
  361   2        // application, don't jump
  362   2        invalid_command = 0;
  363   2        return;
  364   2          }
  365   1      #endif
  366   1        jump_to_application();
  367   1      #endif
  368   1      }
  369          
  370          
  371          static void makeCrc(uint8_t* pBuff, uint16_t length)
  372          {
  373   1        uint16_t i;
  374   1        uint8_t xb;
  375   1        static uint8_16_u CRC_16;
  376   1        
  377   1        CRC_16.word=0;
  378   1        for(i = 0; i < length; i++) {
  379   2          uint8_t j;
  380   2          xb = pBuff[i];
  381   2          for ( j = 0; j < 8; j++)
  382   2          {
  383   3            if (((xb & 0x01) ^ (CRC_16.word & 0x0001)) !=0 ) {
  384   4              CRC_16.word = CRC_16.word >> 1;
  385   4              CRC_16.word = CRC_16.word ^ 0xA001;
  386   4            } else {
  387   4              CRC_16.word = CRC_16.word >> 1;
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 7   

  388   4            }
  389   3            xb = xb >> 1;
  390   3          }
  391   2        }
  392   1        calculated_crc_low_byte = CRC_16.bytes[1];        //C251是大端编译模式
  393   1        calculated_crc_high_byte = CRC_16.bytes[0];
  394   1      }
  395          
  396          static char checkCrc(uint8_t* pBuff, uint16_t length)
  397          {
  398   1        uint8_t received_crc_low_byte2 = pBuff[length];          // one higher than len in buffer
  399   1        uint8_t received_crc_high_byte2 = pBuff[length+1];
  400   1        makeCrc(pBuff,length);
  401   1        if((calculated_crc_low_byte==received_crc_low_byte2)   && (calculated_crc_high_byte==received_crc_high_b
             -yte2)){
  402   2          return 1;
  403   2        }else{
  404   2          return 0;
  405   2        }
  406   1      }
  407          
  408          static void setReceive()
  409          {
  410   1          gpio_mode_set_input(input_pin, GPIO_PULL_UP);
  411   1          received = 0;
  412   1      }
  413          
  414          static void setTransmit()
  415          {
  416   1          // set high before we set as output to guarantee idle high
  417   1          gpio_set(input_pin);
  418   1          gpio_mode_set_output(input_pin, GPIO_OUTPUT_PUSH_PULL);
  419   1      
  420   1          // delay a bit to let the sender get setup for receiving
  421   1          delayMicroseconds(BITTIME);
  422   1      }
  423          
  424          static void send_ACK()
  425          {
  426   1          setTransmit();
  427   1          serialwriteChar(0x30);             // good ack!
  428   1          setReceive();
  429   1      }
  430          
  431          static void send_BAD_ACK()
  432          {
  433   1          setTransmit();
  434   1          serialwriteChar(0xC1);                // bad command message.
  435   1          setReceive();
  436   1      }
  437          
  438          static void send_BAD_CRC_ACK()
  439          {
  440   1          setTransmit();
  441   1          serialwriteChar(0xC2);                // bad command message.
  442   1          setReceive();
  443   1      }
  444          
  445          static void sendDeviceInfo()
  446          {
  447   1          setTransmit();
  448   1          sendString(devinfo.deviceInfo,sizeof(devinfo.deviceInfo));
  449   1          setReceive();
  450   1      }
  451          
  452          static bool checkAddressWritable(uint32_t address)
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 8   

  453          {
  454   1          return address >= APPLICATION_ADDRESS;
  455   1      }
  456          
  457          
  458          static void decodeInput()
  459          {
  460   1          if (incoming_payload_no_command) {
  461   2        uint16_t i;
  462   2        len = payload_buffer_size;
  463   2        if (checkCrc(rxBuffer,len)) {
  464   3            memset(payLoadBuffer, 0, sizeof(payLoadBuffer));             // reset buffer
  465   3      
  466   3            for(i = 0; i < len; i++){
  467   4          payLoadBuffer[i]= rxBuffer[i];
  468   4            }
  469   3            send_ACK();
  470   3            incoming_payload_no_command = 0;
  471   3            return;
  472   3        }else{
  473   3            send_BAD_CRC_ACK();
  474   3            return;
  475   3        }
  476   2          }
  477   1      
  478   1          cmd = rxBuffer[0];
  479   1      
  480   1          if (rxBuffer[16] == 0x7d) {
  481   2        if(rxBuffer[8] == 13 && rxBuffer[9] == 66) {
  482   3            sendDeviceInfo();
  483   3            rxBuffer[20]= 0;
  484   3      
  485   3        }
  486   2        return;
  487   2          }
  488   1      
  489   1          if (rxBuffer[20] == 0x7d) {
  490   2        if(rxBuffer[12] == 13 && rxBuffer[13] == 66) {
  491   3            sendDeviceInfo();
  492   3            rxBuffer[20]= 0;
  493   3            return;
  494   3        }
  495   2      
  496   2          }
  497   1          if (rxBuffer[40] == 0x7d) {
  498   2        if (rxBuffer[32] == 13 && rxBuffer[33] == 66) {
  499   3            sendDeviceInfo();
  500   3            rxBuffer[20]= 0;
  501   3            return;
  502   3        }
  503   2          }
  504   1      
  505   1          if (cmd == CMD_RUN) {
  506   2        // starts the main app
  507   2        if((rxBuffer[1] == 0) && (rxBuffer[2] == 0) && (rxBuffer[3] == 0)) {
  508   3            invalid_command = 101;
  509   3        }
  510   2          }
  511   1      
  512   1          if (cmd == CMD_PROG_FLASH) {
  513   2        len = 2;
  514   2        if (!checkCrc((uint8_t*)rxBuffer, len)) {
  515   3            send_BAD_CRC_ACK();
  516   3      
  517   3            return;
  518   3        }
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 9   

  519   2      
  520   2        if (!checkAddressWritable(address)) {
  521   3            send_BAD_ACK();
  522   3      
  523   3            return;
  524   3        }
  525   2      
  526   2        if (!save_flash_nolib((uint8_t*)payLoadBuffer, payload_buffer_size,address)) {
  527   3            send_BAD_ACK();
  528   3        } else {
  529   3            send_ACK();
  530   3        }
  531   2      
  532   2        return;
  533   2          }
  534   1      
  535   1          if (cmd == CMD_SET_ADDRESS) {
  536   2        // command set addressinput format is: CMD, 00 , High byte
  537   2        // address, Low byte address, crclb ,crchb
  538   2        len = 4;  // package without 2 byte crc
  539   2        if (!checkCrc((uint8_t*)rxBuffer, len)) {
  540   3            send_BAD_CRC_ACK();
  541   3      
  542   3            return;
  543   3        }
  544   2      
  545   2      
  546   2        // will send Ack 0x30 and read input after transfer out callback
  547   2        invalid_command = 0;
  548   2        address = MCU_FLASH_START + ((rxBuffer[2] << 8 | rxBuffer[3]) << ADDRESS_SHIFT);
  549   2        send_ACK();
  550   2      
  551   2        return;
  552   2          }
  553   1      
  554   1          if (cmd == CMD_SET_BUFFER) {
  555   2        // for writing buffer rx buffer 0 = command byte.  command set
  556   2        // address, input , format is CMD, 00 , 00 or 01 (if buffer is 256),
  557   2        // buffer_size,
  558   2        len = 4;  // package without 2 byte crc
  559   2        if (!checkCrc((uint8_t*)rxBuffer, len)) {
  560   3            send_BAD_CRC_ACK();
  561   3      
  562   3            return;
  563   3        }
  564   2      
  565   2              // no ack with command set buffer;
  566   2              if(rxBuffer[2] == 0x01){
  567   3            payload_buffer_size = 256;                          // if nothing in this buffer
  568   3              }else{
  569   3            payload_buffer_size = rxBuffer[3];
  570   3              }
  571   2        incoming_payload_no_command = 1;
  572   2        address_expected_increment = 256;
  573   2              setReceive();
  574   2      
  575   2              return;
  576   2          }
  577   1      
  578   1          if (cmd == CMD_KEEP_ALIVE) {
  579   2        len = 2;
  580   2        if (!checkCrc((uint8_t*)rxBuffer, len)) {
  581   3            send_BAD_CRC_ACK();
  582   3      
  583   3            return;
  584   3        }
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 10  

  585   2      
  586   2        setTransmit();
  587   2        serialwriteChar(0xC1);                // bad command message.
  588   2        setReceive();
  589   2      
  590   2        return;
  591   2          }
  592   1      
  593   1          if (cmd == CMD_ERASE_FLASH) {
  594   2        len = 2;
  595   2        if (!checkCrc((uint8_t*)rxBuffer, len)) {
  596   3            send_BAD_CRC_ACK();
  597   3      
  598   3            return;
  599   3        }
  600   2      
  601   2        if (!checkAddressWritable(address)) {
  602   3            send_BAD_ACK();
  603   3      
  604   3            return;
  605   3        }
  606   2      
  607   2        send_ACK();
  608   2        return;
  609   2          }
  610   1      
  611   1          if (cmd == CMD_READ_EEPROM) {
  612   2        eeprom_req = 1;
  613   2          }
  614   1      
  615   1          if (cmd == CMD_READ_FLASH_SIL) {
  616   2        // for sending contents of flash memory at the memory location set in
  617   2        // bootloader.c need to still set memory with data from set mem
  618   2        // command
  619   2        uint16_t out_buffer_size;
  620   2        uint8_t xdata* read_data;
  621   2      
  622   2        len = 2;
  623   2        if (!checkCrc((uint8_t*)rxBuffer, len)) {
  624   3            send_BAD_CRC_ACK();
  625   3      
  626   3            return;
  627   3        }
  628   2      
  629   2        count++;
  630   2        out_buffer_size = rxBuffer[1];//
  631   2        if(out_buffer_size == 0){
  632   3            out_buffer_size = 256;
  633   3        }
  634   2        address_expected_increment = 128;
  635   2      
  636   2        setTransmit();
  637   2        read_data = (uint8_t xdata*)malloc(out_buffer_size + 3);        // make buffer 3 larger to fit CRC and A
             -CK
  638   2        memset(read_data, 0, sizeof(read_data));
  639   2              //    read_flash((uint8_t*)read_data , address);                 // make sure read_flash reads tw
             -o less than buffer.
  640   2        read_flash_bin((uint8_t xdata*)read_data , address, out_buffer_size);
  641   2      
  642   2              makeCrc(read_data,out_buffer_size);
  643   2              read_data[out_buffer_size] = calculated_crc_low_byte;
  644   2              read_data[out_buffer_size + 1] = calculated_crc_high_byte;
  645   2              read_data[out_buffer_size + 2] = 0x30;
  646   2              sendString(read_data, out_buffer_size+3);
  647   2      
  648   2        setReceive();
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 11  

  649   2      
  650   2        return;
  651   2          }
  652   1      
  653   1          setTransmit();
  654   1      
  655   1          serialwriteChar(0xC1);                // bad command message.
  656   1          invalid_command++;
  657   1          setReceive();
  658   1      }
  659          
  660          #ifdef SERIAL_STATS
               // stats for debugging serial protocol
               struct {
                   uint32_t no_idle;
                   uint32_t no_start;
                   uint32_t bad_start;
                   uint32_t bad_stop;
                   uint32_t good;
               } stats;
               #endif
  670          
  671          
  672          /*
  673            read one byte from the input pin, 19200, not inverted, one stop bit
  674          
  675            return false if we can't get a byte, or the byte has bad framing
  676           */
  677          static bool serialreadChar()
  678          {
  679   1        int bits_to_read;
  680   1          rxbyte=0;
  681   1          bl_timer_reset();
  682   1      
  683   1          // UART is idle high, wait for it to be in the idle state
  684   1          while (~gpio_read(input_pin)) { // wait for rx to go high
  685   2        if (bl_timer_us() > 20000) {
  686   3            /*
  687   3              if we don't get a command for 20ms then assume we should
  688   3              be trying to boot the main firmware, invalid_command 101
  689   3              triggers the jump immediately
  690   3             */
  691   3            invalid_command = 101;
  692   3      #ifdef SERIAL_STATS
                     stats.no_idle++;
               #endif
  695   3            return false;
  696   3        }
  697   2          }
  698   1      
  699   1          // now we need to wait for the start bit leading edge, which is low
  700   1          bl_timer_reset();
  701   1          while (gpio_read(input_pin)) {
  702   2        if (bl_timer_us() > 5*BITTIME && messagereceived) {
  703   3            // we've been waiting too long, don't allow for long gaps
  704   3            // between bytes
  705   3      #ifdef SERIAL_STATS
                     stats.no_start++;
               #endif
  708   3            return false;
  709   3        }
  710   2          }
  711   1      
  712   1          // wait to get the center of bit time. We want to sample at the
  713   1          // middle of each bit
  714   1          delayMicroseconds(HALFBITTIME);
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 12  

  715   1          if (gpio_read(input_pin)) {
  716   2        // bad framing, we should be half-way through the start bit
  717   2        // which should still be low
  718   2      #ifdef SERIAL_STATS
                 stats.bad_start++;
               #endif
  721   2        return false;
  722   2          }
  723   1      
  724   1          /*
  725   1            now sample the 8 data bits
  726   1           */
  727   1          bits_to_read = 0;
  728   1          while (bits_to_read < 8) {
  729   2        delayMicroseconds(BITTIME);
  730   2        rxbyte = rxbyte | (uint8_t)gpio_read(input_pin) << bits_to_read;
  731   2        bits_to_read++;
  732   2          }
  733   1      
  734   1          // wait till middle of stop bit, so we can check that too
  735   1          delayMicroseconds(BITTIME);
  736   1          if (~gpio_read(input_pin)) {
  737   2        // bad framing, stop bit should be high
  738   2      #ifdef SERIAL_STATS
                 stats.bad_stop++;
               #endif
  741   2        return false;
  742   2          }
  743   1      
  744   1          // we got a good byte
  745   1          messagereceived = 1;
  746   1          receiveByte = rxbyte;
  747   1      #ifdef SERIAL_STATS
                   stats.good++;
               #endif
  750   1          return true;
  751   1      }
  752          
  753          static void serialwriteChar(uint8_t dat)
  754          {
  755   1        uint8_t bits_written;
  756   1          // start bit is low
  757   1          gpio_clear(input_pin);
  758   1          delayMicroseconds(BITTIME);
  759   1      
  760   1          // send data bits
  761   1          bits_written = 0;
  762   1          while (bits_written < 8) {
  763   2        if (dat & 0x01) {
  764   3            gpio_set(input_pin);
  765   3        } else {
  766   3            // GPIO_BC(input_port) = input_pin;
  767   3            gpio_clear(input_pin);
  768   3        }
  769   2        bits_written++;
  770   2        dat = dat >> 1;
  771   2        delayMicroseconds(BITTIME);
  772   2          }
  773   1      
  774   1          // send stop bit
  775   1          gpio_set(input_pin);
  776   1      
  777   1          /*
  778   1            note that we skip the delay by BITTIME for the full stop bit and
  779   1            do it in sendString() instead to ensure when sending an ACK
  780   1            immediately followed by a setReceive() on a slow MCU that we
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 13  

  781   1            start on the receive as soon as possible.
  782   1          */
  783   1      }
  784          
  785          static void sendString(const uint8_t dat[], int len)
  786          {
  787   1        int i;
  788   1          for(i = 0; i < len; i++){
  789   2              serialwriteChar(dat[i]);
  790   2              // for multi-byte writes we add the stop bit delay
  791   2              delayMicroseconds(BITTIME);
  792   2          }
  793   1      }
  794          
  795          static void receiveBuffer()
  796          {
  797   1        uint32_t i;
  798   1          count = 0;
  799   1          messagereceived = 0;
  800   1          memset(rxBuffer, 0, sizeof(rxBuffer));
  801   1      
  802   1          setReceive();
  803   1      
  804   1          for(i = 0; i < sizeof(rxBuffer); i++){
  805   2        if (!serialreadChar()) {
  806   3            break;
  807   3        }
  808   2      
  809   2        if(incoming_payload_no_command) {
  810   3            if(count == payload_buffer_size+2){
*** WARNING C173 IN LINE 810 OF bootloader\main.c: '==': signed/unsigned type mismatch
  811   4          break;
  812   4            }
  813   3            rxBuffer[i] = rxbyte;
  814   3            count++;
  815   3        } else {
  816   3            if(bl_timer_us() > 250){
  817   4        
  818   4          count = 0;
  819   4      
  820   4          break;
  821   4            } else {
  822   4          rxBuffer[i] = rxbyte;
  823   4          if(i == 257){
  824   5              invalid_command+=20;       // needs one hundred to trigger a jump but will be reset on next set add
             -ress commmand
  825   5      
  826   5          }
  827   4            }
  828   3        }
  829   2          }
  830   1          if (messagereceived) {
  831   2        decodeInput();
  832   2          }
  833   1      }
  834          
  835          #ifdef UPDATE_EEPROM_ENABLE
  836          static void update_EEPROM()
  837          {
  838   1          read_flash_bin(rxBuffer , EEPROM_START_ADD , 48);
  839   1          if (BOOTLOADER_VERSION != rxBuffer[2]) {
  840   2        if (rxBuffer[2] == 0xFF || rxBuffer[2] == 0x00){
  841   3            return;
  842   3        }
  843   2        rxBuffer[2] = BOOTLOADER_VERSION;
  844   2        save_flash_nolib(rxBuffer, 48, EEPROM_START_ADD);
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 14  

  845   2          }
  846   1      }
  847          #endif // UPDATE_EEPROM_ENABLE
  848          
  849          static void checkForSignal()
  850          {
  851   1        int i;
  852   1          gpio_mode_set_input(input_pin, GPIO_PULL_DOWN);
  853   1        
  854   1          delayMicroseconds(500);
  855   1      
  856   1          for(i = 0 ; i < 500; i ++){
  857   2        if(~gpio_read(input_pin)){
  858   3            low_pin_count++;
  859   3        }else{
  860   3        }
  861   2      
  862   2        delayMicroseconds(10);
  863   2          }
  864   1          if (low_pin_count > 450) {
  865   2      #if CHECK_SOFTWARE_RESET
  866   2              if (!bl_was_software_reset()) {
  867   3            jump();
  868   3              }
  869   2      #else
                       jump();
               #endif
  872   2          }
  873   1      
  874   1          gpio_mode_set_input(input_pin, GPIO_PULL_UP);
  875   1        
  876   1          delayMicroseconds(500);
  877   1      
  878   1          for (i = 0 ; i < 500; i++) {
  879   2        if( ~(gpio_read(input_pin))){
  880   3            low_pin_count++;
  881   3        }else{
  882   3      
  883   3        }
  884   2        delayMicroseconds(10);
  885   2          }
  886   1          if (low_pin_count == 0) {
  887   2        return;           // all high while pin is pulled low, bootloader signal
  888   2          }
  889   1      
  890   1          low_pin_count = 0;
  891   1      
  892   1          gpio_mode_set_input(input_pin, GPIO_PULL_NONE);
  893   1      
  894   1          delayMicroseconds(500);
  895   1      
  896   1          for (i = 0 ; i < 500; i ++) {
  897   2        if( ~(gpio_read(input_pin))){
  898   3            low_pin_count++;
  899   3        }
  900   2      
  901   2        delayMicroseconds(10);
  902   2          }
  903   1          if (low_pin_count == 0) {
  904   2        return;            // when floated all
  905   2          }
  906   1      
  907   1          if (low_pin_count > 0) {
  908   2        jump();
  909   2          }
  910   1      }
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 15  

  911          
  912          #ifdef BOOTLOADER_TEST_CLOCK
               /*
                 this should provide a 2ms low followed by a 1ms high if the clock is correct
                */
               static void test_clock(void)
               {
                   setTransmit();
                   while (1) {
                 gpio_clear(input_pin);
                 bl_timer_reset();
                 while (bl_timer_us() < 2000) ;
                 gpio_set(input_pin);
                 bl_timer_reset();
                 while (bl_timer_us() < 1000) ;
                   }
               }
               #endif // BOOTLOADER_TEST_CLOCK
  929          
  930          #ifdef BOOTLOADER_TEST_STRING
               /*
                 this should send HELLO_WORLD continuously
                */
               static void test_string(void)
               {
                   setTransmit();
                   while (1) {
                       delayMicroseconds(10000);
                       sendString((uint8_t*)"HELLO_WORLD\n",13);
                   }
               }
               #endif // BOOTLOADER_TEST_STRING
  943          
  944          
  945          
  946          int main(void)
  947          {
  948   1      
  949   1        //Prevent warnings
  950   1        static uint8_t xdata MEMPOOL[1024];   //内存池
  951   1        init_mempool(MEMPOOL, sizeof(MEMPOOL)); //初始化内存池
  952   1        
  953   1          bl_clock_config();
  954   1          bl_timer_init();
  955   1          bl_gpio_init();
  956   1      
  957   1        IAP_TPS = 48;
  958   1      
  959   1      #ifdef BOOTLOADER_TEST_CLOCK
                   test_clock();
               #endif
  962   1      #ifdef BOOTLOADER_TEST_STRING
                   test_string();
               #endif
  965   1      
  966   1          checkForSignal();
  967   1      
  968   1          gpio_mode_set_input(input_pin, GPIO_PULL_NONE);
  969   1          
  970   1      #ifdef USE_ADC_INPUT  // go right to application
                   jump();
               #endif
  973   1      
  974   1      #ifdef UPDATE_EEPROM_ENABLE
  975   1           update_EEPROM();
  976   1      #endif
C251 COMPILER V5.60.0,  main                                                               25/10/24  23:46:53  PAGE 16  

  977   1      
  978   1          while (1) {
  979   2          receiveBuffer();
  980   2          if (invalid_command > 100) {
  981   3              jump();
  982   3          }
  983   2          }
  984   1      }
  985          
  986          
  987          // void Uart1_Init(void)  //921600bps@48MHz
  988          // {
  989          //  SCON = 0x50;    //8位数据,可变波特率
  990          //  AUXR |= 0x01;   //串口1选择定时器2为波特率发生器
  991          //  AUXR |= 0x04;   //定时器时钟1T模式
  992          //  T2L = 0xF3;     //设置定时初始值
  993          //  T2H = 0xFF;     //设置定时初始值
  994          //  AUXR |= 0x10;   //定时器2开始计时
  995          
  996          
  997          //  P3M0 |= 0x03; P3M1 &= ~0x03; 
  998          //  P2M0 |= 0x03; P2M1 &= ~0x03; 
  999          // }
 1000          
 1001          
 1002          
 1003          // #pragma FUNCTIONS (static)
 1004          // char putchar(char c)
 1005          // {
 1006          //  // serialwriteChar(c);
 1007          //  SBUF = c;
 1008          //  while (!TI);
 1009          //  TI = 0;
 1010          //  return c;
 1011          // }
 1012          
 1013          
 1014          
 1015          
 1016          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2523     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =      1538     ------
  xdata-const size     =    ------     ------
  edata size           =        29     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        17     ------
End of Module Information.


C251 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)

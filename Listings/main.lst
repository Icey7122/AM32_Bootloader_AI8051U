C251 COMPILER V5.60.0,  main                                                               14/10/24  10:43:49  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Compiler\Keil_v5\C251\BIN\C251.EXE Bootloader\src\main.c XSMALL FUNCTIONS(REENTRANT) FLOAT64 OPT
                    -IMIZE(3,SPEED) BROWSE INCDIR(.\Bootloader\inc) DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj) 

stmt  level    source

    1          /* Bootloader */
    2          
    3          #define BOOTLOADER_VERSION 10
    4          
    5          #define USE_P10
    6          /* Includes ------------------------------------------------------------------*/
    7          #include "nstdbool.h"
    8          #include "main.h"
    9          
   10          //#define USE_ADC_INPUT      // will go right to application and ignore eeprom
   11          
   12          #include "nstdint.h"
   13          #include <stdlib.h>
   14          #include <string.h>
   15          #include "bootloader.h"
   16          
   17          #define STC32_FLASH_START 0x00000000
   18          #define FIRMWARE_RELATIVE_START 0x0000
   19          #define EEPROM_RELATIVE_START 0x0000
   20          
   21          uint8_t bootloader_version = BOOTLOADER_VERSION;
   22          
   23          typedef void (*pFunction)(void);
   24          
   25          #define APPLICATION_ADDRESS     (uint32_t)(STC32_FLASH_START + FIRMWARE_RELATIVE_START) // 4k
   26          
   27          #define EEPROM_START_ADD         (uint32_t)(STC32_FLASH_START + EEPROM_RELATIVE_START)
   28          #define FLASH_END_ADD           (uint32_t)(STC32_FLASH_START + 0xFFFF)               // 32 k
   29          
   30          
   31          #define CMD_RUN             0x00
   32          #define CMD_PROG_FLASH      0x01
   33          #define CMD_ERASE_FLASH     0x02
   34          #define CMD_READ_FLASH_SIL  0x03
   35          #define CMD_VERIFY_FLASH    0x03
   36          #define CMD_VERIFY_FLASH_ARM 0x04
   37          #define CMD_READ_EEPROM     0x04
   38          #define CMD_PROG_EEPROM     0x05
   39          #define CMD_READ_SRAM       0x06
   40          #define CMD_READ_FLASH_ATM  0x07
   41          #define CMD_KEEP_ALIVE      0xFD
   42          #define CMD_SET_ADDRESS     0xFF
   43          #define CMD_SET_BUFFER      0xFE
   44          
   45          
   46          #ifdef USE_P10
   47          #define input_pin        0
   48          #define input_port       0
   49          #define PIN_NUMBER       2
   50          #define PORT_LETTER      0
   51          #endif
   52          
   53          #ifdef USE_PB4
               // #define input_pin       LL_GPIO_PIN_4
               // #define input_port        GPIOB
               // #define PIN_NUMBER        4
               // #define PORT_LETTER       1
               #endif
C251 COMPILER V5.60.0,  main                                                               14/10/24  10:43:49  PAGE 2   

   59          
   60          
   61          uint16_t low_pin_count = 0;
   62          char receviedByte;
   63          int receivedCount;
   64          int count = 0;
   65          char messagereceived = 0;
   66          uint16_t invalid_command = 0;
   67          uint16_t address_expected_increment;
   68          int cmd = 0;
   69          char eeprom_req = 0;
   70          int received;
   71          uint8_t port_letter;
   72          
   73          
   74          uint8_t pin_code = PORT_LETTER << 4 | PIN_NUMBER;
   75          uint8_t deviceInfo[9] = { 0 };      // stm32 device info
   76          
   77          size_t str_len;
   78          char connected = 0;
   79          uint8_t rxBuffer[258];
   80          uint8_t payLoadBuffer[256];
   81          char rxbyte=0;
   82          uint32_t address;
   83          int tick = 0;
   84          
   85          typedef union {
   86              uint8_t bytes[2];
   87              uint16_t word;
   88          } uint8_16_u;
   89          uint16_t len;
   90          uint8_t received_crc_low_byte;
   91          uint8_t received_crc_high_byte;
   92          uint8_t calculated_crc_low_byte;
   93          uint8_t calculated_crc_high_byte;
   94          uint16_t payload_buffer_size;
   95          char incoming_payload_no_command = 0;
   96          
   97          char bootloaderactive = 1;
   98          
   99          uint32_t JumpAddress;
  100          // pFunction JumpToApplication;
  101          #define JumpToApplication()   IAP_CONTR = 0x20
  102          
  103          
  104          //待改（系统时钟初始化）
  105          void SystemClock_Config(void);
  106          //static void MX_GPIO_Init(void);
  107          static void MX_TIM2_Init(void);
  108          
  109          /* USER CODE BEGIN PFP */
  110          static void MX_GPIO_INPUT_INIT(void);
  111          
  112          void processmessage(void);
  113          void serialwriteChar(char dat);
  114          void sendString(uint8_t dat[], int len);
  115          void recieveBuffer();
  116          
  117          #define BAUDRATE              19200
  118          #define BITTIME          1000000/BAUDRATE
  119          #define HALFBITTIME       500000/BAUDRATE
  120          
  121          //待改（使用定时器做延时函数）
  122          void delayMicroseconds(uint32_t micros){
  123   1        // TIM2->CNT = 0;
  124   1        // while (TIM2->CNT < micros){
C251 COMPILER V5.60.0,  main                                                               14/10/24  10:43:49  PAGE 3   

  125   1        // }
  126   1      }
*** WARNING C47 IN LINE 122 OF Bootloader\src\main.c: 'micros': unreferenced parameter
  127          
  128          void jump(){
  129   1      
  130   1        uint8_t value;
  131   1      
  132   1        EA = 0;
  133   1      
  134   1        IAP_ENABLE();                           //设置等待时间，允许IAP操作，送一次就够
  135   1          IAP_READ();                             
  136   1      
  137   1        IAP_ADDRE = (uint8_t)(EEPROM_START_ADD >> 16); 
  138   1        IAP_ADDRH = (uint8_t)(EEPROM_START_ADD >> 8);  
  139   1        IAP_ADDRL = (uint8_t)EEPROM_START_ADD;         
  140   1        IAP_TRIG = 0x5A;
  141   1        IAP_TRIG = 0xA5;                   
  142   1        _nop_();   
  143   1        _nop_();
  144   1        _nop_();
  145   1        _nop_();
  146   1        while(CMD_FAIL);
  147   1      
  148   1        value = IAP_DATA;            //读出的数据送往
  149   1      
  150   1        IAP_DISABLE();
  151   1      
  152   1      #ifdef USE_ADC_INPUT
               #else
  154   1        if (value != 0x01){      // check first byte of eeprom to see if its programmed, if not do not jump
  155   2          invalid_command = 0;
  156   2          return;
  157   2        }
  158   1      #endif
  159   1         JumpToApplication();
  160   1      }
  161          
  162          
  163          void makeCrc(uint8_t* pBuff, uint16_t length){
  164   1        int i;
  165   1        uint8_t xb;
  166   1        static uint8_16_u CRC_16;
  167   1        
  168   1        CRC_16.word=0;
  169   1        for(i = 0; i < length; i++) {
  170   2          uint8_t j;
  171   2          xb = pBuff[i];
  172   2          for ( j = 0; j < 8; j++)
  173   2          {
  174   3            if (((xb & 0x01) ^ (CRC_16.word & 0x0001)) !=0 ) {
  175   4              CRC_16.word = CRC_16.word >> 1;
  176   4              CRC_16.word = CRC_16.word ^ 0xA001;
  177   4            } else {
  178   4              CRC_16.word = CRC_16.word >> 1;
  179   4            }
  180   3            xb = xb >> 1;
  181   3          }
  182   2        }
  183   1        calculated_crc_low_byte = CRC_16.bytes[0];
  184   1        calculated_crc_high_byte = CRC_16.bytes[1];
  185   1      }
  186          
  187          char checkCrc(uint8_t* pBuff, uint16_t length){
  188   1      
  189   1        char received_crc_low_byte2 = pBuff[length];          // one higher than len in buffer
C251 COMPILER V5.60.0,  main                                                               14/10/24  10:43:49  PAGE 4   

  190   1        char received_crc_high_byte2 = pBuff[length+1];
  191   1        makeCrc(pBuff,length);
  192   1        if((calculated_crc_low_byte==received_crc_low_byte2)   && (calculated_crc_high_byte==received_crc_high_b
             -yte2)){
  193   2          return 1;
  194   2        }else{
  195   2          return 0;
  196   2        }
  197   1      
  198   1      }
  199          
  200          //待改（接收引脚初始化）上拉输入
  201          void setReceive(void){
  202   1      
  203   1        MX_GPIO_INPUT_INIT();
  204   1        received = 0;
  205   1      
  206   1      }
  207          //待改（发送引脚初始化）
  208          void setTransmit(void){
  209   1        // LL_GPIO_SetPinMode(input_port, input_pin, LL_GPIO_MODE_OUTPUT);       // set as reciever // clear bit
             -s and set receive bits..
  210   1      }
  211          
  212          void send_ACK(void){
  213   1          setTransmit();
  214   1          serialwriteChar(0x30);             // good ack!
  215   1        setReceive();
  216   1      }
  217          
  218          void send_BAD_ACK(void){
  219   1        setTransmit();
  220   1        serialwriteChar(0xC1);                // bad command message.
  221   1        setReceive();
  222   1      }
  223          
  224          void send_BAD_CRC_ACK(){
  225   1          setTransmit();
  226   1        serialwriteChar(0xC2);                // bad command message.
  227   1        setReceive();
  228   1      }
  229          
  230          void sendDeviceInfo(){
  231   1        setTransmit();
  232   1        sendString(deviceInfo,9);
  233   1        setReceive();
  234   1      }
  235          
  236          bool checkAddressWritable(uint32_t address) {
  237   1        return address >= APPLICATION_ADDRESS;
  238   1      }
  239          
  240          void decodeInput(){
  241   1        if(incoming_payload_no_command){
  242   2          len = payload_buffer_size;
  243   2        //  received_crc_low_byte = rxBuffer[len];          // one higher than len in buffer
  244   2        //  received_crc_high_byte = rxBuffer[len+1];
  245   2          if(checkCrc(rxBuffer,len)){
  246   3            int i;
  247   3            memset(payLoadBuffer, 0, sizeof(payLoadBuffer));             // reset buffer
  248   3      
  249   3            for(i = 0; i < len; i++){
  250   4              payLoadBuffer[i]= rxBuffer[i];
  251   4            }
  252   3            send_ACK();
  253   3            incoming_payload_no_command = 0;
C251 COMPILER V5.60.0,  main                                                               14/10/24  10:43:49  PAGE 5   

  254   3            return;
  255   3          }else{
  256   3            send_BAD_CRC_ACK();
  257   3            return;
  258   3          }
  259   2        }
  260   1      
  261   1        cmd = rxBuffer[0];
  262   1      
  263   1        if(rxBuffer[16] == 0x7d){
  264   2          if(rxBuffer[8] == 13 && rxBuffer[9] == 66){
  265   3            sendDeviceInfo();
  266   3            rxBuffer[20]= 0;
  267   3      
  268   3          }
  269   2          return;
  270   2        }
  271   1      
  272   1        if(rxBuffer[20] == 0x7d){
  273   2          if(rxBuffer[12] == 13 && rxBuffer[13] == 66){
  274   3            sendDeviceInfo();
  275   3            rxBuffer[20]= 0;
  276   3            return;
  277   3          }
  278   2      
  279   2        }
  280   1        if(rxBuffer[40] == 0x7d){
  281   2          if(rxBuffer[32] == 13 && rxBuffer[33] == 66){
  282   3            sendDeviceInfo();
  283   3            rxBuffer[20]= 0;
  284   3            return;
  285   3          }
  286   2        }
  287   1      
  288   1        if(cmd == CMD_RUN){         // starts the main app
  289   2          if((rxBuffer[1] == 0) && (rxBuffer[2] == 0) && (rxBuffer[3] == 0)){
  290   3            invalid_command = 101;
  291   3          }
  292   2        }
  293   1      
  294   1        if(cmd == CMD_PROG_FLASH){
  295   2          len = 2;
  296   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  297   3            send_BAD_CRC_ACK();
  298   3      
  299   3            return;
  300   3          }
  301   2      
  302   2          if (!checkAddressWritable(address)) {
  303   3            send_BAD_ACK();
  304   3      
  305   3            return;
  306   3          }
  307   2      
  308   2          save_flash_nolib((uint8_t*)payLoadBuffer, payload_buffer_size,address);
  309   2          send_ACK();
  310   2      
  311   2          return;
  312   2        }
  313   1      
  314   1        if(cmd == CMD_SET_ADDRESS){             //  command set addressinput format is: CMD, 00 , High byte addr
             -ess, Low byte address, crclb ,crchb
  315   2          len = 4;  // package without 2 byte crc
  316   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  317   3            send_BAD_CRC_ACK();
  318   3      
C251 COMPILER V5.60.0,  main                                                               14/10/24  10:43:49  PAGE 6   

  319   3            return;
  320   3          }
  321   2      
  322   2      
  323   2            // will send Ack 0x30 and read input after transfer out callback
  324   2          invalid_command = 0;
  325   2          address = STC32_FLASH_START + (rxBuffer[2] << 8 | rxBuffer[3]);
  326   2          send_ACK();
  327   2      
  328   2          return;
  329   2        }
  330   1      
  331   1        if(cmd == CMD_SET_BUFFER){        // for writing buffer rx buffer 0 = command byte.  command set address
             -, input , format is CMD, 00 , 00 or 01 (if buffer is 256), buffer_size,
  332   2          len = 4;  // package without 2 byte crc
  333   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  334   3            send_BAD_CRC_ACK();
  335   3      
  336   3            return;
  337   3          }
  338   2      
  339   2              // no ack with command set buffer;
  340   2              if(rxBuffer[2] == 0x01){
  341   3                payload_buffer_size = 256;                          // if nothing in this buffer
  342   3              }else{
  343   3                payload_buffer_size = rxBuffer[3];
  344   3              }
  345   2            incoming_payload_no_command = 1;
  346   2            address_expected_increment = 256;
  347   2              setReceive();
  348   2      
  349   2              return;
  350   2        }
  351   1      
  352   1        if(cmd == CMD_KEEP_ALIVE){
  353   2          len = 2;
  354   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  355   3            send_BAD_CRC_ACK();
  356   3      
  357   3            return;
  358   3          }
  359   2      
  360   2            setTransmit();
  361   2          serialwriteChar(0xC1);                // bad command message.
  362   2          setReceive();
  363   2      
  364   2          return;
  365   2        }
  366   1      
  367   1        if(cmd == CMD_ERASE_FLASH){
  368   2          len = 2;
  369   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  370   3            send_BAD_CRC_ACK();
  371   3      
  372   3            return;
  373   3          }
  374   2      
  375   2          if (!checkAddressWritable(address)) {
  376   3            send_BAD_ACK();
  377   3      
  378   3            return;
  379   3          }
  380   2      
  381   2          send_ACK();
  382   2          return;
  383   2        }
C251 COMPILER V5.60.0,  main                                                               14/10/24  10:43:49  PAGE 7   

  384   1      
  385   1        if(cmd == CMD_READ_EEPROM){
  386   2          eeprom_req = 1;
  387   2        }
  388   1      
  389   1        if(cmd == CMD_READ_FLASH_SIL){     // for sending contents of flash memory at the memory location set in
             - bootloader.c need to still set memory with data from set mem command
  390   2          uint16_t out_buffer_size;
  391   2          uint8_t *read_data;
  392   2          len = 2;
  393   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  394   3            send_BAD_CRC_ACK();
  395   3      
  396   3            return;
  397   3          }
  398   2      
  399   2          count++;
  400   2          out_buffer_size = rxBuffer[1];//
  401   2          if(out_buffer_size == 0){
  402   3            out_buffer_size = 256;
  403   3          }
  404   2          address_expected_increment = 128;
  405   2          read_data = (uint8_t*)malloc(out_buffer_size + 3);
  406   2          setTransmit();                            // make buffer 3 larger to fit CRC and ACK
  407   2          memset(read_data, 0, sizeof(read_data));
  408   2              //    read_flash((uint8_t*)read_data , address);                  // make sure read_flash reads t
             -wo less than buffer.
  409   2          read_flash_bin((uint8_t*)read_data , address, out_buffer_size);
  410   2      
  411   2              makeCrc(read_data,out_buffer_size);
  412   2              read_data[out_buffer_size] = calculated_crc_low_byte;
  413   2              read_data[out_buffer_size + 1] = calculated_crc_high_byte;
  414   2              read_data[out_buffer_size + 2] = 0x30;
  415   2              sendString(read_data, out_buffer_size+3);
  416   2      
  417   2          setReceive();
  418   2          free(read_data);
  419   2          return;
  420   2        }
  421   1      
  422   1          setTransmit();
  423   1      
  424   1        serialwriteChar(0xC1);                // bad command message.
  425   1        invalid_command++;
  426   1        setReceive();
  427   1      }
  428          
  429          
  430          
  431          
*** WARNING C64 IN LINE 107 OF Bootloader\src\main.c: 'MX_TIM2_Init': static function declared but not defined
*** WARNING C64 IN LINE 110 OF Bootloader\src\main.c: 'MX_GPIO_INPUT_INIT': static function declared but not defined


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1137     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       569     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
C251 COMPILER V5.60.0,  main                                                               14/10/24  10:43:49  PAGE 8   

  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        83     ------
End of Module Information.


C251 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)

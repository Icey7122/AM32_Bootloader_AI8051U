C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Compiler\Keil_v5\C251\BIN\C251.EXE bootloader\main.c XSMALL FUNCTIONS(REENTRANT) FLOAT64 WARNING
                    -LEVEL(3) OPTIMIZE(3,SPEED) BROWSE ORDER INCDIR(.\Inc;.\Mcu\8051u\Inc) DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\
                    -Objects\main.obj) 

stmt  level    source

    1          /*
    2            bootloader for AM32 ESC firmware
    3          
    4            based on https://github.com/AlkaMotors/AT32F421_AM32_Bootloader
    5           */
    6          #include "main.h"
    7          #include <stdio.h>
    8          
    9          #include "version.h"
   10          
   11          /* Includes ------------------------------------------------------------------*/
   12          #include "nstdbool.h"
   13          #include <stdio.h>
   14          #include <stdlib.h>
   15          
   16          //#pragma GCC optimize("O0")
   17          
   18          #include "eeprom.h"
   19          
   20          
   21          #define USE_P01
   22          
   23          #define DISABLE_APP_HEADER_CHECKS
   24          
   25          //#define USE_ADC_INPUT      // will go right to application and ignore eeprom
   26          //#define UPDATE_EEPROM_ENABLE
   27          
   28          // use this to check the clock config for the MCU (with a logic
   29          // analyser on the input pin)
   30          //#define BOOTLOADER_TEST_CLOCK
   31          
   32          // use this to check the string output code. When enabled
   33          // the string HELLO_WORLD is output every 10ms
   34          // #define BOOTLOADER_TEST_STRING
   35          
   36          // when there is no app fw yet, disable jump()
   37          //#define DISABLE_JUMP
   38          
   39          // optionally enable stats on serial bit-banging
   40          //#define SERIAL_STATS
   41          
   42          /*
   43            enable checking for software reset for jump.
   44            generally on a software reset we do want to stay in the bootloader
   45            if the signal pin is floating, but disabling this can be useful for
   46            CAN testing
   47          */
   48          #define CHECK_SOFTWARE_RESET 1
   49          
   50          /*
   51            enable checking for eeprom configured before jump
   52            disabling this can be useful for CAN development
   53          */
   54          #define CHECK_EEPROM_BEFORE_JUMP 1
   55          
   56          /*
   57            should we update the bootloader version in eeprom?
C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 2   

   58           */
   59          #define UPDATE_EEPROM_ENABLE 1
   60          
   61          #include <string.h>
   62          
   63          #ifndef MCU_FLASH_START
   64          #define MCU_FLASH_START 0xFF0000
   65          #endif
   66          
   67          #ifndef FIRMWARE_RELATIVE_START
   68          #define FIRMWARE_RELATIVE_START 0x1000
   69          #endif
   70          
   71          #ifdef USE_P01
   72          #define input_pin        P01
   73          #define input_port       P0
   74          #define mode_set_pin   GPIO_ModePin_1   
   75          #define PIN_NUMBER       1
   76          #define PORT_LETTER      0
   77          
   78          #elif defined(USE_P11)
               #define input_pin        P11
               #define input_port       P1
               #define mode_set_pin   GPIO_ModePin_1 
               #define PIN_NUMBER       1
               #define PORT_LETTER      1
               
               #elif defined(USE_P21)
               #define input_pin        P21
               #define input_port       P2
               #define mode_set_pin   GPIO_ModePin_1
               #define PIN_NUMBER       1
               #define PORT_LETTER      2
               
               #elif defined(USE_P50)
               #define input_pin        P50
               #define input_port       P5
               #define mode_set_pin   GPIO_ModePin_0
               #define PIN_NUMBER       0
               #define PORT_LETTER      5
               
               #else
               #error "Bootloader comms pin not defined"
               #endif
  102          
  103          static uint16_t invalid_command;
  104          
  105          #include "blutil.h"
  106          
  107          #ifndef BOARD_FLASH_SIZE
               #error "must define BOARD_FLASH_SIZE"
               #endif
  110          
  111          #define PIN_CODE (PORT_LETTER << 4 | PIN_NUMBER)
  112          
  113          /*
  114            currently only support 32, 64 or 128 k flash
  115           */
  116          #if BOARD_FLASH_SIZE == 32
               #define EEPROM_START_ADD (uint32_t)(MCU_FLASH_START+0x7c00)
               #define FLASH_SIZE_CODE 0x1f
               #define ADDRESS_SHIFT 0
               
               #elif BOARD_FLASH_SIZE == 64
  122          #define EEPROM_START_ADD (uint32_t)(MCU_FLASH_START+0xF800)
  123          #define FLASH_SIZE_CODE 0x35
C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 3   

  124          #define ADDRESS_SHIFT 0
  125          
  126          #elif BOARD_FLASH_SIZE == 128
               #define EEPROM_START_ADD (uint32_t)(MCU_FLASH_START+0x1f800)
               #define FLASH_SIZE_CODE 0x2B
               #define ADDRESS_SHIFT 2 // addresses from the bl client are shifted 2 bits before being used
               #else
               #error "unsupported BOARD_FLASH_SIZE"
               #endif
  133          
  134          /*
  135            the devinfo structure tells the configuration client our pin code,
  136            flash size and device type. It can also be used by the main firmware
  137            to confirm we have the right eeprom address and pin code. We have 2
  138            32bit magic values so the main firmware can confirm the bootloader
  139            supports this feature
  140           */
  141          #define DEVINFO_MAGIC1 0x5925e3da
  142          #define DEVINFO_MAGIC2 0x4eb863d9
  143          
  144          static const struct {
  145              uint32_t magic1;
  146              uint32_t magic2;
  147              const uint8_t deviceInfo[9];
  148          } devinfo _at_ (MCU_FLASH_START + FIRMWARE_RELATIVE_START - 32) = {
  149                  {DEVINFO_MAGIC1},
  150                  {DEVINFO_MAGIC2},
  151                  {'4','7','1',PIN_CODE,FLASH_SIZE_CODE,0x06,0x06,0x01,0x30}
  152          };
  153          
  154          typedef void (*pFunction)(void);
  155          
  156          #define APPLICATION_ADDRESS     (uint32_t)(MCU_FLASH_START + FIRMWARE_RELATIVE_START)
  157          
  158          #define CMD_RUN             0x00
  159          #define CMD_PROG_FLASH      0x01
  160          #define CMD_ERASE_FLASH     0x02
  161          #define CMD_READ_FLASH_SIL  0x03
  162          #define CMD_VERIFY_FLASH    0x03
  163          #define CMD_VERIFY_FLASH_ARM 0x04
  164          #define CMD_READ_EEPROM     0x04
  165          #define CMD_PROG_EEPROM     0x05
  166          #define CMD_READ_SRAM       0x06
  167          #define CMD_READ_FLASH_ATM  0x07
  168          #define CMD_KEEP_ALIVE      0xFD
  169          #define CMD_SET_ADDRESS     0xFF
  170          #define CMD_SET_BUFFER      0xFE
  171          
  172          static uint16_t low_pin_count;
  173          static char receiveByte;
  174          static int count;
  175          static char messagereceived;
  176          static uint16_t address_expected_increment;
  177          static int cmd;
  178          static char eeprom_req;
  179          static int received;
  180          
  181          static uint8_t xdata rxBuffer[258];
  182          static uint8_t xdata payLoadBuffer[256];
  183          static char rxbyte;
  184          static uint32_t address;
  185          
  186          typedef union {
  187              uint8_t bytes[2];
  188              uint16_t word;
  189          } uint8_16_u;
C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 4   

  190          
  191          static uint16_t len;
  192          static uint8_t calculated_crc_low_byte;
  193          static uint8_t calculated_crc_high_byte;
  194          static uint16_t payload_buffer_size;
  195          static char incoming_payload_no_command;
  196          
  197          /* USER CODE BEGIN PFP */
  198          static void sendString(const uint8_t dat[], int len);
  199          static void receiveBuffer();
  200          static void serialwriteChar(uint8_t dat);
  201          
  202          #define BAUDRATE      19200
  203          #define BITTIME          52 // 1000000/BAUDRATE
  204          #define HALFBITTIME      26 // 500000/BAUDRATE
  205          
  206          static void delayMicroseconds(uint32_t micros)
  207          {
  208   1          bl_timer_reset();
  209   1          while (bl_timer_us() < micros) {
  210   2          }
  211   1      }
  212          /*
  213            jump to the application firmware
  214           */
  215          static void jump()
  216          {
  217   1      #ifndef DISABLE_JUMP
  218   1      #if CHECK_EEPROM_BEFORE_JUMP
  219   1        uint8_t value = *(unsigned char far*)EEPROM_START_ADD;
  220   1      #endif
  221   1      #ifndef DISABLE_APP_HEADER_CHECKS
                   const uint32_t *app = (unsigned char far*)(MCU_FLASH_START + FIRMWARE_RELATIVE_START);
                   const uint32_t ram_start = 0x000000;
                   const uint32_t ram_limit_kb = 64;
                   const uint32_t ram_end = ram_start+ram_limit_kb*1024;
                 const uint32_t flash_limit_kb = 256;
               #endif
  228   1      #if CHECK_EEPROM_BEFORE_JUMP
  229   1        if (value != 0x01) {      // check first byte of eeprom to see if its programmed, if not do not jump
  230   2          invalid_command = 0;
  231   2          return;
  232   2          }
  233   1      #endif
  234   1      #ifndef DISABLE_APP_HEADER_CHECKS
                   /*
                     first word of the app is the stack pointer - make sure that it is in range
                    */
                   if (app[0] < ram_start || app[0] > ram_end) {
                 invalid_command = 0;
                 return;
                   }
                   /*
                     2nd word is the entry point of the main app. Ensure that is in range
                    */
                 if (app[1] < APPLICATION_ADDRESS || app[1] > APPLICATION_ADDRESS+flash_limit_kb*1024) {
                 // outside a 256k range, really unlikely to be a valid
                 // application, don't jump
                 invalid_command = 0;
                 return;
                   }
               #endif
  252   1        jump_to_application();
  253   1      #endif
  254   1      }
  255          
C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 5   

  256          
  257          static void makeCrc(uint8_t* pBuff, uint16_t length)
  258          {
  259   1        uint16_t i;
  260   1        uint8_t xb;
  261   1        static uint8_16_u CRC_16;
  262   1        
  263   1        CRC_16.word=0;
  264   1        for(i = 0; i < length; i++) {
  265   2          uint8_t j;
  266   2          xb = pBuff[i];
  267   2          for ( j = 0; j < 8; j++)
  268   2          {
  269   3            if (((xb & 0x01) ^ (CRC_16.word & 0x0001)) !=0 ) {
  270   4              CRC_16.word = CRC_16.word >> 1;
  271   4              CRC_16.word = CRC_16.word ^ 0xA001;
  272   4            } else {
  273   4              CRC_16.word = CRC_16.word >> 1;
  274   4            }
  275   3            xb = xb >> 1;
  276   3          }
  277   2        }
  278   1        calculated_crc_low_byte = CRC_16.bytes[1];        //C251是大端编译模式
  279   1        calculated_crc_high_byte = CRC_16.bytes[0];
  280   1      }
  281          
  282          static char checkCrc(uint8_t* pBuff, uint16_t length)
  283          {
  284   1        uint8_t received_crc_low_byte2 = pBuff[length];          // one higher than len in buffer
  285   1        uint8_t received_crc_high_byte2 = pBuff[length+1];
  286   1        makeCrc(pBuff,length);
  287   1        if((calculated_crc_low_byte==received_crc_low_byte2)   && (calculated_crc_high_byte==received_crc_high_b
             -yte2)){
  288   2          return 1;
  289   2        }else{
  290   2          return 0;
  291   2        }
  292   1      }
  293          
  294          static void setReceive()
  295          {
  296   1          // gpio_mode_set_input(input_pin, GPIO_PULL_UP);
  297   1        gpio_mode_set(input_port, mode_set_pin, GPIO_Mode_IPU);
  298   1          received = 0;
  299   1      }
  300          
  301          static void setTransmit()
  302          {
  303   1          // set high before we set as output to guarantee idle high
  304   1          gpio_set(input_port,input_pin);
  305   1          gpio_mode_set(input_port,input_pin, GPIO_Mode_Out_PP);
  306   1      
  307   1          // delay a bit to let the sender get setup for receiving
  308   1          delayMicroseconds(BITTIME);
  309   1      }
  310          
  311          static void send_ACK()
  312          {
  313   1          setTransmit();
  314   1          serialwriteChar(0x30);             // good ack!
  315   1          setReceive();
  316   1      }
  317          
  318          static void send_BAD_ACK()
  319          {
  320   1          setTransmit();
C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 6   

  321   1          serialwriteChar(0xC1);                // bad command message.
  322   1          setReceive();
  323   1      }
  324          
  325          static void send_BAD_CRC_ACK()
  326          {
  327   1          setTransmit();
  328   1          serialwriteChar(0xC2);                // bad command message.
  329   1          setReceive();
  330   1      }
  331          
  332          static void sendDeviceInfo()
  333          {
  334   1          setTransmit();
  335   1          sendString(devinfo.deviceInfo,sizeof(devinfo.deviceInfo));
  336   1          setReceive();
  337   1      }
  338          
  339          static bool checkAddressWritable(uint32_t address)
  340          {
  341   1          return address >= APPLICATION_ADDRESS;
  342   1      }
  343          
  344          
  345          static void decodeInput()
  346          {
  347   1          if (incoming_payload_no_command) {
  348   2        uint16_t i;
  349   2        len = payload_buffer_size;
  350   2        if (checkCrc(rxBuffer,len)) {
  351   3            memset(payLoadBuffer, 0, sizeof(payLoadBuffer));             // reset buffer
  352   3      
  353   3            for(i = 0; i < len; i++){
  354   4          payLoadBuffer[i]= rxBuffer[i];
  355   4            }
  356   3            send_ACK();
  357   3            incoming_payload_no_command = 0;
  358   3            return;
  359   3        }else{
  360   3            send_BAD_CRC_ACK();
  361   3            return;
  362   3        }
  363   2          }
  364   1      
  365   1          cmd = rxBuffer[0];
  366   1      
  367   1          if (rxBuffer[16] == 0x7d) {
  368   2        if(rxBuffer[8] == 13 && rxBuffer[9] == 66) {
  369   3            sendDeviceInfo();
  370   3            rxBuffer[20]= 0;
  371   3      
  372   3        }
  373   2        return;
  374   2          }
  375   1      
  376   1          if (rxBuffer[20] == 0x7d) {
  377   2        if(rxBuffer[12] == 13 && rxBuffer[13] == 66) {
  378   3            sendDeviceInfo();
  379   3            rxBuffer[20]= 0;
  380   3            return;
  381   3        }
  382   2      
  383   2          }
  384   1          if (rxBuffer[40] == 0x7d) {
  385   2        if (rxBuffer[32] == 13 && rxBuffer[33] == 66) {
  386   3            sendDeviceInfo();
C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 7   

  387   3            rxBuffer[20]= 0;
  388   3            return;
  389   3        }
  390   2          }
  391   1      
  392   1          if (cmd == CMD_RUN) {
  393   2        // starts the main app
  394   2        if((rxBuffer[1] == 0) && (rxBuffer[2] == 0) && (rxBuffer[3] == 0)) {
  395   3            invalid_command = 101;
  396   3        }
  397   2          }
  398   1      
  399   1          if (cmd == CMD_PROG_FLASH) {
  400   2        len = 2;
  401   2        if (!checkCrc((uint8_t*)rxBuffer, len)) {
  402   3            send_BAD_CRC_ACK();
  403   3      
  404   3            return;
  405   3        }
  406   2      
  407   2        if (!checkAddressWritable(address)) {
  408   3            send_BAD_ACK();
  409   3      
  410   3            return;
  411   3        }
  412   2      
  413   2        if (!save_flash_nolib((uint8_t*)payLoadBuffer, payload_buffer_size,address)) {
  414   3            send_BAD_ACK();
  415   3        } else {
  416   3            send_ACK();
  417   3        }
  418   2      
  419   2        return;
  420   2          }
  421   1      
  422   1          if (cmd == CMD_SET_ADDRESS) {
  423   2        // command set addressinput format is: CMD, 00 , High byte
  424   2        // address, Low byte address, crclb ,crchb
  425   2        len = 4;  // package without 2 byte crc
  426   2        if (!checkCrc((uint8_t*)rxBuffer, len)) {
  427   3            send_BAD_CRC_ACK();
  428   3      
  429   3            return;
  430   3        }
  431   2      
  432   2      
  433   2        // will send Ack 0x30 and read input after transfer out callback
  434   2        invalid_command = 0;
  435   2        address = MCU_FLASH_START + ((rxBuffer[2] << 8 | rxBuffer[3]) << ADDRESS_SHIFT);
  436   2        send_ACK();
  437   2      
  438   2        return;
  439   2          }
  440   1      
  441   1          if (cmd == CMD_SET_BUFFER) {
  442   2        // for writing buffer rx buffer 0 = command byte.  command set
  443   2        // address, input , format is CMD, 00 , 00 or 01 (if buffer is 256),
  444   2        // buffer_size,
  445   2        len = 4;  // package without 2 byte crc
  446   2        if (!checkCrc((uint8_t*)rxBuffer, len)) {
  447   3            send_BAD_CRC_ACK();
  448   3      
  449   3            return;
  450   3        }
  451   2      
  452   2              // no ack with command set buffer;
C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 8   

  453   2              if(rxBuffer[2] == 0x01){
  454   3            payload_buffer_size = 256;                          // if nothing in this buffer
  455   3              }else{
  456   3            payload_buffer_size = rxBuffer[3];
  457   3              }
  458   2        incoming_payload_no_command = 1;
  459   2        address_expected_increment = 256;
  460   2              setReceive();
  461   2      
  462   2              return;
  463   2          }
  464   1      
  465   1          if (cmd == CMD_KEEP_ALIVE) {
  466   2        len = 2;
  467   2        if (!checkCrc((uint8_t*)rxBuffer, len)) {
  468   3            send_BAD_CRC_ACK();
  469   3      
  470   3            return;
  471   3        }
  472   2      
  473   2        setTransmit();
  474   2        serialwriteChar(0xC1);                // bad command message.
  475   2        setReceive();
  476   2      
  477   2        return;
  478   2          }
  479   1      
  480   1          if (cmd == CMD_ERASE_FLASH) {
  481   2        len = 2;
  482   2        if (!checkCrc((uint8_t*)rxBuffer, len)) {
  483   3            send_BAD_CRC_ACK();
  484   3      
  485   3            return;
  486   3        }
  487   2      
  488   2        if (!checkAddressWritable(address)) {
  489   3            send_BAD_ACK();
  490   3      
  491   3            return;
  492   3        }
  493   2      
  494   2        send_ACK();
  495   2        return;
  496   2          }
  497   1      
  498   1          if (cmd == CMD_READ_EEPROM) {
  499   2        eeprom_req = 1;
  500   2          }
  501   1      
  502   1          if (cmd == CMD_READ_FLASH_SIL) {
  503   2        // for sending contents of flash memory at the memory location set in
  504   2        // bootloader.c need to still set memory with data from set mem
  505   2        // command
  506   2        uint16_t out_buffer_size;
  507   2        uint8_t xdata* read_data;
  508   2      
  509   2        len = 2;
  510   2        if (!checkCrc((uint8_t*)rxBuffer, len)) {
  511   3            send_BAD_CRC_ACK();
  512   3      
  513   3            return;
  514   3        }
  515   2      
  516   2        count++;
  517   2        out_buffer_size = rxBuffer[1];//
  518   2        if(out_buffer_size == 0){
C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 9   

  519   3            out_buffer_size = 256;
  520   3        }
  521   2        address_expected_increment = 128;
  522   2      
  523   2        setTransmit();
  524   2        read_data = (uint8_t xdata*)malloc(out_buffer_size + 3);        // make buffer 3 larger to fit CRC and A
             -CK
  525   2        memset(read_data, 0, sizeof(read_data));
  526   2              //    read_flash((uint8_t*)read_data , address);                 // make sure read_flash reads tw
             -o less than buffer.
  527   2        read_flash_bin((uint8_t xdata*)read_data , address, out_buffer_size);
  528   2      
  529   2              makeCrc(read_data,out_buffer_size);
  530   2              read_data[out_buffer_size] = calculated_crc_low_byte;
  531   2              read_data[out_buffer_size + 1] = calculated_crc_high_byte;
  532   2              read_data[out_buffer_size + 2] = 0x30;
  533   2              sendString(read_data, out_buffer_size+3);
  534   2      
  535   2        setReceive();
  536   2      
  537   2        return;
  538   2          }
  539   1      
  540   1          setTransmit();
  541   1      
  542   1          serialwriteChar(0xC1);                // bad command message.
  543   1          invalid_command++;
  544   1          setReceive();
  545   1      }
  546          
  547          #ifdef SERIAL_STATS
               // stats for debugging serial protocol
               struct {
                   uint32_t no_idle;
                   uint32_t no_start;
                   uint32_t bad_start;
                   uint32_t bad_stop;
                   uint32_t good;
               } stats;
               #endif
  557          
  558          
  559          /*
  560            read one byte from the input pin, 19200, not inverted, one stop bit
  561          
  562            return false if we can't get a byte, or the byte has bad framing
  563           */
  564          static bool serialreadChar()
  565          {
  566   1        int bits_to_read;
  567   1          rxbyte=0;
  568   1          bl_timer_reset();
  569   1      
  570   1          // UART is idle high, wait for it to be in the idle state
  571   1          while (~gpio_read(input_port,input_pin)) { // wait for rx to go high
  572   2        if (bl_timer_us() > 20000) {
  573   3            /*
  574   3              if we don't get a command for 20ms then assume we should
  575   3              be trying to boot the main firmware, invalid_command 101
  576   3              triggers the jump immediately
  577   3             */
  578   3            invalid_command = 101;
  579   3      #ifdef SERIAL_STATS
                     stats.no_idle++;
               #endif
  582   3            return false;
C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 10  

  583   3        }
  584   2          }
  585   1      
  586   1          // now we need to wait for the start bit leading edge, which is low
  587   1          bl_timer_reset();
  588   1          while (gpio_read(input_port,input_pin)) {
  589   2        if (bl_timer_us() > 5*BITTIME && messagereceived) {
  590   3            // we've been waiting too long, don't allow for long gaps
  591   3            // between bytes
  592   3      #ifdef SERIAL_STATS
                     stats.no_start++;
               #endif
  595   3            return false;
  596   3        }
  597   2          }
  598   1      
  599   1          // wait to get the center of bit time. We want to sample at the
  600   1          // middle of each bit
  601   1          delayMicroseconds(HALFBITTIME);
  602   1          if (gpio_read(input_port,input_pin)) {
  603   2        // bad framing, we should be half-way through the start bit
  604   2        // which should still be low
  605   2      #ifdef SERIAL_STATS
                 stats.bad_start++;
               #endif
  608   2        return false;
  609   2          }
  610   1      
  611   1          /*
  612   1            now sample the 8 data bits
  613   1           */
  614   1          bits_to_read = 0;
  615   1          while (bits_to_read < 8) {
  616   2        delayMicroseconds(BITTIME);
  617   2        rxbyte = rxbyte | (uint8_t)gpio_read(input_port,input_pin) << bits_to_read;
  618   2        bits_to_read++;
  619   2          }
  620   1      
  621   1          // wait till middle of stop bit, so we can check that too
  622   1          delayMicroseconds(BITTIME);
  623   1          if (~gpio_read(input_port,input_pin)) {
  624   2        // bad framing, stop bit should be high
  625   2      #ifdef SERIAL_STATS
                 stats.bad_stop++;
               #endif
  628   2        return false;
  629   2          }
  630   1      
  631   1          // we got a good byte
  632   1          messagereceived = 1;
  633   1          receiveByte = rxbyte;
  634   1      #ifdef SERIAL_STATS
                   stats.good++;
               #endif
  637   1          return true;
  638   1      }
  639          
  640          static void serialwriteChar(uint8_t dat)
  641          {
  642   1        uint8_t bits_written;
  643   1          // start bit is low
  644   1          gpio_clear(input_port,input_pin);
  645   1          delayMicroseconds(BITTIME);
  646   1      
  647   1          // send data bits
  648   1          bits_written = 0;
C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 11  

  649   1          while (bits_written < 8) {
  650   2        if (dat & 0x01) {
  651   3            gpio_set(input_port,input_pin);
  652   3        } else {
  653   3            // GPIO_BC(input_port) = input_pin;
  654   3            gpio_clear(input_port,input_pin);
  655   3        }
  656   2        bits_written++;
  657   2        dat = dat >> 1;
  658   2        delayMicroseconds(BITTIME);
  659   2          }
  660   1      
  661   1          // send stop bit
  662   1          gpio_set(input_port,input_pin);
  663   1      
  664   1          /*
  665   1            note that we skip the delay by BITTIME for the full stop bit and
  666   1            do it in sendString() instead to ensure when sending an ACK
  667   1            immediately followed by a setReceive() on a slow MCU that we
  668   1            start on the receive as soon as possible.
  669   1          */
  670   1      }
  671          
  672          static void sendString(const uint8_t dat[], int len)
  673          {
  674   1        int i;
  675   1          for(i = 0; i < len; i++){
  676   2              serialwriteChar(dat[i]);
  677   2              // for multi-byte writes we add the stop bit delay
  678   2              delayMicroseconds(BITTIME);
  679   2          }
  680   1      }
  681          
  682          static void receiveBuffer()
  683          {
  684   1        uint32_t i;
  685   1          count = 0;
  686   1          messagereceived = 0;
  687   1          memset(rxBuffer, 0, sizeof(rxBuffer));
  688   1      
  689   1          setReceive();
  690   1      
  691   1          for(i = 0; i < sizeof(rxBuffer); i++){
  692   2        if (!serialreadChar()) {
  693   3            break;
  694   3        }
  695   2      
  696   2        if(incoming_payload_no_command) {
  697   3            if(count == payload_buffer_size+2){
*** WARNING C173 IN LINE 697 OF bootloader\main.c: '==': signed/unsigned type mismatch
  698   4          break;
  699   4            }
  700   3            rxBuffer[i] = rxbyte;
  701   3            count++;
  702   3        } else {
  703   3            if(bl_timer_us() > 250){
  704   4        
  705   4          count = 0;
  706   4      
  707   4          break;
  708   4            } else {
  709   4          rxBuffer[i] = rxbyte;
  710   4          if(i == 257){
  711   5              invalid_command+=20;       // needs one hundred to trigger a jump but will be reset on next set add
             -ress commmand
  712   5      
C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 12  

  713   5          }
  714   4            }
  715   3        }
  716   2          }
  717   1          if (messagereceived) {
  718   2        decodeInput();
  719   2          }
  720   1      }
  721          
  722          #ifdef UPDATE_EEPROM_ENABLE
  723          static void update_EEPROM()
  724          {
  725   1          read_flash_bin(rxBuffer , EEPROM_START_ADD , 48);
  726   1          if (BOOTLOADER_VERSION != rxBuffer[2]) {
  727   2        if (rxBuffer[2] == 0xFF || rxBuffer[2] == 0x00){
  728   3            return;
  729   3        }
  730   2        rxBuffer[2] = BOOTLOADER_VERSION;
  731   2        save_flash_nolib(rxBuffer, 48, EEPROM_START_ADD);
  732   2          }
  733   1      }
  734          #endif // UPDATE_EEPROM_ENABLE
  735          
  736          static void checkForSignal()
  737          {
  738   1        int i;
  739   1          gpio_mode_set(input_port,mode_set_pin, GPIO_Mode_IN_FLOATING);
  740   1        
  741   1          delayMicroseconds(500);
  742   1      
  743   1          for(i = 0 ; i < 500; i ++){
  744   2        if(~gpio_read(input_port,input_pin)){
  745   3            low_pin_count++;
  746   3        }else{
  747   3        }
  748   2      
  749   2        delayMicroseconds(10);
  750   2          }
  751   1          if (low_pin_count > 450) {
  752   2      #if CHECK_SOFTWARE_RESET
  753   2              if (bl_was_software_reset()) {
  754   3            jump();
  755   3              }
  756   2      #else
                       jump();
               #endif
  759   2          }
  760   1      
  761   1          gpio_mode_set(input_port,mode_set_pin, GPIO_Mode_IPU);
  762   1        
  763   1          delayMicroseconds(500);
  764   1      
  765   1          for (i = 0 ; i < 500; i++) {
  766   2        if( ~(gpio_read(input_port,input_pin))){
  767   3            low_pin_count++;
  768   3        }else{
  769   3      
  770   3        }
  771   2        delayMicroseconds(10);
  772   2          }
  773   1          if (low_pin_count == 0) {
  774   2        return;           // all high while pin is pulled low, bootloader signal
  775   2          }
  776   1      
  777   1          low_pin_count = 0;
  778   1      
C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 13  

  779   1          gpio_mode_set(input_port,mode_set_pin, GPIO_Mode_IN_FLOATING);
  780   1      
  781   1          delayMicroseconds(500);
  782   1      
  783   1          for (i = 0 ; i < 500; i ++) {
  784   2        if( ~(gpio_read(input_port,input_pin))){
  785   3            low_pin_count++;
  786   3        }
  787   2      
  788   2        delayMicroseconds(10);
  789   2          }
  790   1          if (low_pin_count == 0) {
  791   2        return;            // when floated all
  792   2          }
  793   1      
  794   1          if (low_pin_count > 0) {
  795   2        jump();
  796   2          }
  797   1      }
  798          
  799          #ifdef BOOTLOADER_TEST_CLOCK
               /*
                 this should provide a 2ms low followed by a 1ms high if the clock is correct
                */
               static void test_clock(void)
               {
                   setTransmit();
                   while (1) {
                 gpio_clear(input_pin);
                 bl_timer_reset();
                 while (bl_timer_us() < 2000) ;
                 gpio_set(input_pin);
                 bl_timer_reset();
                 while (bl_timer_us() < 1000) ;
                   }
               }
               #endif // BOOTLOADER_TEST_CLOCK
  816          
  817          #ifdef BOOTLOADER_TEST_STRING
               /*
                 this should send HELLO_WORLD continuously
                */
               static void test_string(void)
               {
                   setTransmit();
                   while (1) {
                       delayMicroseconds(10000);
                       sendString((uint8_t*)"HELLO_WORLD\n",13);
                   }
               }
               #endif // BOOTLOADER_TEST_STRING
  830          
  831          // void Uart1_Init(void)  //921600bps@48MHz
  832          // {
  833          //  SCON = 0x50;    //8位数据,可变波特率
  834          //  AUXR |= 0x01;   //串口1选择定时器2为波特率发生器
  835          //  AUXR |= 0x04;   //定时器时钟1T模式
  836          //  T2L = 0xA9;     //设置定时初始值
  837          //  T2H = 0xFF;     //设置定时初始值
  838          //  AUXR |= 0x10;   //定时器2开始计时
  839          
  840          
  841          //  P3M0 |= 0x03; P3M1 &= ~0x03; 
  842          //  P2M0 |= 0x03; P2M1 &= ~0x03; 
  843          // }
  844          
C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 14  

  845          
  846          int main(void)
  847          {
  848   1        //Prevent warnings
  849   1        static uint8_t xdata MEMPOOL[1024];   //内存池
  850   1        init_mempool(MEMPOOL, sizeof(MEMPOOL)); //初始化内存池
  851   1      
  852   1          bl_clock_config();
  853   1          bl_timer_init();
  854   1          bl_gpio_init();
  855   1        // Uart1_Init();  
  856   1        IAP_TPS = 40;
  857   1      
  858   1      #ifdef BOOTLOADER_TEST_CLOCK
                   test_clock();
               #endif
  861   1      #ifdef BOOTLOADER_TEST_STRING
                   test_string();
               #endif
  864   1      
  865   1          checkForSignal();
  866   1      
  867   1          gpio_mode_set(input_port,mode_set_pin, GPIO_Mode_IN_FLOATING);
  868   1          
  869   1      #ifdef USE_ADC_INPUT  // go right to application
                   jump();
               #endif
  872   1      
  873   1      #ifdef UPDATE_EEPROM_ENABLE
  874   1           update_EEPROM();
  875   1      #endif
  876   1        // printf("Bootloader version: %d\n", BOOTLOADER_VERSION);
  877   1          while (1) {
  878   2          receiveBuffer();
  879   2          if (invalid_command > 100) {
  880   3              jump();
  881   3          }
  882   2          }
  883   1      }
  884          
  885          
  886          
  887          // #pragma FUNCTIONS (static)
  888          // char putchar(char c)
  889          // {
  890          //  // serialwriteChar(c);
  891          //  SBUF = c;
  892          //  while (!TI);
  893          //  TI = 0;
  894          //  return c;
  895          // }
  896          
  897          
  898          
  899          
  900          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2431     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =      1538     ------
  xdata-const size     =    ------     ------
C251 COMPILER V5.60.0,  main                                                               11/11/24  12:33:54  PAGE 15  

  edata size           =        29     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        17     ------
End of Module Information.


C251 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)

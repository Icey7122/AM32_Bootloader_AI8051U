C251 COMPILER V5.60.0,  main                                                               20/10/24  10:38:11  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Compiler\Keil_v5\C251\BIN\C251.EXE Bootloader\src\main.c XSMALL FUNCTIONS(REENTRANT) FLOAT64 OPT
                    -IMIZE(3,SPEED) INCDIR(.\Bootloader\inc) DEBUG PRINT(.\Objects\main.lst) TABS(2) OBJECT(.\Objects\main.obj) 

stmt  level    source

    1          /* Bootloader */
    2          
    3          #define BOOTLOADER_VERSION 10
    4          
    5          #define USE_P01
    6          /* Includes ------------------------------------------------------------------*/
    7          #include "nstdbool.h"
    8          #include "main.h"
    9          
   10          //#define USE_ADC_INPUT      // will go right to application and ignore eeprom
   11          
   12          #include "nstdint.h"
   13          #include <stdlib.h>
   14          #include <string.h>
   15          #include "bootloader.h"
   16          
   17          #define STC32_FLASH_START 0x00000000
   18          #define FIRMWARE_RELATIVE_START 0x0000
   19          #define EEPROM_RELATIVE_START 0x0000
   20          
   21          uint8_t bootloader_version = BOOTLOADER_VERSION;
   22          
   23          typedef void (*pFunction)(void);
   24          
   25          #define APPLICATION_ADDRESS     (uint32_t)(STC32_FLASH_START + FIRMWARE_RELATIVE_START) // 4k
   26          
   27          #define EEPROM_START_ADD         (uint32_t)(STC32_FLASH_START + EEPROM_RELATIVE_START)
   28          #define FLASH_END_ADD           (uint32_t)(STC32_FLASH_START + 0xFFFF)               // 32 k
   29          
   30          
   31          #define CMD_RUN             0x00
   32          #define CMD_PROG_FLASH      0x01
   33          #define CMD_ERASE_FLASH     0x02
   34          #define CMD_READ_FLASH_SIL  0x03
   35          #define CMD_VERIFY_FLASH    0x03
   36          #define CMD_VERIFY_FLASH_ARM 0x04
   37          #define CMD_READ_EEPROM     0x04
   38          #define CMD_PROG_EEPROM     0x05
   39          #define CMD_READ_SRAM       0x06
   40          #define CMD_READ_FLASH_ATM  0x07
   41          #define CMD_KEEP_ALIVE      0xFD
   42          #define CMD_SET_ADDRESS     0xFF
   43          #define CMD_SET_BUFFER      0xFE
   44          
   45          
   46          #ifdef USE_P01
   47          
   48          #define input_pin        P01
   49          #define input_port       P0
   50          #define PIN_NUMBER       0
   51          #define PORT_LETTER      0
   52          
   53          #endif
   54          
   55          #ifdef USE_PB4
               // #define input_pin       LL_GPIO_PIN_4
               // #define input_port        GPIOB
               // #define PIN_NUMBER        4
C251 COMPILER V5.60.0,  main                                                               20/10/24  10:38:11  PAGE 2   

               // #define PORT_LETTER       1
               #endif
   61          
   62          
   63          uint16_t low_pin_count = 0;
   64          char receviedByte;
   65          int receivedCount;
   66          int count = 0;
   67          char messagereceived = 0;
   68          uint16_t invalid_command = 0;
   69          uint16_t address_expected_increment;
   70          int cmd = 0;
   71          char eeprom_req = 0;
   72          int received;
   73          uint8_t port_letter;
   74          
   75          
   76          uint8_t pin_code = PORT_LETTER << 4 | PIN_NUMBER;
   77          uint8_t deviceInfo[9] = { 0 };      // stm32 device info
   78          
   79          size_t str_len;
   80          char connected = 0;
   81          uint8_t rxBuffer[258];
   82          uint8_t payLoadBuffer[256];
   83          char rxbyte=0;
   84          uint32_t address;
   85          int tick = 0;
   86          
   87          typedef union {
   88              uint8_t bytes[2];
   89              uint16_t word;
   90          } uint8_16_u;
   91          uint16_t len;
   92          uint8_t received_crc_low_byte;
   93          uint8_t received_crc_high_byte;
   94          uint8_t calculated_crc_low_byte;
   95          uint8_t calculated_crc_high_byte;
   96          uint16_t payload_buffer_size;
   97          char incoming_payload_no_command = 0;
   98          
   99          char bootloaderactive = 1;
  100          
  101          uint32_t JumpAddress;
  102          // pFunction JumpToApplication;
  103          #define JumpToApplication()   IAP_CONTR = 0x20
  104          
  105          
  106          void SystemClock_Config(void);
  107          //static void MX_GPIO_Init(void);
  108          static void PWMB_Timer_Init(void);
  109          
  110          /* USER CODE BEGIN PFP */
  111          static void GPIO_INPUT_INIT(void);
  112          
  113          void processmessage(void);
  114          void serialwriteChar(char dat);
  115          void sendString(uint8_t dat[], int len);
  116          void recieveBuffer();
  117          
  118          #define BAUDRATE              19200
  119          #define BITTIME          1000000/BAUDRATE
  120          #define HALFBITTIME       500000/BAUDRATE
  121          
  122          //ÂæÖÊîπÔºà‰ΩøÁî®ÂÆöÊó∂Âô®ÂÅöÂª∂Êó∂ÂáΩÊï∞Ôºâ
  123          void delayMicroseconds(uint32_t micros){
  124   1        // TIM2->CNT = 0;
C251 COMPILER V5.60.0,  main                                                               20/10/24  10:38:11  PAGE 3   

  125   1        PWMB_CNTRH = 0x00;
  126   1        PWMB_CNTRL = 0x00;
  127   1        while (((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) < micros){
  128   2        }
  129   1      }
  130          
  131          void jump(){
  132   1      
  133   1        uint8_t value;
  134   1      
  135   1        EA = 0;
  136   1      
  137   1        IAP_ENABLE();                           //ËÆæÁΩÆÁ≠âÂæÖÊó∂Èó¥ÔºåÂÖÅËÆ∏IAPÊìç‰ΩúÔºåÈÄÅ‰∏ÄÊ¨°Â∞±Â§ü
  138   1          IAP_READ();                             
  139   1      
  140   1        IAP_ADDRE = (uint8_t)(EEPROM_START_ADD >> 16); 
  141   1        IAP_ADDRH = (uint8_t)(EEPROM_START_ADD >> 8);  
  142   1        IAP_ADDRL = (uint8_t)EEPROM_START_ADD;         
  143   1        IAP_TRIG = 0x5A;
  144   1        IAP_TRIG = 0xA5;                   
  145   1        _nop_();   
  146   1        _nop_();
  147   1        _nop_();
  148   1        _nop_();
  149   1        while(CMD_FAIL);
  150   1      
  151   1        value = IAP_DATA;            //ËØªÂá∫ÁöÑÊï∞ÊçÆÈÄÅÂæÄ
  152   1      
  153   1        IAP_DISABLE();
  154   1      
  155   1      #ifdef USE_ADC_INPUT
               #else
  157   1        if (value != 0x01){      // check first byte of eeprom to see if its programmed, if not do not jump
  158   2          invalid_command = 0;
  159   2          return;
  160   2        }
  161   1      #endif
  162   1         JumpToApplication();
  163   1      }
  164          
  165          
  166          void makeCrc(uint8_t* pBuff, uint16_t length){
  167   1        int i;
  168   1        uint8_t xb;
  169   1        static uint8_16_u CRC_16;
  170   1        
  171   1        CRC_16.word=0;
  172   1        for(i = 0; i < length; i++) {
  173   2          uint8_t j;
  174   2          xb = pBuff[i];
  175   2          for ( j = 0; j < 8; j++)
  176   2          {
  177   3            if (((xb & 0x01) ^ (CRC_16.word & 0x0001)) !=0 ) {
  178   4              CRC_16.word = CRC_16.word >> 1;
  179   4              CRC_16.word = CRC_16.word ^ 0xA001;
  180   4            } else {
  181   4              CRC_16.word = CRC_16.word >> 1;
  182   4            }
  183   3            xb = xb >> 1;
  184   3          }
  185   2        }
  186   1        calculated_crc_low_byte = CRC_16.bytes[0];
  187   1        calculated_crc_high_byte = CRC_16.bytes[1];
  188   1      }
  189          
  190          char checkCrc(uint8_t* pBuff, uint16_t length){
C251 COMPILER V5.60.0,  main                                                               20/10/24  10:38:11  PAGE 4   

  191   1      
  192   1        char received_crc_low_byte2 = pBuff[length];          // one higher than len in buffer
  193   1        char received_crc_high_byte2 = pBuff[length+1];
  194   1        makeCrc(pBuff,length);
  195   1        if((calculated_crc_low_byte==received_crc_low_byte2)   && (calculated_crc_high_byte==received_crc_high_b
             -yte2)){
  196   2          return 1;
  197   2        }else{
  198   2          return 0;
  199   2        }
  200   1      
  201   1      }
  202          
  203          //ÂæÖÊîπÔºàÊé•Êî∂ÂºïËÑöÂàùÂßãÂåñÔºâ‰∏äÊãâËæìÂÖ•
  204          void setReceive(void){
  205   1      
  206   1        GPIO_INPUT_INIT();
  207   1        received = 0;
  208   1      
  209   1      }
  210          //ÂæÖÊîπÔºàÂèëÈÄÅÂºïËÑöÂàùÂßãÂåñÔºâ
  211          void setTransmit(void){
  212   1        // LL_GPIO_SetPinMode(input_port, input_pin, LL_GPIO_MODE_OUTPUT);       // set as reciever // clear bit
             -s and set receive bits..
  213   1        P0M0 |= 0x02; P0M1 &= ~0x02;  //Êé®ÊåΩËæìÂá∫
  214   1        P0PU &= ~0x02; P0PD &= ~0x02;   //Êó†‰∏ä‰∏ãÊãâ
  215   1      }
  216          
  217          void send_ACK(void){
  218   1          setTransmit();
  219   1          serialwriteChar(0x30);             // good ack!
  220   1        setReceive();
  221   1      }
  222          
  223          void send_BAD_ACK(void){
  224   1        setTransmit();
  225   1        serialwriteChar(0xC1);                // bad command message.
  226   1        setReceive();
  227   1      }
  228          
  229          void send_BAD_CRC_ACK(){
  230   1          setTransmit();
  231   1        serialwriteChar(0xC2);                // bad command message.
  232   1        setReceive();
  233   1      }
  234          
  235          void sendDeviceInfo(){
  236   1        setTransmit();
  237   1        sendString(deviceInfo,9);
  238   1        setReceive();
  239   1      }
  240          
  241          bool checkAddressWritable(uint32_t address) {
  242   1        return address >= APPLICATION_ADDRESS;
  243   1      }
  244          
  245          void decodeInput(){
  246   1        if(incoming_payload_no_command){
  247   2          len = payload_buffer_size;
  248   2        //  received_crc_low_byte = rxBuffer[len];          // one higher than len in buffer
  249   2        //  received_crc_high_byte = rxBuffer[len+1];
  250   2          if(checkCrc(rxBuffer,len)){
  251   3            int i;
  252   3            memset(payLoadBuffer, 0, sizeof(payLoadBuffer));             // reset buffer
  253   3      
  254   3            for(i = 0; i < len; i++){
C251 COMPILER V5.60.0,  main                                                               20/10/24  10:38:11  PAGE 5   

  255   4              payLoadBuffer[i]= rxBuffer[i];
  256   4            }
  257   3            send_ACK();
  258   3            incoming_payload_no_command = 0;
  259   3            return;
  260   3          }else{
  261   3            send_BAD_CRC_ACK();
  262   3            return;
  263   3          }
  264   2        }
  265   1      
  266   1        cmd = rxBuffer[0];
  267   1      
  268   1        if(rxBuffer[16] == 0x7d){
  269   2          if(rxBuffer[8] == 13 && rxBuffer[9] == 66){
  270   3            sendDeviceInfo();
  271   3            rxBuffer[20]= 0;
  272   3      
  273   3          }
  274   2          return;
  275   2        }
  276   1      
  277   1        if(rxBuffer[20] == 0x7d){
  278   2          if(rxBuffer[12] == 13 && rxBuffer[13] == 66){
  279   3            sendDeviceInfo();
  280   3            rxBuffer[20]= 0;
  281   3            return;
  282   3          }
  283   2      
  284   2        }
  285   1        if(rxBuffer[40] == 0x7d){
  286   2          if(rxBuffer[32] == 13 && rxBuffer[33] == 66){
  287   3            sendDeviceInfo();
  288   3            rxBuffer[20]= 0;
  289   3            return;
  290   3          }
  291   2        }
  292   1      
  293   1        if(cmd == CMD_RUN){         // starts the main app
  294   2          if((rxBuffer[1] == 0) && (rxBuffer[2] == 0) && (rxBuffer[3] == 0)){
  295   3            invalid_command = 101;
  296   3          }
  297   2        }
  298   1      
  299   1        if(cmd == CMD_PROG_FLASH){
  300   2          len = 2;
  301   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  302   3            send_BAD_CRC_ACK();
  303   3      
  304   3            return;
  305   3          }
  306   2      
  307   2          if (!checkAddressWritable(address)) {
  308   3            send_BAD_ACK();
  309   3      
  310   3            return;
  311   3          }
  312   2      
  313   2          save_flash_nolib((uint8_t*)payLoadBuffer, payload_buffer_size,address);
  314   2          send_ACK();
  315   2      
  316   2          return;
  317   2        }
  318   1      
  319   1        if(cmd == CMD_SET_ADDRESS){             //  command set addressinput format is: CMD, 00 , High byte addr
             -ess, Low byte address, crclb ,crchb
C251 COMPILER V5.60.0,  main                                                               20/10/24  10:38:11  PAGE 6   

  320   2          len = 4;  // package without 2 byte crc
  321   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  322   3            send_BAD_CRC_ACK();
  323   3      
  324   3            return;
  325   3          }
  326   2      
  327   2      
  328   2            // will send Ack 0x30 and read input after transfer out callback
  329   2          invalid_command = 0;
  330   2          address = STC32_FLASH_START + (rxBuffer[2] << 8 | rxBuffer[3]);
  331   2          send_ACK();
  332   2      
  333   2          return;
  334   2        }
  335   1      
  336   1        if(cmd == CMD_SET_BUFFER){        // for writing buffer rx buffer 0 = command byte.  command set address
             -, input , format is CMD, 00 , 00 or 01 (if buffer is 256), buffer_size,
  337   2          len = 4;  // package without 2 byte crc
  338   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  339   3            send_BAD_CRC_ACK();
  340   3      
  341   3            return;
  342   3          }
  343   2      
  344   2              // no ack with command set buffer;
  345   2              if(rxBuffer[2] == 0x01){
  346   3                payload_buffer_size = 256;                          // if nothing in this buffer
  347   3              }else{
  348   3                payload_buffer_size = rxBuffer[3];
  349   3              }
  350   2            incoming_payload_no_command = 1;
  351   2            address_expected_increment = 256;
  352   2              setReceive();
  353   2      
  354   2              return;
  355   2        }
  356   1      
  357   1        if(cmd == CMD_KEEP_ALIVE){
  358   2          len = 2;
  359   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  360   3            send_BAD_CRC_ACK();
  361   3      
  362   3            return;
  363   3          }
  364   2      
  365   2            setTransmit();
  366   2          serialwriteChar(0xC1);                // bad command message.
  367   2          setReceive();
  368   2      
  369   2          return;
  370   2        }
  371   1      
  372   1        if(cmd == CMD_ERASE_FLASH){
  373   2          len = 2;
  374   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  375   3            send_BAD_CRC_ACK();
  376   3      
  377   3            return;
  378   3          }
  379   2      
  380   2          if (!checkAddressWritable(address)) {
  381   3            send_BAD_ACK();
  382   3      
  383   3            return;
  384   3          }
C251 COMPILER V5.60.0,  main                                                               20/10/24  10:38:11  PAGE 7   

  385   2      
  386   2          send_ACK();
  387   2          return;
  388   2        }
  389   1      
  390   1        if(cmd == CMD_READ_EEPROM){
  391   2          eeprom_req = 1;
  392   2        }
  393   1      
  394   1        if(cmd == CMD_READ_FLASH_SIL){     // for sending contents of flash memory at the memory location set in
             - bootloader.c need to still set memory with data from set mem command
  395   2          uint16_t out_buffer_size;
  396   2          uint8_t *read_data;
  397   2          len = 2;
  398   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  399   3            send_BAD_CRC_ACK();
  400   3      
  401   3            return;
  402   3          }
  403   2      
  404   2          count++;
  405   2          out_buffer_size = rxBuffer[1];//
  406   2          if(out_buffer_size == 0){
  407   3            out_buffer_size = 256;
  408   3          }
  409   2          address_expected_increment = 128;
  410   2          read_data = (uint8_t*)malloc(out_buffer_size + 3);
  411   2          setTransmit();                            // make buffer 3 larger to fit CRC and ACK
  412   2          memset(read_data, 0, sizeof(read_data));
  413   2              //    read_flash((uint8_t*)read_data , address);                  // make sure read_flash reads t
             -wo less than buffer.
  414   2          read_flash_bin((uint8_t*)read_data , address, out_buffer_size);
  415   2      
  416   2              makeCrc(read_data,out_buffer_size);
  417   2              read_data[out_buffer_size] = calculated_crc_low_byte;
  418   2              read_data[out_buffer_size + 1] = calculated_crc_high_byte;
  419   2              read_data[out_buffer_size + 2] = 0x30;
  420   2              sendString(read_data, out_buffer_size+3);
  421   2      
  422   2          setReceive();
  423   2          free(read_data);
  424   2          return;
  425   2        }
  426   1      
  427   1          setTransmit();
  428   1      
  429   1        serialwriteChar(0xC1);                // bad command message.
  430   1        invalid_command++;
  431   1        setReceive();
  432   1      }
  433          
  434          void serialreadChar()
  435          {
  436   1        int bits_to_read;
  437   1        rxbyte=0;
  438   1      
  439   1      
  440   1        PWMB_PSCRL = 0xBF; // set to 1/4mhz
  441   1        PWMB_CNTRH = 0x00;
  442   1        PWMB_CNTRL = 0x00;
  443   1        while(~(input_pin)){ // wait for rx to go high
  444   2          if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 50000){
  445   3              invalid_command = 101;
  446   3              return;
  447   3          }
  448   2        }
C251 COMPILER V5.60.0,  main                                                               20/10/24  10:38:11  PAGE 8   

  449   1      
  450   1      
  451   1        PWMB_PSCRL = 0x2F; // set Buck to 1MHz
  452   1        PWMB_CNTRH = 0x00;
  453   1        PWMB_CNTRL = 0x00;
  454   1        while(input_pin){   // wait for it go go low
  455   2          if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 250 && messagereceived){
  456   3            return;
  457   3          }
  458   2        }
  459   1      
  460   1        delayMicroseconds(HALFBITTIME);//wait to get the center of bit time
  461   1      
  462   1        bits_to_read = 0;
  463   1        while (bits_to_read < 8) {
  464   2          delayMicroseconds(BITTIME);
  465   2          rxbyte = rxbyte | ((uint8_t)(input_pin) >> PIN_NUMBER) << bits_to_read;
  466   2        bits_to_read++;
  467   2        }
  468   1      
  469   1        delayMicroseconds(HALFBITTIME); //wait till the stop bit time begins
  470   1        messagereceived = 1;
  471   1        receviedByte = rxbyte;
  472   1        //return rxbyte;
  473   1      
  474   1      }
  475          
  476          void serialwriteChar(char dat)
  477          {
  478   1      
  479   1        //BRR Âè™ÂÜôÂØÑÂ≠òÂô®ÔºöÂè™ËÉΩÊîπÂèòÁÆ°ËÑöÁä∂ÊÄÅ‰∏∫‰ΩéÁîµÂπ≥ÔºåÂØπÂØÑÂ≠òÂô® ÁÆ°ËÑöÂØπ‰∫é‰ΩçÂÜô 1 Áõ∏Â∫îÁ
             -Æ°ËÑö‰ºö‰∏∫‰ΩéÁîµÂπ≥„ÄÇÂÜô 0 Êó†Âä®‰Ωú„ÄÇ
  480   1        // input_port->BRR = input_pin;; //initiate start bit
  481   1        char bits_to_read = 0;
  482   1      
  483   1        input_pin = 0;          //initiate start bit
  484   1      
  485   1        
  486   1        while (bits_to_read < 8) {
  487   2      
  488   2          delayMicroseconds(BITTIME);
  489   2      
  490   2          if (dat & 0x01) {
  491   3            // input_port->BSRR = input_pin;
  492   3            input_pin = 1;
  493   3          }else{
  494   3            // input_port->BRR = input_pin;
  495   3            input_pin = 0;
  496   3          }
  497   2          bits_to_read++;
  498   2          dat = dat >> 1;
  499   2        }
  500   1      
  501   1        delayMicroseconds(BITTIME);
  502   1      
  503   1        // input_port->BSRR = input_pin; //write the stop bit
  504   1      
  505   1      
  506   1        input_pin = 1;          //write the stop bit
  507   1      
  508   1      
  509   1        // if more than one byte a delay is needed after stop bit,
  510   1        //if its the only one no delay, the sendstring function adds delay after each bit
  511   1      
  512   1        //if(cmd == 255 || cmd == 254 || cmd == 1  || incoming_payload_no_command){
  513   1        //
C251 COMPILER V5.60.0,  main                                                               20/10/24  10:38:11  PAGE 9   

  514   1        //}else{
  515   1        //  delayMicroseconds(BITTIME);
  516   1        //}
  517   1      }
  518          
  519          void sendString(uint8_t *dat, int len){
  520   1        int i;
  521   1        for(i = 0; i < len; i++){
  522   2          serialwriteChar(dat[i]);
  523   2          delayMicroseconds(BITTIME);
  524   2        }
  525   1      }
  526          
  527          void recieveBuffer(void){
  528   1      
  529   1        int i = 0;
  530   1        count = 0;
  531   1        messagereceived = 0;
  532   1        memset(rxBuffer, 0, sizeof(rxBuffer));
  533   1      
  534   1      
  535   1        for(i = 0; i < sizeof(rxBuffer); i++){
  536   2          serialreadChar();
  537   2          if(incoming_payload_no_command){
  538   3            if(count == payload_buffer_size+2){
  539   4              break;
  540   4            }
  541   3            rxBuffer[i] = rxbyte;
  542   3            count++;
  543   3          }else{
  544   3            if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 250){
  545   4            count = 0;
  546   4            break;
  547   4            }else{
  548   4            rxBuffer[i] = rxbyte;
  549   4            if(i == 257){
  550   5              invalid_command+=20;       // needs one hundred to trigger a jump but will be reset on next set addre
             -ss commmand
  551   5      
  552   5              }
  553   4            }
  554   3          }
  555   2        }
  556   1        decodeInput();
  557   1      }
  558          
  559          void update_EEPROM(void){
  560   1        read_flash_bin(rxBuffer , EEPROM_START_ADD , 48);
  561   1        if(BOOTLOADER_VERSION != rxBuffer[2]){
  562   2          if (rxBuffer[2] == 0xFF || rxBuffer[2] == 0x00){
  563   3            return;
  564   3          }
  565   2          rxBuffer[2] = BOOTLOADER_VERSION;
  566   2          save_flash_nolib(rxBuffer, 48, EEPROM_START_ADD);
  567   2        }
  568   1      }
  569          
  570          void checkForSignal(void){
  571   1        //uint8_t floating_or_signal= 0;
  572   1        // LL_GPIO_SetPinPull(input_port, input_pin, LL_GPIO_PULL_DOWN);
  573   1        int i;
  574   1      
  575   1        P0PU &= ~0x02; //ÂÖ≥Èó≠‰∏äÊãâÁîµÈòª
  576   1        P0PD |= 0x02; //ÂºÄÂêØ‰∏ãÊãâÁîµÈòª
  577   1      
  578   1        delayMicroseconds(500);
C251 COMPILER V5.60.0,  main                                                               20/10/24  10:38:11  PAGE 10  

  579   1      
  580   1        for(i = 0 ; i < 500; i ++){
  581   2          if(~input_pin){
  582   3            low_pin_count++;
  583   3          }else{
  584   3        //   high_pin_count++;
  585   3          }
  586   2          delayMicroseconds(10);
  587   2        }
  588   1      
  589   1        if(low_pin_count == 0){
  590   2          return;           // all high while pin is pulled low, bootloader signal
  591   2        }
  592   1      
  593   1        low_pin_count = 0;
  594   1      
  595   1        P0PU &= ~0x02; //ÂÖ≥Èó≠‰∏äÊãâÁîµÈòª
  596   1        P0PD &= ~0x02; //ÂÖ≥Èó≠‰∏ãÊãâÁîµÈòª 
  597   1        // LL_GPIO_SetPinPull(input_port, input_pin, LL_GPIO_PULL_NO);
  598   1        delayMicroseconds(500);
  599   1      
  600   1        for(i = 0 ; i < 500; i ++){
  601   2          if(~input_pin){
  602   3            low_pin_count++;
  603   3          }
  604   2          delayMicroseconds(10);
  605   2        }
  606   1      
  607   1        if(low_pin_count == 0){
  608   2          return;            // when floated all
  609   2        }
  610   1      
  611   1        if(low_pin_count > 0){
  612   2          jump();
  613   2        }
  614   1      }
  615          
  616          
  617          void Uart1_Init(void) //921600bps@48MHz
  618          {
  619   1        SCON = 0x50;    //8‰ΩçÊï∞ÊçÆ,ÂèØÂèòÊ≥¢ÁâπÁéá
  620   1        AUXR |= 0x01;   //‰∏≤Âè£1ÈÄâÊã©ÂÆöÊó∂Âô®2‰∏∫Ê≥¢ÁâπÁéáÂèëÁîüÂô®
  621   1        AUXR |= 0x04;   //ÂÆöÊó∂Âô®Êó∂Èíü1TÊ®°Âºè
  622   1        T2L = 0xF3;     //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
  623   1        T2H = 0xFF;     //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
  624   1        AUXR |= 0x10;   //ÂÆöÊó∂Âô®2ÂºÄÂßãËÆ°Êó∂
  625   1      }
  626          
  627          #include <stdio.h>
  628          
  629          
  630          int main(void)
  631          {
  632   1      
  633   1        //Prevent warnings
  634   1        (void)bootloader_version;
*** WARNING C138 IN LINE 634 OF Bootloader\src\main.c: expression with possibly no effect
  635   1      
  636   1          // LL_APB1_GRP2_EnableClock(LL_APB1_GRP2_PERIPH_SYSCFG);
  637   1          // LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
  638   1      
  639   1          // FLASH->ACR |= FLASH_ACR_PRFTBE;   // prefetch buffer enable
  640   1      
  641   1          SystemClock_Config();
  642   1        Uart1_Init();
  643   1      
C251 COMPILER V5.60.0,  main                                                               20/10/24  10:38:11  PAGE 11  

  644   1        P3M0 |= 0x03; P3M1 &= ~0x03; 
  645   1        P2M0 |= 0x03; P2M1 &= ~0x03; 
  646   1      
  647   1        PWMB_Timer_Init();
  648   1      
  649   1      
  650   1        while (1)
  651   1        {
  652   2          // printf("SystemClock_Config\n");
  653   2          printf("%u\n",((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL));
  654   2        }
  655   1      
  656   1      //      GPIO_INPUT_INIT();     // init the pin with a pulldown
  657   1      
  658   1      //      checkForSignal();
  659   1      
  660   1      
  661   1      //  P0PD &= ~0x02;
  662   1      //  P0PU |= 0x02;     //‰∏äÊãâËæìÂÖ•
  663   1      //      // LL_GPIO_SetPinPull(input_port, input_pin, LL_GPIO_PULL_UP);
  664   1      
  665   1      // #ifdef USE_ADC_INPUT  // go right to application
  666   1      //    jump();
  667   1      // #endif
  668   1      //    deviceInfo[3] = pin_code;
  669   1      //    update_EEPROM();
  670   1      
  671   1      // //  sendDeviceInfo();
  672   1      //    while (1)
  673   1      //    {
  674   1      //      recieveBuffer();
  675   1      //      if (invalid_command > 100){
  676   1      //        jump();
  677   1      //      }
  678   1      //    }
  679   1      
  680   1      }
  681          
  682          
  683          
  684          void SystemClock_Config(void)
  685          {
  686   1        EA = 0;
  687   1      
  688   1        CKCON = 0x00;           // ËÆæÁΩÆÂ§ñÈÉ®Êï∞ÊçÆÊÄªÁ∫ø‰∏∫ÊúÄÂø´
  689   1        WTST = 1;                 // ËÆæÁΩÆÁ®ãÂ∫è‰ª£Á†ÅÁ≠âÂæÖÂèÇÊï∞ÔºåËµãÂÄº‰∏∫0ÂèØÂ∞ÜCPUÊâßË°åÁ®ãÂ∫èÁöÑÈÄüÂ∫¶ËÆæ
             -ÁΩÆ‰∏∫ÊúÄÂø´
  690   1        P_SW2 = 0x80;         // ÂºÄÂêØÁâπÊÆäÂú∞ÂùÄËÆøÈóÆ
  691   1      
  692   1        CLKDIV = 0x04;      //‰∏ªÊó∂ÈíüMCLKËæìÂá∫Âà∞Á≥ªÁªüÊó∂Èíü(SYSCLK)ÂàÜÈ¢ë1
  693   1             
  694   1        IRTRIM = CHIPID12;        //ÂÜÖÈÉ®Êó∂ÈíüÊ∫êÈÄâÊã©24M
  695   1        HIRCSEL1 = 1;
  696   1        HIRCSEL0 = 0;       //27MhzÈ¢ëÊÆµ
  697   1      
  698   1        HIRCCR = 0x80;
  699   1        while (!(HIRCCR & 0x01));
  700   1        
  701   1        // MCLKOCR = 72;          //ÂàÜÈ¢ë72,ËæìÂá∫Êó∂ÈíüÁöÑÂàÜÈ¢ë
  702   1      
  703   1        CLKSEL = 0x40;      //PLL,È´òÈÄüIOÔºåÁ≥ªÁªüÊó∂ÈíüÊ∫êÁöÑÁõ∏ÂÖ≥ËÆæÁΩÆ(ÂÖàÈÄâÊã©ÂÜÖÈÉ®IRC‰Ωú‰∏∫Á≥ªÁªüÊó∂Èíü)
  704   1      
  705   1        USBCLK &= 0x0F;
  706   1        USBCLK |= 0xA0;
  707   1        NOP(5);         //Á≠âÂæÖÊó∂ÈíüÁ®≥ÂÆö
  708   1      
C251 COMPILER V5.60.0,  main                                                               20/10/24  10:38:11  PAGE 12  

  709   1        //PLL‰∫ßÁîü96MhzÊó∂Èíü
  710   1      
  711   1        CLKDIV = 0X01;      //‰∏ªÊó∂ÈíüMCLKËæìÂá∫Âà∞Á≥ªÁªüÊó∂Èíü(SYSCLK)ÂàÜÈ¢ë1
  712   1      
  713   1        CLKSEL |= 0x08;     //MCLKÈÄâÊã©PLL/2‰∏∫Êó∂ÈíüÊ∫ê->48Mhz
  714   1      
  715   1        HSCLKDIV = 0x01;    //È´òÈÄüPWM,SPI,I2S,TFPUÊó∂Èíü96MHz
  716   1      
  717   1        USBCKS = 1;       
  718   1        USBCKS2 = 0;      //USBÊó∂ÈíüÈÄâÊã©48Mhz
  719   1      
  720   1        EA = 1;
  721   1      }
  722          
  723          
  724          static void PWMB_Timer_Init(void)
  725          {
  726   1        PWMB_ENO = 0x00;    //Á¶ÅÊ≠¢PWMBÁöÑPWMËæìÂá∫
  727   1        PWMB_IOAUX = 0x00;    //Á¶ÅÊ≠¢PWMB
  728   1      
  729   1        PWMB_ARRH = 0xFF;
  730   1        PWMB_ARRL = 0xFF;   //ËÆæÁΩÆPWMBÂë®Êúü‰∏∫65535
  731   1        PWMB_CNTRH = 0x00;
  732   1        PWMB_CNTRL = 0x00;    //Ê∏ÖÈõ∂ËÆ°Êï∞Âô®
  733   1        PWMB_PSCRH = 0x00;    
  734   1        PWMB_PSCRL = 0x2F;    //PWMBÊó∂ÈíüÊ∫êÂàÜÈ¢ëÂà∞1Mhz
  735   1        PWMB_IER = 0x00;    //Á¶ÅÊ≠¢PWMB‰∏≠Êñ≠
  736   1        PWMB_CR1 = 0x01;    //‰ΩøËÉΩËÆ°Êï∞Âô®
  737   1      }
  738          
  739          
  740          
  741          static void GPIO_INPUT_INIT(void)
  742          {
  743   1      #ifdef USE_PB4
               #endif
  745   1      #ifdef USE_PA2
               #endif
  747   1      
  748   1          P0M0 &= ~0x02; 
  749   1        P0M1 |= 0x02;   
  750   1          P0NCS &= ~0x02; 
  751   1          P0IE |= 0x02; 
  752   1        P0PU |= 0x02; 
  753   1        //È´òÈòª‰∏äÊãâËæìÂÖ•
  754   1      }
  755          
  756          
  757          #pragma FUNCTIONS (static)
  758          char putchar(char c)
  759          {
  760   1        // serialwriteChar(c);
  761   1        SBUF = c;
  762   1        while (!TI);
  763   1        TI = 0;
  764   1        return c;
  765   1      }
  766          
  767          
  768          
  769          
  770          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2437     ------
C251 COMPILER V5.60.0,  main                                                               20/10/24  10:38:11  PAGE 13  

  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       569     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        87     ------
End of Module Information.


C251 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)

C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Compiler\Keil_v5\C251\BIN\C251.EXE Bootloader\src\main.c XSMALL FUNCTIONS(REENTRANT) FLOAT64 OPT
                    -IMIZE(0,SPEED) INCDIR(.\Bootloader\inc) DEBUG CODE LISTINCLUDE SYMBOLS PRINT(.\Objects\main.lst) TABS(2) PREPRINT(.\Obje
                    -cts\main.i) OBJECT(.\Objects\main.obj) 

stmt  level    source

    1          /* Bootloader */
    2          
    3          #define BOOTLOADER_VERSION 10
    4          
    5          #define USE_P01
    6          /* Includes ------------------------------------------------------------------*/
    7          #include "nstdbool.h"
    1       =1 #ifndef _NSTDBOOL_H
    2       =1 #define _NSTDBOOL_H
    3       =1 
    4       =1 #define bool bit
    5       =1 #define true 1
    6       =1 #define false 0
    7       =1 
    8       =1 
    9       =1 #endif // !_NSTDBOOL_H
    8          #include "main.h"
    1       =1 #ifndef INC_MAIN_H_
    2       =1 #define INC_MAIN_H_
    3       =1 
    4       =1 #include "nstdint.h"
    1       =2 #ifndef _NSTDINT_H
    2       =2 #define _NSTDINT_H
    3       =2 
    4       =2 typedef unsigned char uint8_t;
    5       =2 typedef unsigned int uint16_t;
    6       =2 typedef unsigned long uint32_t;
    7       =2 typedef char    int8_t;
    8       =2 typedef int     int16_t;
    9       =2 typedef long    int32_t;
   10       =2 
   11       =2 #endif // !_NSTDINT_H
    5       =1 #include "intrins.h"
    1       =2 /*--------------------------------------------------------------------------
    2       =2 INTRINS.H
    3       =2 
    4       =2 Intrinsic functions for C251 Version 3.
    5       =2 Copyright (c) 1995-2001 Keil Elektronik GmbH and Keil Software, Inc.
    6       =2 All rights reserved.
    7       =2 --------------------------------------------------------------------------*/
    8       =2 
    9       =2 #pragma SAVE
   10       =2 #pragma PARM251
   11       =2 
   12       =2 #if __C251__ >= 200
   13       =2 #pragma FUNCTIONS(STATIC)
   14       =2 /* intrinsic functions are reentrant, but need static attribute */
   15       =2 #endif
   16       =2 
   17       =2 extern void          _nop_     (void);
   18       =2 extern bit           _testbit_ (bit);
   19       =2 extern unsigned char _cror_    (unsigned char, unsigned char);
   20       =2 extern unsigned int  _iror_    (unsigned int,  unsigned char);
   21       =2 extern unsigned long _lror_    (unsigned long, unsigned char);
   22       =2 extern unsigned char _crol_    (unsigned char, unsigned char);
   23       =2 extern unsigned int  _irol_    (unsigned int,  unsigned char);
   24       =2 extern unsigned long _lrol_    (unsigned long, unsigned char);
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 2   

   25       =2 extern unsigned char _chkfloat_  (float x)  reentrant;
   26       =2 extern unsigned char _chkdouble_ (double x) reentrant;
   27       =2 
   28       =2 #pragma RESTORE
    6       =1 #include "STC8051U.H"
    1       =2 #ifndef __STC8051U_H__
    2       =2 #define __STC8051U_H__
    3       =2 
    4       =2 /////////////////////////////////////////////////
    5       =2 
    6       =2 sfr         P0          =           0x80;
    7       =2     sbit    P00         =           P0^0;
    8       =2     sbit    P01         =           P0^1;
    9       =2     sbit    P02         =           P0^2;
   10       =2     sbit    P03         =           P0^3;
   11       =2     sbit    P04         =           P0^4;
   12       =2     sbit    P05         =           P0^5;
   13       =2     sbit    P06         =           P0^6;
   14       =2     sbit    P07         =           P0^7;
   15       =2 
   16       =2 sfr         SP          =           0x81;
   17       =2 sfr         DPL         =           0x82;
   18       =2 sfr         DPH         =           0x83;
   19       =2 sfr         DPXL        =           0x84;
   20       =2 sfr         SPH         =           0x85;
   21       =2 
   22       =2 sfr         PCON        =           0x87;
   23       =2     sbit    SMOD        =           PCON^7;
   24       =2     sbit    SMOD0       =           PCON^6;
   25       =2     sbit    LVDF        =           PCON^5;
   26       =2     sbit    POF         =           PCON^4;
   27       =2     sbit    GF1         =           PCON^3;
   28       =2     sbit    GF0         =           PCON^2;
   29       =2     sbit    PD          =           PCON^1;
   30       =2     sbit    IDL         =           PCON^0;
   31       =2 
   32       =2 sfr         TCON        =           0x88;
   33       =2     sbit    TF1         =           TCON^7;
   34       =2     sbit    TR1         =           TCON^6;
   35       =2     sbit    TF0         =           TCON^5;
   36       =2     sbit    TR0         =           TCON^4;
   37       =2     sbit    IE1         =           TCON^3;
   38       =2     sbit    IT1         =           TCON^2;
   39       =2     sbit    IE0         =           TCON^1;
   40       =2     sbit    IT0         =           TCON^0;
   41       =2 
   42       =2 sfr         TMOD        =           0x89;
   43       =2     sbit    T1_GATE     =           TMOD^7;
   44       =2     sbit    T1_CT       =           TMOD^6;
   45       =2     sbit    T1_M1       =           TMOD^5;
   46       =2     sbit    T1_M0       =           TMOD^4;
   47       =2     sbit    T0_GATE     =           TMOD^3;
   48       =2     sbit    T0_CT       =           TMOD^2;
   49       =2     sbit    T0_M1       =           TMOD^1;
   50       =2     sbit    T0_M0       =           TMOD^0;
   51       =2 
   52       =2 sfr         TL0         =           0x8a;
   53       =2 sfr         TL1         =           0x8b;
   54       =2 sfr         TH0         =           0x8c;
   55       =2 sfr         TH1         =           0x8d;
   56       =2 
   57       =2 sfr         AUXR        =           0x8e;
   58       =2     sbit    T0x12       =           AUXR^7;
   59       =2     sbit    T1x12       =           AUXR^6;
   60       =2     sbit    S1M0x6      =           AUXR^5;
   61       =2     sbit    T2R         =           AUXR^4;
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 3   

   62       =2     sbit    T2_CT       =           AUXR^3;
   63       =2     sbit    T2x12       =           AUXR^2;
   64       =2     sbit    EXTRAM      =           AUXR^1;
   65       =2     sbit    S1BRT       =           AUXR^0;
   66       =2 
   67       =2 sfr         INTCLKO     =           0x8f;
   68       =2     sbit    EX4         =           INTCLKO^6;
   69       =2     sbit    EX3         =           INTCLKO^5;
   70       =2     sbit    EX2         =           INTCLKO^4;
   71       =2     sbit    T2CLKO      =           INTCLKO^2;
   72       =2     sbit    T1CLKO      =           INTCLKO^1;
   73       =2     sbit    T0CLKO      =           INTCLKO^0;
   74       =2 
   75       =2 sfr         P1          =           0x90;
   76       =2     sbit    P10         =           P1^0;
   77       =2     sbit    P11         =           P1^1;
   78       =2     sbit    P12         =           P1^2;
   79       =2     sbit    P13         =           P1^3;
   80       =2     sbit    P14         =           P1^4;
   81       =2     sbit    P15         =           P1^5;
   82       =2     sbit    P16         =           P1^6;
   83       =2     sbit    P17         =           P1^7;
   84       =2 
   85       =2 sfr         P1M1        =           0x91;
   86       =2 sfr         P1M0        =           0x92;
   87       =2 sfr         P0M1        =           0x93;
   88       =2 sfr         P0M0        =           0x94;
   89       =2 sfr         P2M1        =           0x95;
   90       =2 sfr         P2M0        =           0x96;
   91       =2 
   92       =2 sfr         AUXR2       =           0x97;
   93       =2     sbit    RAMTINY     =           AUXR2^7;
   94       =2     sbit    CPUMODE     =           AUXR2^6;
   95       =2     sbit    RAMEXE      =           AUXR2^5;
   96       =2     sbit    CANFD       =           AUXR2^4;
   97       =2     sbit    CANSEL      =           AUXR2^3;
   98       =2     sbit    CAN2EN      =           AUXR2^2;
   99       =2     sbit    CANEN       =           AUXR2^1;
  100       =2     sbit    LINEN       =           AUXR2^0;
  101       =2 
  102       =2 sfr         SCON        =           0x98;
  103       =2     sbit    SM0         =           SCON^7;
  104       =2     sbit    SM1         =           SCON^6;
  105       =2     sbit    SM2         =           SCON^5;
  106       =2     sbit    REN         =           SCON^4;
  107       =2     sbit    TB8         =           SCON^3;
  108       =2     sbit    RB8         =           SCON^2;
  109       =2     sbit    TI          =           SCON^1;
  110       =2     sbit    RI          =           SCON^0;
  111       =2 
  112       =2 sfr         SBUF        =           0x99;
  113       =2 
  114       =2 sfr         S2CON       =           0x9a;
  115       =2     sbit    S2SM0       =           S2CON^7;
  116       =2     sbit    S2SM1       =           S2CON^6;
  117       =2     sbit    S2SM2       =           S2CON^5;
  118       =2     sbit    S2REN       =           S2CON^4;
  119       =2     sbit    S2TB8       =           S2CON^3;
  120       =2     sbit    S2RB8       =           S2CON^2;
  121       =2     sbit    S2TI        =           S2CON^1;
  122       =2     sbit    S2RI        =           S2CON^0;
  123       =2 
  124       =2 sfr         S2BUF       =           0x9b;
  125       =2 
  126       =2 sfr         IRCBAND     =           0x9d;
  127       =2     sbit    USBCKS      =           IRCBAND^7;
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 4   

  128       =2     sbit    USBCKS2     =           IRCBAND^6;
  129       =2     sbit    HIRCSEL1    =           IRCBAND^1;
  130       =2     sbit    HIRCSEL0    =           IRCBAND^0;
  131       =2 
  132       =2 sfr         LIRTRIM     =           0x9e;
  133       =2 sfr         IRTRIM      =           0x9f;
  134       =2 
  135       =2 sfr         P2          =           0xa0;
  136       =2     sbit    P20         =           P2^0;
  137       =2     sbit    P21         =           P2^1;
  138       =2     sbit    P22         =           P2^2;
  139       =2     sbit    P23         =           P2^3;
  140       =2     sbit    P24         =           P2^4;
  141       =2     sbit    P25         =           P2^5;
  142       =2     sbit    P26         =           P2^6;
  143       =2     sbit    P27         =           P2^7;
  144       =2 
  145       =2 sfr         BUS_SPEED   =           0xa1;
  146       =2 
  147       =2 sfr         P_SW1       =           0xa2;
  148       =2     sbit    S1_S1       =           P_SW1^7;
  149       =2     sbit    S1_S0       =           P_SW1^6;
  150       =2     sbit    CAN_S1      =           P_SW1^5;
  151       =2     sbit    CAN_S0      =           P_SW1^4;
  152       =2     sbit    SPI_S1      =           P_SW1^3;
  153       =2     sbit    SPI_S0      =           P_SW1^2;
  154       =2     sbit    LIN_S1      =           P_SW1^1;
  155       =2     sbit    LIN_S0      =           P_SW1^0;
  156       =2 
  157       =2 sfr         VRTRIM      =           0xa6;
  158       =2 
  159       =2 sfr         IE          =           0xa8;
  160       =2     sbit    EA          =           IE^7;
  161       =2     sbit    ELVD        =           IE^6;
  162       =2     sbit    EADC        =           IE^5;
  163       =2     sbit    ES          =           IE^4;
  164       =2     sbit    ET1         =           IE^3;
  165       =2     sbit    EX1         =           IE^2;
  166       =2     sbit    ET0         =           IE^1;
  167       =2     sbit    EX0         =           IE^0;
  168       =2 
  169       =2 sfr         SADDR       =           0xa9;
  170       =2 sfr         WKTCL       =           0xaa;
  171       =2 sfr         WKTCH       =           0xab;
  172       =2     sbit    WKTEN       =           WKTCH^7;
  173       =2 
  174       =2 sfr         S3CON       =           0xac;
  175       =2     sbit    S3SM0       =           S3CON^7;
  176       =2     sbit    S3ST3       =           S3CON^6;
  177       =2     sbit    S3SM2       =           S3CON^5;
  178       =2     sbit    S3REN       =           S3CON^4;
  179       =2     sbit    S3TB8       =           S3CON^3;
  180       =2     sbit    S3RB8       =           S3CON^2;
  181       =2     sbit    S3TI        =           S3CON^1;
  182       =2     sbit    S3RI        =           S3CON^0;
  183       =2 
  184       =2 sfr         S3BUF       =           0xad;
  185       =2 sfr         TA          =           0xae;
  186       =2 
  187       =2 sfr         IE2         =           0xaf;
  188       =2     sbit    EUSB        =           IE2^7;
  189       =2     sbit    ET4         =           IE2^6;
  190       =2     sbit    ET3         =           IE2^5;
  191       =2     sbit    ES4         =           IE2^4;
  192       =2     sbit    ES3         =           IE2^3;
  193       =2     sbit    ET2         =           IE2^2;
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 5   

  194       =2     sbit    ESPI        =           IE2^1;
  195       =2     sbit    ES2         =           IE2^0;
  196       =2 
  197       =2 sfr         P3          =           0xb0;
  198       =2     sbit    P30         =           P3^0;
  199       =2     sbit    P31         =           P3^1;
  200       =2     sbit    P32         =           P3^2;
  201       =2     sbit    P33         =           P3^3;
  202       =2     sbit    P34         =           P3^4;
  203       =2     sbit    P35         =           P3^5;
  204       =2     sbit    P36         =           P3^6;
  205       =2     sbit    P37         =           P3^7;
  206       =2 
  207       =2     sbit    RD          =           P3^7;
  208       =2     sbit    WR          =           P3^6;
  209       =2     sbit    T1          =           P3^5;
  210       =2     sbit    T0          =           P3^4;
  211       =2     sbit    INT1        =           P3^3;
  212       =2     sbit    INT0        =           P3^2;
  213       =2     sbit    TXD         =           P3^1;
  214       =2     sbit    RXD         =           P3^0;
  215       =2 
  216       =2 sfr         P3M1        =           0xb1;
  217       =2 sfr         P3M0        =           0xb2;
  218       =2 sfr         P4M1        =           0xb3;
  219       =2 sfr         P4M0        =           0xb4;
  220       =2 
  221       =2 sfr         IP2         =           0xb5;
  222       =2     sbit    PUSB        =           IP2^7;
  223       =2     sbit    PI2C        =           IP2^6;
  224       =2     sbit    PCMP        =           IP2^5;
  225       =2     sbit    PX4         =           IP2^4;
  226       =2     sbit    PPWMB       =           IP2^3;
  227       =2     sbit    PPWMA       =           IP2^2;
  228       =2     sbit    PSPI        =           IP2^1;
  229       =2     sbit    PS2         =           IP2^0;
  230       =2 
  231       =2 sfr         IP2H        =           0xb6;
  232       =2     sbit    PUSBH       =           IP2H^7;
  233       =2     sbit    PI2CH       =           IP2H^6;
  234       =2     sbit    PCMPH       =           IP2H^5;
  235       =2     sbit    PX4H        =           IP2H^4;
  236       =2     sbit    PPWMBH      =           IP2H^3;
  237       =2     sbit    PPWMAH      =           IP2H^2;
  238       =2     sbit    PSPIH       =           IP2H^1;
  239       =2     sbit    PS2H        =           IP2H^0;
  240       =2 
  241       =2 sfr         IPH         =           0xb7;
  242       =2     sbit    PPCAH       =           IPH^7;
  243       =2     sbit    PLVDH       =           IPH^6;
  244       =2     sbit    PADCH       =           IPH^5;
  245       =2     sbit    PSH         =           IPH^4;
  246       =2     sbit    PT1H        =           IPH^3;
  247       =2     sbit    PX1H        =           IPH^2;
  248       =2     sbit    PT0H        =           IPH^1;
  249       =2     sbit    PX0H        =           IPH^0;
  250       =2 
  251       =2 sfr         IP          =           0xb8;
  252       =2     sbit    PPCA        =           IP^7;
  253       =2     sbit    PLVD        =           IP^6;
  254       =2     sbit    PADC        =           IP^5;
  255       =2     sbit    PS          =           IP^4;
  256       =2     sbit    PT1         =           IP^3;
  257       =2     sbit    PX1         =           IP^2;
  258       =2     sbit    PT0         =           IP^1;
  259       =2     sbit    PX0         =           IP^0;
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 6   

  260       =2 
  261       =2 sfr         SADEN       =           0xb9;
  262       =2 
  263       =2 sfr         P_SW2       =           0xba;
  264       =2     sbit    EAXFR       =           P_SW2^7;
  265       =2     sbit    I2C_S1      =           P_SW2^5;
  266       =2     sbit    I2C_S0      =           P_SW2^4;
  267       =2     sbit    CMPO_S      =           P_SW2^3;
  268       =2     sbit    S4_S        =           P_SW2^2;
  269       =2     sbit    S3_S        =           P_SW2^1;
  270       =2     sbit    S2_S        =           P_SW2^0;
  271       =2 
  272       =2 sfr         P_SW3       =           0xbb;
  273       =2     sbit    I2S_S1      =           P_SW3^7;
  274       =2     sbit    I2S_S0      =           P_SW3^6;
  275       =2     sbit    S2SPI_S1    =           P_SW3^5;
  276       =2     sbit    S2SPI_S0    =           P_SW3^4;
  277       =2     sbit    S1SPI_S1    =           P_SW3^3;
  278       =2     sbit    S1SPI_S0    =           P_SW3^2;
  279       =2     sbit    CAN2_S1     =           P_SW3^1;
  280       =2     sbit    CAN2_S0     =           P_SW3^0;
  281       =2 
  282       =2 sfr         ADC_CONTR   =           0xbc;
  283       =2     sbit    ADC_POWER   =           ADC_CONTR^7;
  284       =2     sbit    ADC_START   =           ADC_CONTR^6;
  285       =2     sbit    ADC_FLAG    =           ADC_CONTR^5;
  286       =2     sbit    ADC_EPWMT   =           ADC_CONTR^4;
  287       =2 
  288       =2 sfr         ADC_RES     =           0xbd;
  289       =2 sfr         ADC_RESL    =           0xbe;
  290       =2 
  291       =2 sfr         P_SW4       =           0xbf;
  292       =2     sbit    QSPI_S1     =           P_SW4^1;
  293       =2     sbit    QSPI_S0     =           P_SW4^0;
  294       =2 
  295       =2 sfr         P4          =           0xc0;
  296       =2     sbit    P40         =           P4^0;
  297       =2     sbit    P41         =           P4^1;
  298       =2     sbit    P42         =           P4^2;
  299       =2     sbit    P43         =           P4^3;
  300       =2     sbit    P44         =           P4^4;
  301       =2     sbit    P45         =           P4^5;
  302       =2     sbit    P46         =           P4^6;
  303       =2     sbit    P47         =           P4^7;
  304       =2 
  305       =2 sfr         WDT_CONTR   =           0xc1;
  306       =2     sbit    WDT_FLAG    =           WDT_CONTR^7;
  307       =2     sbit    EN_WDT      =           WDT_CONTR^5;
  308       =2     sbit    CLR_WDT     =           WDT_CONTR^4;
  309       =2     sbit    IDL_WDT     =           WDT_CONTR^3;
  310       =2 
  311       =2 sfr         IAP_DATA    =           0xc2;
  312       =2 sfr         IAP_ADDRH   =           0xc3;
  313       =2 sfr         IAP_ADDRL   =           0xc4;
  314       =2 sfr         IAP_CMD     =           0xc5;
  315       =2 sfr         IAP_TRIG    =           0xc6;
  316       =2 
  317       =2 sfr         IAP_CONTR   =           0xc7;
  318       =2     sbit    IAPEN       =           IAP_CONTR^7;
  319       =2     sbit    SWBS        =           IAP_CONTR^6;
  320       =2     sbit    SWRST       =           IAP_CONTR^5;
  321       =2     sbit    CMD_FAIL    =           IAP_CONTR^4;
  322       =2     sbit    SWBS2       =           IAP_CONTR^3;
  323       =2 
  324       =2 sfr         P5          =           0xc8;
  325       =2     sbit    P50         =           P5^0;
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 7   

  326       =2     sbit    P51         =           P5^1;
  327       =2     sbit    P52         =           P5^2;
  328       =2     sbit    P53         =           P5^3;
  329       =2     sbit    P54         =           P5^4;
  330       =2     sbit    P55         =           P5^5;
  331       =2     sbit    P56         =           P5^6;
  332       =2     sbit    P57         =           P5^7;
  333       =2 
  334       =2 sfr         P5M1        =           0xc9;
  335       =2 sfr         P5M0        =           0xca;
  336       =2 sfr         P6M1        =           0xcb;
  337       =2 sfr         P6M0        =           0xcc;
  338       =2 
  339       =2 sfr         SPSTAT      =           0xcd;
  340       =2     sbit    SPIF        =           SPSTAT^7;
  341       =2     sbit    WCOL        =           SPSTAT^6;
  342       =2 
  343       =2 sfr         SPCTL       =           0xce;
  344       =2     sbit    SSIG        =           SPCTL^7;
  345       =2     sbit    SPEN        =           SPCTL^6;
  346       =2     sbit    DORD        =           SPCTL^5;
  347       =2     sbit    MSTR        =           SPCTL^4;
  348       =2     sbit    CPOL        =           SPCTL^3;
  349       =2     sbit    CPHA        =           SPCTL^2;
  350       =2     sbit    SPR1        =           SPCTL^1;
  351       =2     sbit    SPR0        =           SPCTL^0;
  352       =2 
  353       =2 sfr         SPDAT       =           0xcf;
  354       =2 
  355       =2 sfr         PSW         =           0xd0;
  356       =2     sbit    CY          =           PSW^7;
  357       =2     sbit    AC          =           PSW^6;
  358       =2     sbit    F0          =           PSW^5;
  359       =2     sbit    RS1         =           PSW^4;
  360       =2     sbit    RS0         =           PSW^3;
  361       =2     sbit    OV          =           PSW^2;
  362       =2     sbit    F1          =           PSW^1;
  363       =2     sbit    P           =           PSW^0;
  364       =2 
  365       =2 sfr         PSW1        =           0xd1;
  366       =2     sbit    N           =           PSW1^5;
  367       =2     sbit    Z           =           PSW1^1;
  368       =2 
  369       =2 sfr         T4H         =           0xd2;
  370       =2 sfr         T4L         =           0xd3;
  371       =2 sfr         T3H         =           0xd4;
  372       =2 sfr         T3L         =           0xd5;
  373       =2 sfr         T2H         =           0xd6;
  374       =2 sfr         T2L         =           0xd7;
  375       =2 
  376       =2 sfr         USBCLK      =           0xdc;
  377       =2 
  378       =2 sfr         T4T3M       =           0xdd;
  379       =2     sbit    T4R         =           T4T3M^7;
  380       =2     sbit    T4_CT       =           T4T3M^6;
  381       =2     sbit    T4x12       =           T4T3M^5;
  382       =2     sbit    T4CLKO      =           T4T3M^4;
  383       =2     sbit    T3R         =           T4T3M^3;
  384       =2     sbit    T3_CT       =           T4T3M^2;
  385       =2     sbit    T3x12       =           T4T3M^1;
  386       =2     sbit    T3CLKO      =           T4T3M^0;
  387       =2 
  388       =2 sfr         ADCCFG      =           0xde;
  389       =2     sbit    RESFMT      =           ADCCFG^5;
  390       =2 
  391       =2 sfr         IP3         =           0xdf;
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 8   

  392       =2     sbit    PI2S        =           IP3^3;
  393       =2     sbit    PRTC        =           IP3^2;
  394       =2     sbit    PS4         =           IP3^1;
  395       =2     sbit    PS3         =           IP3^0;
  396       =2 
  397       =2 sfr         ACC         =           0xe0;
  398       =2 sfr         P7M1        =           0xe1;
  399       =2 sfr         P7M0        =           0xe2;
  400       =2 sfr         DPS         =           0xe3;
  401       =2 
  402       =2 sfr         CMPCR1      =           0xe6;
  403       =2     sbit    CMPEN       =           CMPCR1^7;
  404       =2     sbit    CMPIF       =           CMPCR1^6;
  405       =2     sbit    PIE         =           CMPCR1^5;
  406       =2     sbit    NIE         =           CMPCR1^4;
  407       =2     sbit    CMPOE       =           CMPCR1^1;
  408       =2     sbit    CMPRES      =           CMPCR1^0;
  409       =2 
  410       =2 sfr         CMPCR2      =           0xe7;
  411       =2     sbit    INVCMPO     =           CMPCR2^7;
  412       =2     sbit    DISFLT      =           CMPCR2^6;
  413       =2 
  414       =2 sfr         P6          =           0xe8;
  415       =2     sbit    P60         =           P6^0;
  416       =2     sbit    P61         =           P6^1;
  417       =2     sbit    P62         =           P6^2;
  418       =2     sbit    P63         =           P6^3;
  419       =2     sbit    P64         =           P6^4;
  420       =2     sbit    P65         =           P6^5;
  421       =2     sbit    P66         =           P6^6;
  422       =2     sbit    P67         =           P6^7;
  423       =2 
  424       =2 sfr         WTST        =           0xe9;
  425       =2 sfr         CKCON       =           0xea;
  426       =2 sfr         MXAX        =           0xeb;
  427       =2 sfr         USBDAT      =           0xec;
  428       =2 sfr         DMAIR       =           0xed;
  429       =2 
  430       =2 sfr         IP3H        =           0xee;
  431       =2     sbit    PI2SH       =           IP3H^3;
  432       =2     sbit    PRTCH       =           IP3H^2;
  433       =2     sbit    PS4H        =           IP3H^1;
  434       =2     sbit    PS3H        =           IP3H^0;
  435       =2 
  436       =2 sfr         AUXINTIF    =           0xef;
  437       =2     sbit    INT4IF      =           AUXINTIF^6;
  438       =2     sbit    INT3IF      =           AUXINTIF^5;
  439       =2     sbit    INT2IF      =           AUXINTIF^4;
  440       =2     sbit    T4IF        =           AUXINTIF^2;
  441       =2     sbit    T3IF        =           AUXINTIF^1;
  442       =2     sbit    T2IF        =           AUXINTIF^0;
  443       =2 
  444       =2 sfr         B           =           0xf0;
  445       =2 
  446       =2 sfr         USBCON      =           0xf4;
  447       =2     sbit    ENUSB       =           USBCON^7;
  448       =2     sbit    ENUSBRST    =           USBCON^6;
  449       =2     sbit    PS2M        =           USBCON^5;
  450       =2     sbit    PUEN        =           USBCON^4;
  451       =2     sbit    PDEN        =           USBCON^3;
  452       =2     sbit    DFREC       =           USBCON^2;
  453       =2     sbit    DP          =           USBCON^1;
  454       =2     sbit    DM          =           USBCON^0;
  455       =2 
  456       =2 sfr         IAP_TPS     =           0xf5;
  457       =2 sfr         IAP_ADDRE   =           0xf6;
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 9   

  458       =2 
  459       =2 sfr         P7          =           0xf8;
  460       =2     sbit    P70         =           P7^0;
  461       =2     sbit    P71         =           P7^1;
  462       =2     sbit    P72         =           P7^2;
  463       =2     sbit    P73         =           P7^3;
  464       =2     sbit    P74         =           P7^4;
  465       =2     sbit    P75         =           P7^5;
  466       =2     sbit    P76         =           P7^6;
  467       =2     sbit    P77         =           P7^7;
  468       =2 
  469       =2 sfr         USBADR      =           0xfc;
  470       =2 
  471       =2 sfr         S4CON       =           0xfd;
  472       =2     sbit    S4SM0       =           S4CON^7;
  473       =2     sbit    S4ST4       =           S4CON^6;
  474       =2     sbit    S4SM2       =           S4CON^5;
  475       =2     sbit    S4REN       =           S4CON^4;
  476       =2     sbit    S4TB8       =           S4CON^3;
  477       =2     sbit    S4RB8       =           S4CON^2;
  478       =2     sbit    S4TI        =           S4CON^1;
  479       =2     sbit    S4RI        =           S4CON^0;
  480       =2 
  481       =2 sfr         S4BUF       =           0xfe;
  482       =2 
  483       =2 sfr         RSTCFG      =           0xff;
  484       =2     sbit    ENLVR       =           RSTCFG^6;
  485       =2     sbit    P54RST      =           RSTCFG^4;
  486       =2 
  487       =2 /////////////////////////////////////////////////
  488       =2 //
  489       =2 //如下特殊功能寄存器位于扩展RAM区域
  490       =2 //访问这些寄存器,需先将EAXFR设置为1,才可正常读写
  491       =2 //    EAXFR = 1;
  492       =2 //或者
  493       =2 //    P_SW2 |= 0x80;
  494       =2 ///////////////////////////////////////////////////
  495       =2 
  496       =2 /////////////////////////////////////////////////
  497       =2 //7E:FF00H-7E:FFFFH
  498       =2 /////////////////////////////////////////////////
  499       =2 
  500       =2 
  501       =2 
  502       =2 /////////////////////////////////////////////////
  503       =2 //7E:FE00H-7E:FEFFH
  504       =2 /////////////////////////////////////////////////
  505       =2 
  506       =2 #define     CLKSEL                  (*(unsigned char volatile far *)0x7efe00)
  507       =2 #define     CLKDIV                  (*(unsigned char volatile far *)0x7efe01)
  508       =2 #define     HIRCCR                  (*(unsigned char volatile far *)0x7efe02)
  509       =2 #define     XOSCCR                  (*(unsigned char volatile far *)0x7efe03)
  510       =2 #define     IRC32KCR                (*(unsigned char volatile far *)0x7efe04)
  511       =2 #define     MCLKOCR                 (*(unsigned char volatile far *)0x7efe05)
  512       =2 #define     IRCDB                   (*(unsigned char volatile far *)0x7efe06)
  513       =2 #define     IRC48MCR                (*(unsigned char volatile far *)0x7efe07)
  514       =2 #define     X32KCR                  (*(unsigned char volatile far *)0x7efe08)
  515       =2 #define     HSCLKDIV                (*(unsigned char volatile far *)0x7efe0b)
  516       =2 
  517       =2 #define     P0PU                    (*(unsigned char volatile far *)0x7efe10)
  518       =2 #define     P1PU                    (*(unsigned char volatile far *)0x7efe11)
  519       =2 #define     P2PU                    (*(unsigned char volatile far *)0x7efe12)
  520       =2 #define     P3PU                    (*(unsigned char volatile far *)0x7efe13)
  521       =2 #define     P4PU                    (*(unsigned char volatile far *)0x7efe14)
  522       =2 #define     P5PU                    (*(unsigned char volatile far *)0x7efe15)
  523       =2 #define     P6PU                    (*(unsigned char volatile far *)0x7efe16)
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 10  

  524       =2 #define     P7PU                    (*(unsigned char volatile far *)0x7efe17)
  525       =2 #define     P0NCS                   (*(unsigned char volatile far *)0x7efe18)
  526       =2 #define     P1NCS                   (*(unsigned char volatile far *)0x7efe19)
  527       =2 #define     P2NCS                   (*(unsigned char volatile far *)0x7efe1a)
  528       =2 #define     P3NCS                   (*(unsigned char volatile far *)0x7efe1b)
  529       =2 #define     P4NCS                   (*(unsigned char volatile far *)0x7efe1c)
  530       =2 #define     P5NCS                   (*(unsigned char volatile far *)0x7efe1d)
  531       =2 #define     P6NCS                   (*(unsigned char volatile far *)0x7efe1e)
  532       =2 #define     P7NCS                   (*(unsigned char volatile far *)0x7efe1f)
  533       =2 #define     P0SR                    (*(unsigned char volatile far *)0x7efe20)
  534       =2 #define     P1SR                    (*(unsigned char volatile far *)0x7efe21)
  535       =2 #define     P2SR                    (*(unsigned char volatile far *)0x7efe22)
  536       =2 #define     P3SR                    (*(unsigned char volatile far *)0x7efe23)
  537       =2 #define     P4SR                    (*(unsigned char volatile far *)0x7efe24)
  538       =2 #define     P5SR                    (*(unsigned char volatile far *)0x7efe25)
  539       =2 #define     P6SR                    (*(unsigned char volatile far *)0x7efe26)
  540       =2 #define     P7SR                    (*(unsigned char volatile far *)0x7efe27)
  541       =2 #define     P0DR                    (*(unsigned char volatile far *)0x7efe28)
  542       =2 #define     P1DR                    (*(unsigned char volatile far *)0x7efe29)
  543       =2 #define     P2DR                    (*(unsigned char volatile far *)0x7efe2a)
  544       =2 #define     P3DR                    (*(unsigned char volatile far *)0x7efe2b)
  545       =2 #define     P4DR                    (*(unsigned char volatile far *)0x7efe2c)
  546       =2 #define     P5DR                    (*(unsigned char volatile far *)0x7efe2d)
  547       =2 #define     P6DR                    (*(unsigned char volatile far *)0x7efe2e)
  548       =2 #define     P7DR                    (*(unsigned char volatile far *)0x7efe2f)
  549       =2 #define     P0IE                    (*(unsigned char volatile far *)0x7efe30)
  550       =2 #define     P1IE                    (*(unsigned char volatile far *)0x7efe31)
  551       =2 #define     P2IE                    (*(unsigned char volatile far *)0x7efe32)
  552       =2 #define     P3IE                    (*(unsigned char volatile far *)0x7efe33)
  553       =2 #define     P4IE                    (*(unsigned char volatile far *)0x7efe34)
  554       =2 #define     P5IE                    (*(unsigned char volatile far *)0x7efe35)
  555       =2 #define     P6IE                    (*(unsigned char volatile far *)0x7efe36)
  556       =2 #define     P7IE                    (*(unsigned char volatile far *)0x7efe37)
  557       =2 #define     P0PD                    (*(unsigned char volatile far *)0x7efe40)
  558       =2 #define     P1PD                    (*(unsigned char volatile far *)0x7efe41)
  559       =2 #define     P2PD                    (*(unsigned char volatile far *)0x7efe42)
  560       =2 #define     P3PD                    (*(unsigned char volatile far *)0x7efe43)
  561       =2 #define     P4PD                    (*(unsigned char volatile far *)0x7efe44)
  562       =2 #define     P5PD                    (*(unsigned char volatile far *)0x7efe45)
  563       =2 #define     P6PD                    (*(unsigned char volatile far *)0x7efe46)
  564       =2 #define     P7PD                    (*(unsigned char volatile far *)0x7efe47)
  565       =2 #define     P0BP                    (*(unsigned char volatile far *)0x7efe48)
  566       =2 #define     P1BP                    (*(unsigned char volatile far *)0x7efe49)
  567       =2 #define     P2BP                    (*(unsigned char volatile far *)0x7efe4a)
  568       =2 #define     P3BP                    (*(unsigned char volatile far *)0x7efe4b)
  569       =2 #define     P4BP                    (*(unsigned char volatile far *)0x7efe4c)
  570       =2 #define     P5BP                    (*(unsigned char volatile far *)0x7efe4d)
  571       =2 #define     P6BP                    (*(unsigned char volatile far *)0x7efe4e)
  572       =2 #define     P7BP                    (*(unsigned char volatile far *)0x7efe4f)
  573       =2 
  574       =2 #define     LCMIFCFG                (*(unsigned char volatile far *)0x7efe50)
  575       =2 #define     LCMIFCFG2               (*(unsigned char volatile far *)0x7efe51)
  576       =2 #define     LCMIFCR                 (*(unsigned char volatile far *)0x7efe52)
  577       =2 #define     LCMIFSTA                (*(unsigned char volatile far *)0x7efe53)
  578       =2 #define     LCMIFDATL               (*(unsigned char volatile far *)0x7efe54)
  579       =2 #define     LCMIFDATH               (*(unsigned char volatile far *)0x7efe55)
  580       =2 #define     LCMIFPSCR               (*(unsigned char volatile far *)0x7efe56)
  581       =2 
  582       =2 #define     RTCCR                   (*(unsigned char volatile far *)0x7efe60)
  583       =2 #define     RTCCFG                  (*(unsigned char volatile far *)0x7efe61)
  584       =2 #define     RTCIEN                  (*(unsigned char volatile far *)0x7efe62)
  585       =2 #define     RTCIF                   (*(unsigned char volatile far *)0x7efe63)
  586       =2 #define     ALAHOUR                 (*(unsigned char volatile far *)0x7efe64)
  587       =2 #define     ALAMIN                  (*(unsigned char volatile far *)0x7efe65)
  588       =2 #define     ALASEC                  (*(unsigned char volatile far *)0x7efe66)
  589       =2 #define     ALASSEC                 (*(unsigned char volatile far *)0x7efe67)
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 11  

  590       =2 #define     INIYEAR                 (*(unsigned char volatile far *)0x7efe68)
  591       =2 #define     INIMONTH                (*(unsigned char volatile far *)0x7efe69)
  592       =2 #define     INIDAY                  (*(unsigned char volatile far *)0x7efe6a)
  593       =2 #define     INIHOUR                 (*(unsigned char volatile far *)0x7efe6b)
  594       =2 #define     INIMIN                  (*(unsigned char volatile far *)0x7efe6c)
  595       =2 #define     INISEC                  (*(unsigned char volatile far *)0x7efe6d)
  596       =2 #define     INISSEC                 (*(unsigned char volatile far *)0x7efe6e)
  597       =2 #define     INIWEEK                 (*(unsigned char volatile far *)0x7efe6f)
  598       =2 #define     WEEK                    (*(unsigned char volatile far *)0x7efe6f)
  599       =2 #define     YEAR                    (*(unsigned char volatile far *)0x7efe70)
  600       =2 #define     MONTH                   (*(unsigned char volatile far *)0x7efe71)
  601       =2 #define     DAY                     (*(unsigned char volatile far *)0x7efe72)
  602       =2 #define     HOUR                    (*(unsigned char volatile far *)0x7efe73)
  603       =2 #define     MIN                     (*(unsigned char volatile far *)0x7efe74)
  604       =2 #define     SEC                     (*(unsigned char volatile far *)0x7efe75)
  605       =2 #define     SSEC                    (*(unsigned char volatile far *)0x7efe76)
  606       =2 
  607       =2 #define     T11CR                   (*(unsigned char volatile far *)0x7efe78)
  608       =2 #define     T11PS                   (*(unsigned char volatile far *)0x7efe79)
  609       =2 #define     T11H                    (*(unsigned char volatile far *)0x7efe7a)
  610       =2 #define     T11L                    (*(unsigned char volatile far *)0x7efe7b)
  611       =2 
  612       =2 #define     I2CCFG                  (*(unsigned char volatile far *)0x7efe80)
  613       =2 #define     I2CMSCR                 (*(unsigned char volatile far *)0x7efe81)
  614       =2 #define     I2CMSST                 (*(unsigned char volatile far *)0x7efe82)
  615       =2 #define     I2CSLCR                 (*(unsigned char volatile far *)0x7efe83)
  616       =2 #define     I2CSLST                 (*(unsigned char volatile far *)0x7efe84)
  617       =2 #define     I2CSLADR                (*(unsigned char volatile far *)0x7efe85)
  618       =2 #define     I2CTXD                  (*(unsigned char volatile far *)0x7efe86)
  619       =2 #define     I2CRXD                  (*(unsigned char volatile far *)0x7efe87)
  620       =2 #define     I2CMSAUX                (*(unsigned char volatile far *)0x7efe88)
  621       =2 #define     I2CPSCR                 (*(unsigned char volatile far *)0x7efe89)
  622       =2 
  623       =2 #define     SPI_CLKDIV              (*(unsigned char volatile far *)0x7efe90)
  624       =2 #define     PWMA_CLKDIV             (*(unsigned char volatile far *)0x7efe91)
  625       =2 #define     PWMB_CLKDIV             (*(unsigned char volatile far *)0x7efe92)
  626       =2 #define     TFPU_CLKDIV             (*(unsigned char volatile far *)0x7efe93)
  627       =2 #define     I2S_CLKDIV              (*(unsigned char volatile far *)0x7efe94)
  628       =2 
  629       =2 #define     RSTFLAG                 (*(unsigned char volatile far *)0x7efe99)
  630       =2 #define     RSTCR0                  (*(unsigned char volatile far *)0x7efe9a)
  631       =2 #define     RSTCR1                  (*(unsigned char volatile far *)0x7efe9b)
  632       =2 #define     RSTCR2                  (*(unsigned char volatile far *)0x7efe9c)
  633       =2 #define     RSTCR3                  (*(unsigned char volatile far *)0x7efe9d)
  634       =2 #define     RSTCR4                  (*(unsigned char volatile far *)0x7efe9e)
  635       =2 #define     RSTCR5                  (*(unsigned char volatile far *)0x7efe9f)
  636       =2 
  637       =2 #define     TM0PS                   (*(unsigned char volatile far *)0x7efea0)
  638       =2 #define     TM1PS                   (*(unsigned char volatile far *)0x7efea1)
  639       =2 #define     TM2PS                   (*(unsigned char volatile far *)0x7efea2)
  640       =2 #define     TM3PS                   (*(unsigned char volatile far *)0x7efea3)
  641       =2 #define     TM4PS                   (*(unsigned char volatile far *)0x7efea4)
  642       =2 #define     ADCTIM                  (*(unsigned char volatile far *)0x7efea8)
  643       =2 #define     ADCEXCFG                (*(unsigned char volatile far *)0x7efead)
  644       =2 #define     CMPEXCFG                (*(unsigned char volatile far *)0x7efeae)
  645       =2 
  646       =2 #define     PWMA_ETRPS              (*(unsigned char volatile far *)0x7efeb0)
  647       =2 #define     PWMA_ENO                (*(unsigned char volatile far *)0x7efeb1)
  648       =2 #define     PWMA_PS                 (*(unsigned char volatile far *)0x7efeb2)
  649       =2 #define     PWMA_IOAUX              (*(unsigned char volatile far *)0x7efeb3)
  650       =2 #define     PWMB_ETRPS              (*(unsigned char volatile far *)0x7efeb4)
  651       =2 #define     PWMB_ENO                (*(unsigned char volatile far *)0x7efeb5)
  652       =2 #define     PWMB_PS                 (*(unsigned char volatile far *)0x7efeb6)
  653       =2 #define     PWMB_IOAUX              (*(unsigned char volatile far *)0x7efeb7)
  654       =2 #define     PWMA_PS2                (*(unsigned char volatile far *)0x7efeb8)
  655       =2 #define     PWMA_RCRH               (*(unsigned char volatile far *)0x7efeb9)
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 12  

  656       =2 #define     PWMB_RCRH               (*(unsigned char volatile far *)0x7efeba)
  657       =2 
  658       =2 #define     PWMA_CR1                (*(unsigned char volatile far *)0x7efec0)
  659       =2 #define     PWMA_CR2                (*(unsigned char volatile far *)0x7efec1)
  660       =2 #define     PWMA_SMCR               (*(unsigned char volatile far *)0x7efec2)
  661       =2 #define     PWMA_ETR                (*(unsigned char volatile far *)0x7efec3)
  662       =2 #define     PWMA_IER                (*(unsigned char volatile far *)0x7efec4)
  663       =2 #define     PWMA_SR1                (*(unsigned char volatile far *)0x7efec5)
  664       =2 #define     PWMA_SR2                (*(unsigned char volatile far *)0x7efec6)
  665       =2 #define     PWMA_EGR                (*(unsigned char volatile far *)0x7efec7)
  666       =2 #define     PWMA_CCMR1              (*(unsigned char volatile far *)0x7efec8)
  667       =2 #define     PWMA_CCMR2              (*(unsigned char volatile far *)0x7efec9)
  668       =2 #define     PWMA_CCMR3              (*(unsigned char volatile far *)0x7efeca)
  669       =2 #define     PWMA_CCMR4              (*(unsigned char volatile far *)0x7efecb)
  670       =2 #define     PWMA_CCER1              (*(unsigned char volatile far *)0x7efecc)
  671       =2 #define     PWMA_CCER2              (*(unsigned char volatile far *)0x7efecd)
  672       =2 #define     PWMA_CNTRH              (*(unsigned char volatile far *)0x7efece)
  673       =2 #define     PWMA_CNTRL              (*(unsigned char volatile far *)0x7efecf)
  674       =2 #define     PWMA_PSCRH              (*(unsigned char volatile far *)0x7efed0)
  675       =2 #define     PWMA_PSCRL              (*(unsigned char volatile far *)0x7efed1)
  676       =2 #define     PWMA_ARRH               (*(unsigned char volatile far *)0x7efed2)
  677       =2 #define     PWMA_ARRL               (*(unsigned char volatile far *)0x7efed3)
  678       =2 #define     PWMA_RCR                (*(unsigned char volatile far *)0x7efed4)
  679       =2 #define     PWMA_CCR1H              (*(unsigned char volatile far *)0x7efed5)
  680       =2 #define     PWMA_CCR1L              (*(unsigned char volatile far *)0x7efed6)
  681       =2 #define     PWMA_CCR2H              (*(unsigned char volatile far *)0x7efed7)
  682       =2 #define     PWMA_CCR2L              (*(unsigned char volatile far *)0x7efed8)
  683       =2 #define     PWMA_CCR3H              (*(unsigned char volatile far *)0x7efed9)
  684       =2 #define     PWMA_CCR3L              (*(unsigned char volatile far *)0x7efeda)
  685       =2 #define     PWMA_CCR4H              (*(unsigned char volatile far *)0x7efedb)
  686       =2 #define     PWMA_CCR4L              (*(unsigned char volatile far *)0x7efedc)
  687       =2 #define     PWMA_BKR                (*(unsigned char volatile far *)0x7efedd)
  688       =2 #define     PWMA_DTR                (*(unsigned char volatile far *)0x7efede)
  689       =2 #define     PWMA_OISR               (*(unsigned char volatile far *)0x7efedf)
  690       =2 
  691       =2 #define     PWMB_CR1                (*(unsigned char volatile far *)0x7efee0)
  692       =2 #define     PWMB_CR2                (*(unsigned char volatile far *)0x7efee1)
  693       =2 #define     PWMB_SMCR               (*(unsigned char volatile far *)0x7efee2)
  694       =2 #define     PWMB_ETR                (*(unsigned char volatile far *)0x7efee3)
  695       =2 #define     PWMB_IER                (*(unsigned char volatile far *)0x7efee4)
  696       =2 #define     PWMB_SR1                (*(unsigned char volatile far *)0x7efee5)
  697       =2 #define     PWMB_SR2                (*(unsigned char volatile far *)0x7efee6)
  698       =2 #define     PWMB_EGR                (*(unsigned char volatile far *)0x7efee7)
  699       =2 #define     PWMB_CCMR1              (*(unsigned char volatile far *)0x7efee8)
  700       =2 #define     PWMB_CCMR2              (*(unsigned char volatile far *)0x7efee9)
  701       =2 #define     PWMB_CCMR3              (*(unsigned char volatile far *)0x7efeea)
  702       =2 #define     PWMB_CCMR4              (*(unsigned char volatile far *)0x7efeeb)
  703       =2 #define     PWMB_CCER1              (*(unsigned char volatile far *)0x7efeec)
  704       =2 #define     PWMB_CCER2              (*(unsigned char volatile far *)0x7efeed)
  705       =2 #define     PWMB_CNTRH              (*(unsigned char volatile far *)0x7efeee)
  706       =2 #define     PWMB_CNTRL              (*(unsigned char volatile far *)0x7efeef)
  707       =2 #define     PWMB_PSCRH              (*(unsigned char volatile far *)0x7efef0)
  708       =2 #define     PWMB_PSCRL              (*(unsigned char volatile far *)0x7efef1)
  709       =2 #define     PWMB_ARRH               (*(unsigned char volatile far *)0x7efef2)
  710       =2 #define     PWMB_ARRL               (*(unsigned char volatile far *)0x7efef3)
  711       =2 #define     PWMB_RCR                (*(unsigned char volatile far *)0x7efef4)
  712       =2 #define     PWMB_CCR5H              (*(unsigned char volatile far *)0x7efef5)
  713       =2 #define     PWMB_CCR5L              (*(unsigned char volatile far *)0x7efef6)
  714       =2 #define     PWMB_CCR6H              (*(unsigned char volatile far *)0x7efef7)
  715       =2 #define     PWMB_CCR6L              (*(unsigned char volatile far *)0x7efef8)
  716       =2 #define     PWMB_CCR7H              (*(unsigned char volatile far *)0x7efef9)
  717       =2 #define     PWMB_CCR7L              (*(unsigned char volatile far *)0x7efefa)
  718       =2 #define     PWMB_CCR8H              (*(unsigned char volatile far *)0x7efefb)
  719       =2 #define     PWMB_CCR8L              (*(unsigned char volatile far *)0x7efefc)
  720       =2 #define     PWMB_BKR                (*(unsigned char volatile far *)0x7efefd)
  721       =2 #define     PWMB_DTR                (*(unsigned char volatile far *)0x7efefe)
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 13  

  722       =2 #define     PWMB_OISR               (*(unsigned char volatile far *)0x7efeff)
  723       =2 
  724       =2 /////////////////////////////////////////////////
  725       =2 //7E:FD00H-7E:FDFFH
  726       =2 /////////////////////////////////////////////////
  727       =2 
  728       =2 #define     P0INTE                  (*(unsigned char volatile far *)0x7efd00)
  729       =2 #define     P1INTE                  (*(unsigned char volatile far *)0x7efd01)
  730       =2 #define     P2INTE                  (*(unsigned char volatile far *)0x7efd02)
  731       =2 #define     P3INTE                  (*(unsigned char volatile far *)0x7efd03)
  732       =2 #define     P4INTE                  (*(unsigned char volatile far *)0x7efd04)
  733       =2 #define     P5INTE                  (*(unsigned char volatile far *)0x7efd05)
  734       =2 #define     P6INTE                  (*(unsigned char volatile far *)0x7efd06)
  735       =2 #define     P7INTE                  (*(unsigned char volatile far *)0x7efd07)
  736       =2 #define     P0INTF                  (*(unsigned char volatile far *)0x7efd10)
  737       =2 #define     P1INTF                  (*(unsigned char volatile far *)0x7efd11)
  738       =2 #define     P2INTF                  (*(unsigned char volatile far *)0x7efd12)
  739       =2 #define     P3INTF                  (*(unsigned char volatile far *)0x7efd13)
  740       =2 #define     P4INTF                  (*(unsigned char volatile far *)0x7efd14)
  741       =2 #define     P5INTF                  (*(unsigned char volatile far *)0x7efd15)
  742       =2 #define     P6INTF                  (*(unsigned char volatile far *)0x7efd16)
  743       =2 #define     P7INTF                  (*(unsigned char volatile far *)0x7efd17)
  744       =2 #define     P0IM0                   (*(unsigned char volatile far *)0x7efd20)
  745       =2 #define     P1IM0                   (*(unsigned char volatile far *)0x7efd21)
  746       =2 #define     P2IM0                   (*(unsigned char volatile far *)0x7efd22)
  747       =2 #define     P3IM0                   (*(unsigned char volatile far *)0x7efd23)
  748       =2 #define     P4IM0                   (*(unsigned char volatile far *)0x7efd24)
  749       =2 #define     P5IM0                   (*(unsigned char volatile far *)0x7efd25)
  750       =2 #define     P6IM0                   (*(unsigned char volatile far *)0x7efd26)
  751       =2 #define     P7IM0                   (*(unsigned char volatile far *)0x7efd27)
  752       =2 #define     P0IM1                   (*(unsigned char volatile far *)0x7efd30)
  753       =2 #define     P1IM1                   (*(unsigned char volatile far *)0x7efd31)
  754       =2 #define     P2IM1                   (*(unsigned char volatile far *)0x7efd32)
  755       =2 #define     P3IM1                   (*(unsigned char volatile far *)0x7efd33)
  756       =2 #define     P4IM1                   (*(unsigned char volatile far *)0x7efd34)
  757       =2 #define     P5IM1                   (*(unsigned char volatile far *)0x7efd35)
  758       =2 #define     P6IM1                   (*(unsigned char volatile far *)0x7efd36)
  759       =2 #define     P7IM1                   (*(unsigned char volatile far *)0x7efd37)
  760       =2 #define     P0WKUE                  (*(unsigned char volatile far *)0x7efd40)
  761       =2 #define     P1WKUE                  (*(unsigned char volatile far *)0x7efd41)
  762       =2 #define     P2WKUE                  (*(unsigned char volatile far *)0x7efd42)
  763       =2 #define     P3WKUE                  (*(unsigned char volatile far *)0x7efd43)
  764       =2 #define     P4WKUE                  (*(unsigned char volatile far *)0x7efd44)
  765       =2 #define     P5WKUE                  (*(unsigned char volatile far *)0x7efd45)
  766       =2 #define     P6WKUE                  (*(unsigned char volatile far *)0x7efd46)
  767       =2 #define     P7WKUE                  (*(unsigned char volatile far *)0x7efd47)
  768       =2 
  769       =2 #define     CCAPM2                  (*(unsigned char volatile far *)0x7efd50)
  770       =2 #define     CCAP2L                  (*(unsigned char volatile far *)0x7efd51)
  771       =2 #define     CCAP2H                  (*(unsigned char volatile far *)0x7efd52)
  772       =2 #define     PCA_PWM2                (*(unsigned char volatile far *)0x7efd53)
  773       =2 #define     CCAPM3                  (*(unsigned char volatile far *)0x7efd54)
  774       =2 #define     CCAP3L                  (*(unsigned char volatile far *)0x7efd55)
  775       =2 #define     CCAP3H                  (*(unsigned char volatile far *)0x7efd56)
  776       =2 #define     PCA_PWM3                (*(unsigned char volatile far *)0x7efd57)
  777       =2 #define     CCAPM0                  (*(unsigned char volatile far *)0x7efd58)
  778       =2 #define     CCAP0L                  (*(unsigned char volatile far *)0x7efd59)
  779       =2 #define     CCAP0H                  (*(unsigned char volatile far *)0x7efd5a)
  780       =2 #define     PCA_PWM0                (*(unsigned char volatile far *)0x7efd5b)
  781       =2 #define     CCAPM1                  (*(unsigned char volatile far *)0x7efd5c)
  782       =2 #define     CCAP1L                  (*(unsigned char volatile far *)0x7efd5d)
  783       =2 #define     CCAP1H                  (*(unsigned char volatile far *)0x7efd5e)
  784       =2 #define     PCA_PWM1                (*(unsigned char volatile far *)0x7efd5f)
  785       =2 
  786       =2 #define     PINIPL                  (*(unsigned char volatile far *)0x7efd60)
  787       =2 #define     PINIPH                  (*(unsigned char volatile far *)0x7efd61)
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 14  

  788       =2 
  789       =2 #define     CCON                    (*(unsigned char volatile far *)0x7efd64)
  790       =2 #define     CL                      (*(unsigned char volatile far *)0x7efd65)
  791       =2 #define     CH                      (*(unsigned char volatile far *)0x7efd66)
  792       =2 #define     CMOD                    (*(unsigned char volatile far *)0x7efd67)
  793       =2 
  794       =2 #define     UR1TOCR                 (*(unsigned char volatile far *)0x7efd70)
  795       =2 #define     UR1TOSR                 (*(unsigned char volatile far *)0x7efd71)
  796       =2 #define     UR1TOTH                 (*(unsigned char volatile far *)0x7efd72)
  797       =2 #define     UR1TOTL                 (*(unsigned char volatile far *)0x7efd73)
  798       =2 #define     UR2TOCR                 (*(unsigned char volatile far *)0x7efd74)
  799       =2 #define     UR2TOSR                 (*(unsigned char volatile far *)0x7efd75)
  800       =2 #define     UR2TOTH                 (*(unsigned char volatile far *)0x7efd76)
  801       =2 #define     UR2TOTL                 (*(unsigned char volatile far *)0x7efd77)
  802       =2 #define     UR3TOCR                 (*(unsigned char volatile far *)0x7efd78)
  803       =2 #define     UR3TOSR                 (*(unsigned char volatile far *)0x7efd79)
  804       =2 #define     UR3TOTH                 (*(unsigned char volatile far *)0x7efd7a)
  805       =2 #define     UR3TOTL                 (*(unsigned char volatile far *)0x7efd7b)
  806       =2 #define     UR4TOCR                 (*(unsigned char volatile far *)0x7efd7c)
  807       =2 #define     UR4TOSR                 (*(unsigned char volatile far *)0x7efd7d)
  808       =2 #define     UR4TOTH                 (*(unsigned char volatile far *)0x7efd7e)
  809       =2 #define     UR4TOTL                 (*(unsigned char volatile far *)0x7efd7f)
  810       =2 #define     SPITOCR                 (*(unsigned char volatile far *)0x7efd80)
  811       =2 #define     SPITOSR                 (*(unsigned char volatile far *)0x7efd81)
  812       =2 #define     SPITOTH                 (*(unsigned char volatile far *)0x7efd82)
  813       =2 #define     SPITOTL                 (*(unsigned char volatile far *)0x7efd83)
  814       =2 #define     I2CTOCR                 (*(unsigned char volatile far *)0x7efd84)
  815       =2 #define     I2CTOSR                 (*(unsigned char volatile far *)0x7efd85)
  816       =2 #define     I2CTOTH                 (*(unsigned char volatile far *)0x7efd86)
  817       =2 #define     I2CTOTL                 (*(unsigned char volatile far *)0x7efd87)
  818       =2 
  819       =2 #define     UR1TOTE                 (*(unsigned char volatile far *)0x7efd88)
  820       =2 #define     UR2TOTE                 (*(unsigned char volatile far *)0x7efd89)
  821       =2 #define     UR3TOTE                 (*(unsigned char volatile far *)0x7efd8a)
  822       =2 #define     UR4TOTE                 (*(unsigned char volatile far *)0x7efd8b)
  823       =2 #define     SPITOTE                 (*(unsigned char volatile far *)0x7efd8c)
  824       =2 #define     I2CTOTE                 (*(unsigned char volatile far *)0x7efd8d)
  825       =2 
  826       =2 #define     I2SCR                   (*(unsigned char volatile far *)0x7efd98)
  827       =2 #define     I2SSR                   (*(unsigned char volatile far *)0x7efd99)
  828       =2 #define     I2SDRH                  (*(unsigned char volatile far *)0x7efd9a)
  829       =2 #define     I2SDRL                  (*(unsigned char volatile far *)0x7efd9b)
  830       =2 #define     I2SPRH                  (*(unsigned char volatile far *)0x7efd9c)
  831       =2 #define     I2SPRL                  (*(unsigned char volatile far *)0x7efd9d)
  832       =2 #define     I2SCFGH                 (*(unsigned char volatile far *)0x7efd9e)
  833       =2 #define     I2SCFGL                 (*(unsigned char volatile far *)0x7efd9f)
  834       =2 #define     I2SMD                   (*(unsigned char volatile far *)0x7efda0)
  835       =2 #define     I2SMCKDIV               (*(unsigned char volatile far *)0x7efda1)
  836       =2 
  837       =2 #define     CRECR                   (*(unsigned char volatile far *)0x7efda8)
  838       =2 #define     CRECNTH                 (*(unsigned char volatile far *)0x7efda9)
  839       =2 #define     CRECNTL                 (*(unsigned char volatile far *)0x7efdaa)
  840       =2 #define     CRERES                  (*(unsigned char volatile far *)0x7efdab)
  841       =2 
  842       =2 #define     S2CFG                   (*(unsigned char volatile far *)0x7efdb4)
  843       =2 #define     S2ADDR                  (*(unsigned char volatile far *)0x7efdb5)
  844       =2 #define     S2ADEN                  (*(unsigned char volatile far *)0x7efdb6)
  845       =2 #define     USARTCR1                (*(unsigned char volatile far *)0x7efdc0)
  846       =2 #define     USARTCR2                (*(unsigned char volatile far *)0x7efdc1)
  847       =2 #define     USARTCR3                (*(unsigned char volatile far *)0x7efdc2)
  848       =2 #define     USARTCR4                (*(unsigned char volatile far *)0x7efdc3)
  849       =2 #define     USARTCR5                (*(unsigned char volatile far *)0x7efdc4)
  850       =2 #define     USARTGTR                (*(unsigned char volatile far *)0x7efdc5)
  851       =2 #define     USARTBRH                (*(unsigned char volatile far *)0x7efdc6)
  852       =2 #define     USARTBRL                (*(unsigned char volatile far *)0x7efdc7)
  853       =2 #define     USART2CR1               (*(unsigned char volatile far *)0x7efdc8)
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 15  

  854       =2 #define     USART2CR2               (*(unsigned char volatile far *)0x7efdc9)
  855       =2 #define     USART2CR3               (*(unsigned char volatile far *)0x7efdca)
  856       =2 #define     USART2CR4               (*(unsigned char volatile far *)0x7efdcb)
  857       =2 #define     USART2CR5               (*(unsigned char volatile far *)0x7efdcc)
  858       =2 #define     USART2GTR               (*(unsigned char volatile far *)0x7efdcd)
  859       =2 #define     USART2BRH               (*(unsigned char volatile far *)0x7efdce)
  860       =2 #define     USART2BRL               (*(unsigned char volatile far *)0x7efdcf)
  861       =2 
  862       =2 #define     CHIPID                  ( (unsigned char volatile far *)0x7efde0)
  863       =2 
  864       =2 #define     CHIPID0                 (*(unsigned char volatile far *)0x7efde0)
  865       =2 #define     CHIPID1                 (*(unsigned char volatile far *)0x7efde1)
  866       =2 #define     CHIPID2                 (*(unsigned char volatile far *)0x7efde2)
  867       =2 #define     CHIPID3                 (*(unsigned char volatile far *)0x7efde3)
  868       =2 #define     CHIPID4                 (*(unsigned char volatile far *)0x7efde4)
  869       =2 #define     CHIPID5                 (*(unsigned char volatile far *)0x7efde5)
  870       =2 #define     CHIPID6                 (*(unsigned char volatile far *)0x7efde6)
  871       =2 #define     CHIPID7                 (*(unsigned char volatile far *)0x7efde7)
  872       =2 #define     CHIPID8                 (*(unsigned char volatile far *)0x7efde8)
  873       =2 #define     CHIPID9                 (*(unsigned char volatile far *)0x7efde9)
  874       =2 #define     CHIPID10                (*(unsigned char volatile far *)0x7efdea)
  875       =2 #define     CHIPID11                (*(unsigned char volatile far *)0x7efdeb)
  876       =2 #define     CHIPID12                (*(unsigned char volatile far *)0x7efdec)
  877       =2 #define     CHIPID13                (*(unsigned char volatile far *)0x7efded)
  878       =2 #define     CHIPID14                (*(unsigned char volatile far *)0x7efdee)
  879       =2 #define     CHIPID15                (*(unsigned char volatile far *)0x7efdef)
  880       =2 #define     CHIPID16                (*(unsigned char volatile far *)0x7efdf0)
  881       =2 #define     CHIPID17                (*(unsigned char volatile far *)0x7efdf1)
  882       =2 #define     CHIPID18                (*(unsigned char volatile far *)0x7efdf2)
  883       =2 #define     CHIPID19                (*(unsigned char volatile far *)0x7efdf3)
  884       =2 #define     CHIPID20                (*(unsigned char volatile far *)0x7efdf4)
  885       =2 #define     CHIPID21                (*(unsigned char volatile far *)0x7efdf5)
  886       =2 #define     CHIPID22                (*(unsigned char volatile far *)0x7efdf6)
  887       =2 #define     CHIPID23                (*(unsigned char volatile far *)0x7efdf7)
  888       =2 #define     CHIPID24                (*(unsigned char volatile far *)0x7efdf8)
  889       =2 #define     CHIPID25                (*(unsigned char volatile far *)0x7efdf9)
  890       =2 #define     CHIPID26                (*(unsigned char volatile far *)0x7efdfa)
  891       =2 #define     CHIPID27                (*(unsigned char volatile far *)0x7efdfb)
  892       =2 #define     CHIPID28                (*(unsigned char volatile far *)0x7efdfc)
  893       =2 #define     CHIPID29                (*(unsigned char volatile far *)0x7efdfd)
  894       =2 #define     CHIPID30                (*(unsigned char volatile far *)0x7efdfe)
  895       =2 #define     CHIPID31                (*(unsigned char volatile far *)0x7efdff)
  896       =2 
  897       =2 /////////////////////////////////////////////////
  898       =2 //7E:FC00H-7E:FCFFH
  899       =2 /////////////////////////////////////////////////
  900       =2 
  901       =2 
  902       =2 
  903       =2 /////////////////////////////////////////////////
  904       =2 //7E:FB00H-7E:FBFFH
  905       =2 /////////////////////////////////////////////////
  906       =2 
  907       =2 #define     CHIPIDX                 ( (unsigned char volatile far *)0x7efbd0)
  908       =2 
  909       =2 #define     CHIPIDX0                (*(unsigned char volatile far *)0x7efbd0)
  910       =2 #define     CHIPIDX1                (*(unsigned char volatile far *)0x7efbd1)
  911       =2 #define     CHIPIDX2                (*(unsigned char volatile far *)0x7efbd2)
  912       =2 #define     CHIPIDX3                (*(unsigned char volatile far *)0x7efbd3)
  913       =2 #define     CHIPIDX4                (*(unsigned char volatile far *)0x7efbd4)
  914       =2 #define     CHIPIDX5                (*(unsigned char volatile far *)0x7efbd5)
  915       =2 #define     CHIPIDX6                (*(unsigned char volatile far *)0x7efbd6)
  916       =2 #define     CHIPIDX7                (*(unsigned char volatile far *)0x7efbd7)
  917       =2 #define     CHIPIDX8                (*(unsigned char volatile far *)0x7efbd8)
  918       =2 #define     CHIPIDX9                (*(unsigned char volatile far *)0x7efbd9)
  919       =2 #define     CHIPIDX10               (*(unsigned char volatile far *)0x7efbda)
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 16  

  920       =2 #define     CHIPIDX11               (*(unsigned char volatile far *)0x7efbdb)
  921       =2 #define     CHIPIDX12               (*(unsigned char volatile far *)0x7efbdc)
  922       =2 #define     CHIPIDX13               (*(unsigned char volatile far *)0x7efbdd)
  923       =2 #define     CHIPIDX14               (*(unsigned char volatile far *)0x7efbde)
  924       =2 #define     CHIPIDX15               (*(unsigned char volatile far *)0x7efbdf)
  925       =2 #define     CHIPIDX16               (*(unsigned char volatile far *)0x7efbe0)
  926       =2 #define     CHIPIDX17               (*(unsigned char volatile far *)0x7efbe1)
  927       =2 #define     CHIPIDX18               (*(unsigned char volatile far *)0x7efbe2)
  928       =2 #define     CHIPIDX19               (*(unsigned char volatile far *)0x7efbe3)
  929       =2 #define     CHIPIDX20               (*(unsigned char volatile far *)0x7efbe4)
  930       =2 #define     CHIPIDX21               (*(unsigned char volatile far *)0x7efbe5)
  931       =2 #define     CHIPIDX22               (*(unsigned char volatile far *)0x7efbe6)
  932       =2 #define     CHIPIDX23               (*(unsigned char volatile far *)0x7efbe7)
  933       =2 #define     CHIPIDX24               (*(unsigned char volatile far *)0x7efbe8)
  934       =2 #define     CHIPIDX25               (*(unsigned char volatile far *)0x7efbe9)
  935       =2 #define     CHIPIDX26               (*(unsigned char volatile far *)0x7efbea)
  936       =2 #define     CHIPIDX27               (*(unsigned char volatile far *)0x7efbeb)
  937       =2 #define     CHIPIDX28               (*(unsigned char volatile far *)0x7efbec)
  938       =2 #define     CHIPIDX29               (*(unsigned char volatile far *)0x7efbed)
  939       =2 #define     CHIPIDX30               (*(unsigned char volatile far *)0x7efbee)
  940       =2 #define     CHIPIDX31               (*(unsigned char volatile far *)0x7efbef)
  941       =2 
  942       =2 #define     HSPWMA_CFG              (*(unsigned char volatile far *)0x7efbf0)
  943       =2 #define     HSPWMA_ADR              (*(unsigned char volatile far *)0x7efbf1)
  944       =2 #define     HSPWMA_DAT              (*(unsigned char volatile far *)0x7efbf2)
  945       =2 #define     HSPWMA_ADRH             (*(unsigned char volatile far *)0x7efbf3)
  946       =2 #define     HSPWMB_CFG              (*(unsigned char volatile far *)0x7efbf4)
  947       =2 #define     HSPWMB_ADR              (*(unsigned char volatile far *)0x7efbf5)
  948       =2 #define     HSPWMB_DAT              (*(unsigned char volatile far *)0x7efbf6)
  949       =2 #define     HSPWMB_ADRH             (*(unsigned char volatile far *)0x7efbf7)
  950       =2 #define     HSSPI_CFG               (*(unsigned char volatile far *)0x7efbf8)
  951       =2 #define     HSSPI_CFG2              (*(unsigned char volatile far *)0x7efbf9)
  952       =2 #define     HSSPI_STA               (*(unsigned char volatile far *)0x7efbfa)
  953       =2 #define     HSSPI_PSCR              (*(unsigned char volatile far *)0x7efbfb)
  954       =2 
  955       =2 /////////////////////////////////////////////////
  956       =2 //7E:FA00H-7E:FAFFH
  957       =2 /////////////////////////////////////////////////
  958       =2 
  959       =2 #define     DMA_M2M_CFG             (*(unsigned char volatile far *)0x7efa00)
  960       =2 #define     DMA_M2M_CR              (*(unsigned char volatile far *)0x7efa01)
  961       =2 #define     DMA_M2M_STA             (*(unsigned char volatile far *)0x7efa02)
  962       =2 #define     DMA_M2M_AMT             (*(unsigned char volatile far *)0x7efa03)
  963       =2 #define     DMA_M2M_DONE            (*(unsigned char volatile far *)0x7efa04)
  964       =2 #define     DMA_M2M_TXAH            (*(unsigned char volatile far *)0x7efa05)
  965       =2 #define     DMA_M2M_TXAL            (*(unsigned char volatile far *)0x7efa06)
  966       =2 #define     DMA_M2M_RXAH            (*(unsigned char volatile far *)0x7efa07)
  967       =2 #define     DMA_M2M_RXAL            (*(unsigned char volatile far *)0x7efa08)
  968       =2 
  969       =2 #define     DMA_ADC_CFG             (*(unsigned char volatile far *)0x7efa10)
  970       =2 #define     DMA_ADC_CR              (*(unsigned char volatile far *)0x7efa11)
  971       =2 #define     DMA_ADC_STA             (*(unsigned char volatile far *)0x7efa12)
  972       =2 #define     DMA_ADC_AMT             (*(unsigned char volatile far *)0x7efa13)
  973       =2 #define     DMA_ADC_DONE            (*(unsigned char volatile far *)0x7efa14)
  974       =2 #define     DMA_ADC_RXAH            (*(unsigned char volatile far *)0x7efa17)
  975       =2 #define     DMA_ADC_RXAL            (*(unsigned char volatile far *)0x7efa18)
  976       =2 #define     DMA_ADC_CFG2            (*(unsigned char volatile far *)0x7efa19)
  977       =2 #define     DMA_ADC_CHSW0           (*(unsigned char volatile far *)0x7efa1a)
  978       =2 #define     DMA_ADC_CHSW1           (*(unsigned char volatile far *)0x7efa1b)
  979       =2 #define     DMA_ADC_ITVH            (*(unsigned char volatile far *)0x7efa1e)
  980       =2 #define     DMA_ADC_ITVL            (*(unsigned char volatile far *)0x7efa1f)
  981       =2 
  982       =2 #define     DMA_SPI_CFG             (*(unsigned char volatile far *)0x7efa20)
  983       =2 #define     DMA_SPI_CR              (*(unsigned char volatile far *)0x7efa21)
  984       =2 #define     DMA_SPI_STA             (*(unsigned char volatile far *)0x7efa22)
  985       =2 #define     DMA_SPI_AMT             (*(unsigned char volatile far *)0x7efa23)
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 17  

  986       =2 #define     DMA_SPI_DONE            (*(unsigned char volatile far *)0x7efa24)
  987       =2 #define     DMA_SPI_TXAH            (*(unsigned char volatile far *)0x7efa25)
  988       =2 #define     DMA_SPI_TXAL            (*(unsigned char volatile far *)0x7efa26)
  989       =2 #define     DMA_SPI_RXAH            (*(unsigned char volatile far *)0x7efa27)
  990       =2 #define     DMA_SPI_RXAL            (*(unsigned char volatile far *)0x7efa28)
  991       =2 #define     DMA_SPI_CFG2            (*(unsigned char volatile far *)0x7efa29)
  992       =2 #define     DMA_SPI_ITVH            (*(unsigned char volatile far *)0x7efa2e)
  993       =2 #define     DMA_SPI_ITVL            (*(unsigned char volatile far *)0x7efa2f)
  994       =2 
  995       =2 #define     DMA_UR1T_CFG            (*(unsigned char volatile far *)0x7efa30)
  996       =2 #define     DMA_UR1T_CR             (*(unsigned char volatile far *)0x7efa31)
  997       =2 #define     DMA_UR1T_STA            (*(unsigned char volatile far *)0x7efa32)
  998       =2 #define     DMA_UR1T_AMT            (*(unsigned char volatile far *)0x7efa33)
  999       =2 #define     DMA_UR1T_DONE           (*(unsigned char volatile far *)0x7efa34)
 1000       =2 #define     DMA_UR1T_TXAH           (*(unsigned char volatile far *)0x7efa35)
 1001       =2 #define     DMA_UR1T_TXAL           (*(unsigned char volatile far *)0x7efa36)
 1002       =2 #define     DMA_UR1R_CFG            (*(unsigned char volatile far *)0x7efa38)
 1003       =2 #define     DMA_UR1R_CR             (*(unsigned char volatile far *)0x7efa39)
 1004       =2 #define     DMA_UR1R_STA            (*(unsigned char volatile far *)0x7efa3a)
 1005       =2 #define     DMA_UR1R_AMT            (*(unsigned char volatile far *)0x7efa3b)
 1006       =2 #define     DMA_UR1R_DONE           (*(unsigned char volatile far *)0x7efa3c)
 1007       =2 #define     DMA_UR1R_RXAH           (*(unsigned char volatile far *)0x7efa3d)
 1008       =2 #define     DMA_UR1R_RXAL           (*(unsigned char volatile far *)0x7efa3e)
 1009       =2 
 1010       =2 #define     DMA_UR2T_CFG            (*(unsigned char volatile far *)0x7efa40)
 1011       =2 #define     DMA_UR2T_CR             (*(unsigned char volatile far *)0x7efa41)
 1012       =2 #define     DMA_UR2T_STA            (*(unsigned char volatile far *)0x7efa42)
 1013       =2 #define     DMA_UR2T_AMT            (*(unsigned char volatile far *)0x7efa43)
 1014       =2 #define     DMA_UR2T_DONE           (*(unsigned char volatile far *)0x7efa44)
 1015       =2 #define     DMA_UR2T_TXAH           (*(unsigned char volatile far *)0x7efa45)
 1016       =2 #define     DMA_UR2T_TXAL           (*(unsigned char volatile far *)0x7efa46)
 1017       =2 #define     DMA_UR2R_CFG            (*(unsigned char volatile far *)0x7efa48)
 1018       =2 #define     DMA_UR2R_CR             (*(unsigned char volatile far *)0x7efa49)
 1019       =2 #define     DMA_UR2R_STA            (*(unsigned char volatile far *)0x7efa4a)
 1020       =2 #define     DMA_UR2R_AMT            (*(unsigned char volatile far *)0x7efa4b)
 1021       =2 #define     DMA_UR2R_DONE           (*(unsigned char volatile far *)0x7efa4c)
 1022       =2 #define     DMA_UR2R_RXAH           (*(unsigned char volatile far *)0x7efa4d)
 1023       =2 #define     DMA_UR2R_RXAL           (*(unsigned char volatile far *)0x7efa4e)
 1024       =2 
 1025       =2 #define     DMA_UR3T_CFG            (*(unsigned char volatile far *)0x7efa50)
 1026       =2 #define     DMA_UR3T_CR             (*(unsigned char volatile far *)0x7efa51)
 1027       =2 #define     DMA_UR3T_STA            (*(unsigned char volatile far *)0x7efa52)
 1028       =2 #define     DMA_UR3T_AMT            (*(unsigned char volatile far *)0x7efa53)
 1029       =2 #define     DMA_UR3T_DONE           (*(unsigned char volatile far *)0x7efa54)
 1030       =2 #define     DMA_UR3T_TXAH           (*(unsigned char volatile far *)0x7efa55)
 1031       =2 #define     DMA_UR3T_TXAL           (*(unsigned char volatile far *)0x7efa56)
 1032       =2 #define     DMA_UR3R_CFG            (*(unsigned char volatile far *)0x7efa58)
 1033       =2 #define     DMA_UR3R_CR             (*(unsigned char volatile far *)0x7efa59)
 1034       =2 #define     DMA_UR3R_STA            (*(unsigned char volatile far *)0x7efa5a)
 1035       =2 #define     DMA_UR3R_AMT            (*(unsigned char volatile far *)0x7efa5b)
 1036       =2 #define     DMA_UR3R_DONE           (*(unsigned char volatile far *)0x7efa5c)
 1037       =2 #define     DMA_UR3R_RXAH           (*(unsigned char volatile far *)0x7efa5d)
 1038       =2 #define     DMA_UR3R_RXAL           (*(unsigned char volatile far *)0x7efa5e)
 1039       =2 
 1040       =2 #define     DMA_UR4T_CFG            (*(unsigned char volatile far *)0x7efa60)
 1041       =2 #define     DMA_UR4T_CR             (*(unsigned char volatile far *)0x7efa61)
 1042       =2 #define     DMA_UR4T_STA            (*(unsigned char volatile far *)0x7efa62)
 1043       =2 #define     DMA_UR4T_AMT            (*(unsigned char volatile far *)0x7efa63)
 1044       =2 #define     DMA_UR4T_DONE           (*(unsigned char volatile far *)0x7efa64)
 1045       =2 #define     DMA_UR4T_TXAH           (*(unsigned char volatile far *)0x7efa65)
 1046       =2 #define     DMA_UR4T_TXAL           (*(unsigned char volatile far *)0x7efa66)
 1047       =2 #define     DMA_UR4R_CFG            (*(unsigned char volatile far *)0x7efa68)
 1048       =2 #define     DMA_UR4R_CR             (*(unsigned char volatile far *)0x7efa69)
 1049       =2 #define     DMA_UR4R_STA            (*(unsigned char volatile far *)0x7efa6a)
 1050       =2 #define     DMA_UR4R_AMT            (*(unsigned char volatile far *)0x7efa6b)
 1051       =2 #define     DMA_UR4R_DONE           (*(unsigned char volatile far *)0x7efa6c)
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 18  

 1052       =2 #define     DMA_UR4R_RXAH           (*(unsigned char volatile far *)0x7efa6d)
 1053       =2 #define     DMA_UR4R_RXAL           (*(unsigned char volatile far *)0x7efa6e)
 1054       =2 
 1055       =2 #define     DMA_LCM_CFG             (*(unsigned char volatile far *)0x7efa70)
 1056       =2 #define     DMA_LCM_CR              (*(unsigned char volatile far *)0x7efa71)
 1057       =2 #define     DMA_LCM_STA             (*(unsigned char volatile far *)0x7efa72)
 1058       =2 #define     DMA_LCM_AMT             (*(unsigned char volatile far *)0x7efa73)
 1059       =2 #define     DMA_LCM_DONE            (*(unsigned char volatile far *)0x7efa74)
 1060       =2 #define     DMA_LCM_TXAH            (*(unsigned char volatile far *)0x7efa75)
 1061       =2 #define     DMA_LCM_TXAL            (*(unsigned char volatile far *)0x7efa76)
 1062       =2 #define     DMA_LCM_RXAH            (*(unsigned char volatile far *)0x7efa77)
 1063       =2 #define     DMA_LCM_RXAL            (*(unsigned char volatile far *)0x7efa78)
 1064       =2 #define     DMA_LCM_ITVH            (*(unsigned char volatile far *)0x7efa7e)
 1065       =2 #define     DMA_LCM_ITVL            (*(unsigned char volatile far *)0x7efa7f)
 1066       =2 
 1067       =2 #define     DMA_M2M_AMTH            (*(unsigned char volatile far *)0x7efa80)
 1068       =2 #define     DMA_M2M_DONEH           (*(unsigned char volatile far *)0x7efa81)
 1069       =2 #define     DMA_ADC_AMTH            (*(unsigned char volatile far *)0x7efa82)
 1070       =2 #define     DMA_ADC_DONEH           (*(unsigned char volatile far *)0x7efa83)
 1071       =2 #define     DMA_SPI_AMTH            (*(unsigned char volatile far *)0x7efa84)
 1072       =2 #define     DMA_SPI_DONEH           (*(unsigned char volatile far *)0x7efa85)
 1073       =2 #define     DMA_LCM_AMTH            (*(unsigned char volatile far *)0x7efa86)
 1074       =2 #define     DMA_LCM_DONEH           (*(unsigned char volatile far *)0x7efa87)
 1075       =2 #define     DMA_UR1T_AMTH           (*(unsigned char volatile far *)0x7efa88)
 1076       =2 #define     DMA_UR1T_DONEH          (*(unsigned char volatile far *)0x7efa89)
 1077       =2 #define     DMA_UR1R_AMTH           (*(unsigned char volatile far *)0x7efa8a)
 1078       =2 #define     DMA_UR1R_DONEH          (*(unsigned char volatile far *)0x7efa8b)
 1079       =2 #define     DMA_UR2T_AMTH           (*(unsigned char volatile far *)0x7efa8c)
 1080       =2 #define     DMA_UR2T_DONEH          (*(unsigned char volatile far *)0x7efa8d)
 1081       =2 #define     DMA_UR2R_AMTH           (*(unsigned char volatile far *)0x7efa8e)
 1082       =2 #define     DMA_UR2R_DONEH          (*(unsigned char volatile far *)0x7efa8f)
 1083       =2 #define     DMA_UR3T_AMTH           (*(unsigned char volatile far *)0x7efa90)
 1084       =2 #define     DMA_UR3T_DONEH          (*(unsigned char volatile far *)0x7efa91)
 1085       =2 #define     DMA_UR3R_AMTH           (*(unsigned char volatile far *)0x7efa92)
 1086       =2 #define     DMA_UR3R_DONEH          (*(unsigned char volatile far *)0x7efa93)
 1087       =2 #define     DMA_UR4T_AMTH           (*(unsigned char volatile far *)0x7efa94)
 1088       =2 #define     DMA_UR4T_DONEH          (*(unsigned char volatile far *)0x7efa95)
 1089       =2 #define     DMA_UR4R_AMTH           (*(unsigned char volatile far *)0x7efa96)
 1090       =2 #define     DMA_UR4R_DONEH          (*(unsigned char volatile far *)0x7efa97)
 1091       =2 
 1092       =2 #define     DMA_I2CT_CFG            (*(unsigned char volatile far *)0x7efa98)
 1093       =2 #define     DMA_I2CT_CR             (*(unsigned char volatile far *)0x7efa99)
 1094       =2 #define     DMA_I2CT_STA            (*(unsigned char volatile far *)0x7efa9a)
 1095       =2 #define     DMA_I2CT_AMT            (*(unsigned char volatile far *)0x7efa9b)
 1096       =2 #define     DMA_I2CT_DONE           (*(unsigned char volatile far *)0x7efa9c)
 1097       =2 #define     DMA_I2CT_TXAH           (*(unsigned char volatile far *)0x7efa9d)
 1098       =2 #define     DMA_I2CT_TXAL           (*(unsigned char volatile far *)0x7efa9e)
 1099       =2 #define     DMA_I2CR_CFG            (*(unsigned char volatile far *)0x7efaa0)
 1100       =2 #define     DMA_I2CR_CR             (*(unsigned char volatile far *)0x7efaa1)
 1101       =2 #define     DMA_I2CR_STA            (*(unsigned char volatile far *)0x7efaa2)
 1102       =2 #define     DMA_I2CR_AMT            (*(unsigned char volatile far *)0x7efaa3)
 1103       =2 #define     DMA_I2CR_DONE           (*(unsigned char volatile far *)0x7efaa4)
 1104       =2 #define     DMA_I2CR_RXAH           (*(unsigned char volatile far *)0x7efaa5)
 1105       =2 #define     DMA_I2CR_RXAL           (*(unsigned char volatile far *)0x7efaa6)
 1106       =2 
 1107       =2 #define     DMA_I2CT_AMTH           (*(unsigned char volatile far *)0x7efaa8)
 1108       =2 #define     DMA_I2CT_DONEH          (*(unsigned char volatile far *)0x7efaa9)
 1109       =2 #define     DMA_I2CR_AMTH           (*(unsigned char volatile far *)0x7efaaa)
 1110       =2 #define     DMA_I2CR_DONEH          (*(unsigned char volatile far *)0x7efaab)
 1111       =2 #define     DMA_I2C_CR              (*(unsigned char volatile far *)0x7efaad)
 1112       =2 #define     DMA_I2C_ST1             (*(unsigned char volatile far *)0x7efaae)
 1113       =2 #define     DMA_I2C_ST2             (*(unsigned char volatile far *)0x7efaaf)
 1114       =2 
 1115       =2 #define     DMA_I2ST_CFG            (*(unsigned char volatile far *)0x7efab0)
 1116       =2 #define     DMA_I2ST_CR             (*(unsigned char volatile far *)0x7efab1)
 1117       =2 #define     DMA_I2ST_STA            (*(unsigned char volatile far *)0x7efab2)
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 19  

 1118       =2 #define     DMA_I2ST_AMT            (*(unsigned char volatile far *)0x7efab3)
 1119       =2 #define     DMA_I2ST_DONE           (*(unsigned char volatile far *)0x7efab4)
 1120       =2 #define     DMA_I2ST_TXAH           (*(unsigned char volatile far *)0x7efab5)
 1121       =2 #define     DMA_I2ST_TXAL           (*(unsigned char volatile far *)0x7efab6)
 1122       =2 #define     DMA_I2SR_CFG            (*(unsigned char volatile far *)0x7efab8)
 1123       =2 #define     DMA_I2SR_CR             (*(unsigned char volatile far *)0x7efab9)
 1124       =2 #define     DMA_I2SR_STA            (*(unsigned char volatile far *)0x7efaba)
 1125       =2 #define     DMA_I2SR_AMT            (*(unsigned char volatile far *)0x7efabb)
 1126       =2 #define     DMA_I2SR_DONE           (*(unsigned char volatile far *)0x7efabc)
 1127       =2 #define     DMA_I2SR_RXAH           (*(unsigned char volatile far *)0x7efabd)
 1128       =2 #define     DMA_I2SR_RXAL           (*(unsigned char volatile far *)0x7efabe)
 1129       =2 
 1130       =2 #define     DMA_I2ST_AMTH           (*(unsigned char volatile far *)0x7efac0)
 1131       =2 #define     DMA_I2ST_DONEH          (*(unsigned char volatile far *)0x7efac1)
 1132       =2 #define     DMA_I2SR_AMTH           (*(unsigned char volatile far *)0x7efac2)
 1133       =2 #define     DMA_I2SR_DONEH          (*(unsigned char volatile far *)0x7efac3)
 1134       =2 #define     DMA_I2C_ITVH            (*(unsigned char volatile far *)0x7efac4)
 1135       =2 #define     DMA_I2C_ITVL            (*(unsigned char volatile far *)0x7efac5)
 1136       =2 #define     DMA_I2S_ITVH            (*(unsigned char volatile far *)0x7efac6)
 1137       =2 #define     DMA_I2S_ITVL            (*(unsigned char volatile far *)0x7efac7)
 1138       =2 #define     DMA_UR1_ITVH            (*(unsigned char volatile far *)0x7efac8)
 1139       =2 #define     DMA_UR1_ITVL            (*(unsigned char volatile far *)0x7efac9)
 1140       =2 #define     DMA_UR2_ITVH            (*(unsigned char volatile far *)0x7efaca)
 1141       =2 #define     DMA_UR2_ITVL            (*(unsigned char volatile far *)0x7efacb)
 1142       =2 #define     DMA_UR3_ITVH            (*(unsigned char volatile far *)0x7efacc)
 1143       =2 #define     DMA_UR3_ITVL            (*(unsigned char volatile far *)0x7efacd)
 1144       =2 #define     DMA_UR4_ITVH            (*(unsigned char volatile far *)0x7eface)
 1145       =2 #define     DMA_UR4_ITVL            (*(unsigned char volatile far *)0x7efacf)
 1146       =2 
 1147       =2 #define     DMA_QSPI_CFG            (*(unsigned char volatile far *)0x7efad0)
 1148       =2 #define     DMA_QSPI_CR             (*(unsigned char volatile far *)0x7efad1)
 1149       =2 #define     DMA_QSPI_STA            (*(unsigned char volatile far *)0x7efad2)
 1150       =2 #define     DMA_QSPI_AMT            (*(unsigned char volatile far *)0x7efad3)
 1151       =2 #define     DMA_QSPI_DONE           (*(unsigned char volatile far *)0x7efad4)
 1152       =2 #define     DMA_QSPI_TXAH           (*(unsigned char volatile far *)0x7efad5)
 1153       =2 #define     DMA_QSPI_TXAL           (*(unsigned char volatile far *)0x7efad6)
 1154       =2 #define     DMA_QSPI_RXAH           (*(unsigned char volatile far *)0x7efad7)
 1155       =2 #define     DMA_QSPI_RXAL           (*(unsigned char volatile far *)0x7efad8)
 1156       =2 #define     DMA_QSPI_AMTH           (*(unsigned char volatile far *)0x7efadb)
 1157       =2 #define     DMA_QSPI_DONEH          (*(unsigned char volatile far *)0x7efadc)
 1158       =2 #define     DMA_QSPI_ITVH           (*(unsigned char volatile far *)0x7efade)
 1159       =2 #define     DMA_QSPI_ITVL           (*(unsigned char volatile far *)0x7efadf)
 1160       =2 
 1161       =2 #define     DMA_P2P_CR1             (*(unsigned char volatile far *)0x7efaf0)
 1162       =2 #define     DMA_P2P_CR2             (*(unsigned char volatile far *)0x7efaf1)
 1163       =2 #define     DMA_ARB_CFG             (*(unsigned char volatile far *)0x7efaf8)
 1164       =2 #define     DMA_ARB_STA             (*(unsigned char volatile far *)0x7efaf9)
 1165       =2 
 1166       =2 /////////////////////////////////////////////////
 1167       =2 //7E:F900H-7E:F9FFH
 1168       =2 /////////////////////////////////////////////////
 1169       =2 
 1170       =2 #define     QSPI_CR1                (*(unsigned char volatile far *)0x7ef900)
 1171       =2 #define     QSPI_CR2                (*(unsigned char volatile far *)0x7ef901)
 1172       =2 #define     QSPI_CR3                (*(unsigned char volatile far *)0x7ef902)
 1173       =2 #define     QSPI_CR4                (*(unsigned char volatile far *)0x7ef903)
 1174       =2 #define     QSPI_DCR1               (*(unsigned char volatile far *)0x7ef904)
 1175       =2 #define     QSPI_DCR2               (*(unsigned char volatile far *)0x7ef905)
 1176       =2 #define     QSPI_SR1                (*(unsigned char volatile far *)0x7ef906)
 1177       =2 #define     QSPI_SR2                (*(unsigned char volatile far *)0x7ef907)
 1178       =2 #define     QSPI_FCR                (*(unsigned char volatile far *)0x7ef908)
 1179       =2 #define     QSPI_HCR1               (*(unsigned char volatile far *)0x7ef909)
 1180       =2 #define     QSPI_HCR2               (*(unsigned char volatile far *)0x7ef90a)
 1181       =2 #define     QSPI_DLR1               (*(unsigned char volatile far *)0x7ef910)
 1182       =2 #define     QSPI_DLR2               (*(unsigned char volatile far *)0x7ef911)
 1183       =2 #define     QSPI_CCR1               (*(unsigned char volatile far *)0x7ef914)
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 20  

 1184       =2 #define     QSPI_CCR2               (*(unsigned char volatile far *)0x7ef915)
 1185       =2 #define     QSPI_CCR3               (*(unsigned char volatile far *)0x7ef916)
 1186       =2 #define     QSPI_CCR4               (*(unsigned char volatile far *)0x7ef917)
 1187       =2 #define     QSPI_AR1                (*(unsigned char volatile far *)0x7ef918)
 1188       =2 #define     QSPI_AR2                (*(unsigned char volatile far *)0x7ef919)
 1189       =2 #define     QSPI_AR3                (*(unsigned char volatile far *)0x7ef91a)
 1190       =2 #define     QSPI_AR4                (*(unsigned char volatile far *)0x7ef91b)
 1191       =2 #define     QSPI_ABR                (*(unsigned char volatile far *)0x7ef91c)
 1192       =2 #define     QSPI_DR                 (*(unsigned char volatile far *)0x7ef920)
 1193       =2 #define     QSPI_PSMKR1             (*(unsigned char volatile far *)0x7ef924)
 1194       =2 #define     QSPI_PSMAR1             (*(unsigned char volatile far *)0x7ef928)
 1195       =2 #define     QSPI_PIR1               (*(unsigned char volatile far *)0x7ef92c)
 1196       =2 #define     QSPI_PIR2               (*(unsigned char volatile far *)0x7ef92d)
 1197       =2 
 1198       =2 #define     PWMA_ENO2               (*(unsigned char volatile far *)0x7ef930)
 1199       =2 #define     PWMA_IOAUX2             (*(unsigned char volatile far *)0x7ef931)
 1200       =2 #define     PWMA_CR3                (*(unsigned char volatile far *)0x7ef932)
 1201       =2 #define     PWMA_SR3                (*(unsigned char volatile far *)0x7ef933)
 1202       =2 #define     PWMA_CCER3              (*(unsigned char volatile far *)0x7ef934)
 1203       =2 #define     PWMA_CCMR1X             (*(unsigned char volatile far *)0x7ef938)
 1204       =2 #define     PWMA_CCMR2X             (*(unsigned char volatile far *)0x7ef939)
 1205       =2 #define     PWMA_CCMR3X             (*(unsigned char volatile far *)0x7ef93a)
 1206       =2 #define     PWMA_CCMR4X             (*(unsigned char volatile far *)0x7ef93b)
 1207       =2 #define     PWMA_CCMR5              (*(unsigned char volatile far *)0x7ef93c)
 1208       =2 #define     PWMA_CCMR5X             (*(unsigned char volatile far *)0x7ef93d)
 1209       =2 #define     PWMA_CCMR6              (*(unsigned char volatile far *)0x7ef93e)
 1210       =2 #define     PWMA_CCMR6X             (*(unsigned char volatile far *)0x7ef93f)
 1211       =2 #define     PWMA_CCR5H              (*(unsigned char volatile far *)0x7ef940)
 1212       =2 #define     PWMA_CCR5L              (*(unsigned char volatile far *)0x7ef941)
 1213       =2 #define     PWMA_CCR5X              (*(unsigned char volatile far *)0x7ef942)
 1214       =2 #define     PWMA_CCR6H              (*(unsigned char volatile far *)0x7ef943)
 1215       =2 #define     PWMA_CCR6L              (*(unsigned char volatile far *)0x7ef944)
 1216       =2 #define     PWMA_DER                (*(unsigned char volatile far *)0x7ef948)
 1217       =2 #define     PWMA_DBA                (*(unsigned char volatile far *)0x7ef949)
 1218       =2 #define     PWMA_DBL                (*(unsigned char volatile far *)0x7ef94a)
 1219       =2 #define     PWMA_DMACR              (*(unsigned char volatile far *)0x7ef94b)
 1220       =2 
 1221       =2 #define     DMA_PWMAT_CFG           (*(unsigned char volatile far *)0x7ef980)
 1222       =2 #define     DMA_PWMAT_CR            (*(unsigned char volatile far *)0x7ef981)
 1223       =2 #define     DMA_PWMAT_STA           (*(unsigned char volatile far *)0x7ef982)
 1224       =2 #define     DMA_PWMAT_AMTH          (*(unsigned char volatile far *)0x7ef984)
 1225       =2 #define     DMA_PWMAT_AMT           (*(unsigned char volatile far *)0x7ef985)
 1226       =2 #define     DMA_PWMAT_DONEH         (*(unsigned char volatile far *)0x7ef986)
 1227       =2 #define     DMA_PWMAT_DONE          (*(unsigned char volatile far *)0x7ef987)
 1228       =2 #define     DMA_PWMAT_TXAH          (*(unsigned char volatile far *)0x7ef988)
 1229       =2 #define     DMA_PWMAT_TXAL          (*(unsigned char volatile far *)0x7ef989)
 1230       =2 #define     DMA_PWMA_ITVH           (*(unsigned char volatile far *)0x7ef98e)
 1231       =2 #define     DMA_PWMA_ITVL           (*(unsigned char volatile far *)0x7ef98f)
 1232       =2 
 1233       =2 #define     DMA_PWMAR_CFG           (*(unsigned char volatile far *)0x7ef990)
 1234       =2 #define     DMA_PWMAR_CR            (*(unsigned char volatile far *)0x7ef991)
 1235       =2 #define     DMA_PWMAR_STA           (*(unsigned char volatile far *)0x7ef992)
 1236       =2 #define     DMA_PWMAR_AMTH          (*(unsigned char volatile far *)0x7ef994)
 1237       =2 #define     DMA_PWMAR_AMT           (*(unsigned char volatile far *)0x7ef995)
 1238       =2 #define     DMA_PWMAR_DONEH         (*(unsigned char volatile far *)0x7ef996)
 1239       =2 #define     DMA_PWMAR_DONE          (*(unsigned char volatile far *)0x7ef997)
 1240       =2 #define     DMA_PWMAR_RXAH          (*(unsigned char volatile far *)0x7ef998)
 1241       =2 #define     DMA_PWMAR_RXAL          (*(unsigned char volatile far *)0x7ef999)
 1242       =2 
 1243       =2 /////////////////////////////////////////////////
 1244       =2 //USB Control Regiter
 1245       =2 /////////////////////////////////////////////////
 1246       =2 
 1247       =2 #define     USBBASE                 0
 1248       =2 #define     FADDR                   (USBBASE + 0)
 1249       =2 #define     UPDATE                  0x80
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 21  

 1250       =2 #define     POWER                   (USBBASE + 1)
 1251       =2 #define     ISOUD                   0x80
 1252       =2 #define     USBRST                  0x08
 1253       =2 #define     USBRSU                  0x04
 1254       =2 #define     USBSUS                  0x02
 1255       =2 #define     ENSUS                   0x01
 1256       =2 #define     INTRIN1                 (USBBASE + 2)
 1257       =2 #define     EP5INIF                 0x20
 1258       =2 #define     EP4INIF                 0x10
 1259       =2 #define     EP3INIF                 0x08
 1260       =2 #define     EP2INIF                 0x04
 1261       =2 #define     EP1INIF                 0x02
 1262       =2 #define     EP0IF                   0x01
 1263       =2 #define     INTROUT1                (USBBASE + 4)
 1264       =2 #define     EP5OUTIF                0x20
 1265       =2 #define     EP4OUTIF                0x10
 1266       =2 #define     EP3OUTIF                0x08
 1267       =2 #define     EP2OUTIF                0x04
 1268       =2 #define     EP1OUTIF                0x02
 1269       =2 #define     INTRUSB                 (USBBASE + 6)
 1270       =2 #define     SOFIF                   0x08
 1271       =2 #define     RSTIF                   0x04
 1272       =2 #define     RSUIF                   0x02
 1273       =2 #define     SUSIF                   0x01
 1274       =2 #define     INTRIN1E                (USBBASE + 7)
 1275       =2 #define     EP5INIE                 0x20
 1276       =2 #define     EP4INIE                 0x10
 1277       =2 #define     EP3INIE                 0x08
 1278       =2 #define     EP2INIE                 0x04
 1279       =2 #define     EP1INIE                 0x02
 1280       =2 #define     EP0IE                   0x01
 1281       =2 #define     INTROUT1E               (USBBASE + 9)
 1282       =2 #define     EP5OUTIE                0x20
 1283       =2 #define     EP4OUTIE                0x10
 1284       =2 #define     EP3OUTIE                0x08
 1285       =2 #define     EP2OUTIE                0x04
 1286       =2 #define     EP1OUTIE                0x02
 1287       =2 #define     INTRUSBE                (USBBASE + 11)
 1288       =2 #define     SOFIE                   0x08
 1289       =2 #define     RSTIE                   0x04
 1290       =2 #define     RSUIE                   0x02
 1291       =2 #define     SUSIE                   0x01
 1292       =2 #define     FRAME1                  (USBBASE + 12)
 1293       =2 #define     FRAME2                  (USBBASE + 13)
 1294       =2 #define     INDEX                   (USBBASE + 14)
 1295       =2 #define     INMAXP                  (USBBASE + 16)
 1296       =2 #define     CSR0                    (USBBASE + 17)
 1297       =2 #define     SSUEND                  0x80
 1298       =2 #define     SOPRDY                  0x40
 1299       =2 #define     SDSTL                   0x20
 1300       =2 #define     SUEND                   0x10
 1301       =2 #define     DATEND                  0x08
 1302       =2 #define     STSTL                   0x04
 1303       =2 #define     IPRDY                   0x02
 1304       =2 #define     OPRDY                   0x01
 1305       =2 #define     INCSR1                  (USBBASE + 17)
 1306       =2 #define     INCLRDT                 0x40
 1307       =2 #define     INSTSTL                 0x20
 1308       =2 #define     INSDSTL                 0x10
 1309       =2 #define     INFLUSH                 0x08
 1310       =2 #define     INUNDRUN                0x04
 1311       =2 #define     INFIFONE                0x02
 1312       =2 #define     INIPRDY                 0x01
 1313       =2 #define     INCSR2                  (USBBASE + 18)
 1314       =2 #define     INAUTOSET               0x80
 1315       =2 #define     INISO                   0x40
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 22  

 1316       =2 #define     INMODEIN                0x20
 1317       =2 #define     INMODEOUT               0x00
 1318       =2 #define     INENDMA                 0x10
 1319       =2 #define     INFCDT                  0x08
 1320       =2 #define     OUTMAXP                 (USBBASE + 19)
 1321       =2 #define     OUTCSR1                 (USBBASE + 20)
 1322       =2 #define     OUTCLRDT                0x80
 1323       =2 #define     OUTSTSTL                0x40
 1324       =2 #define     OUTSDSTL                0x20
 1325       =2 #define     OUTFLUSH                0x10
 1326       =2 #define     OUTDATERR               0x08
 1327       =2 #define     OUTOVRRUN               0x04
 1328       =2 #define     OUTFIFOFUL              0x02
 1329       =2 #define     OUTOPRDY                0x01
 1330       =2 #define     OUTCSR2                 (USBBASE + 21)
 1331       =2 #define     OUTAUTOCLR              0x80
 1332       =2 #define     OUTISO                  0x40
 1333       =2 #define     OUTENDMA                0x20
 1334       =2 #define     OUTDMAMD                0x10
 1335       =2 #define     COUNT0                  (USBBASE + 22)
 1336       =2 #define     OUTCOUNT1               (USBBASE + 22)
 1337       =2 #define     OUTCOUNT2               (USBBASE + 23)
 1338       =2 #define     FIFO0                   (USBBASE + 32)
 1339       =2 #define     FIFO1                   (USBBASE + 33)
 1340       =2 #define     FIFO2                   (USBBASE + 34)
 1341       =2 #define     FIFO3                   (USBBASE + 35)
 1342       =2 #define     FIFO4                   (USBBASE + 36)
 1343       =2 #define     FIFO5                   (USBBASE + 37)
 1344       =2 #define     UTRKCTL                 (USBBASE + 48)
 1345       =2 #define     UTRKSTS                 (USBBASE + 49)
 1346       =2 
 1347       =2 /////////////////////////////////////////////////
 1348       =2 //Interrupt Vector
 1349       =2 /////////////////////////////////////////////////
 1350       =2 
 1351       =2 #define     INT0_VECTOR             0       //0003H
 1352       =2 #define     TMR0_VECTOR             1       //000BH
 1353       =2 #define     INT1_VECTOR             2       //0013H
 1354       =2 #define     TMR1_VECTOR             3       //001BH
 1355       =2 #define     UART1_VECTOR            4       //0023H
 1356       =2 #define     ADC_VECTOR              5       //002BH
 1357       =2 #define     LVD_VECTOR              6       //0033H
 1358       =2 #define     PCA_VECTOR              7       //003BH
 1359       =2 #define     UART2_VECTOR            8       //0043H
 1360       =2 #define     SPI_VECTOR              9       //004BH
 1361       =2 #define     INT2_VECTOR             10      //0053H
 1362       =2 #define     INT3_VECTOR             11      //005BH
 1363       =2 #define     TMR2_VECTOR             12      //0063H
 1364       =2 #define     USER_VECTOR             13      //006BH
 1365       =2 #define     INT4_VECTOR             16      //0083H
 1366       =2 #define     UART3_VECTOR            17      //008BH
 1367       =2 #define     UART4_VECTOR            18      //0093H
 1368       =2 #define     TMR3_VECTOR             19      //009BH
 1369       =2 #define     TMR4_VECTOR             20      //00A3H
 1370       =2 #define     CMP_VECTOR              21      //00ABH
 1371       =2 #define     I2C_VECTOR              24      //00C3H
 1372       =2 #define     USB_VECTOR              25      //00CBH
 1373       =2 #define     PWMA_VECTOR             26      //00D3H
 1374       =2 #define     PWMB_VECTOR             27      //00DBH
 1375       =2 
 1376       =2 #define     RTC_VECTOR              36      //0123H
 1377       =2 #define     P0INT_VECTOR            37      //012BH
 1378       =2 #define     P1INT_VECTOR            38      //0133H
 1379       =2 #define     P2INT_VECTOR            39      //013BH
 1380       =2 #define     P3INT_VECTOR            40      //0143H
 1381       =2 #define     P4INT_VECTOR            41      //014BH
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 23  

 1382       =2 #define     P5INT_VECTOR            42      //0153H
 1383       =2 #define     P6INT_VECTOR            43      //015BH
 1384       =2 #define     P7INT_VECTOR            44      //0163H
 1385       =2 #define     DMA_M2M_VECTOR          47      //017BH
 1386       =2 #define     DMA_ADC_VECTOR          48      //0183H
 1387       =2 #define     DMA_SPI_VECTOR          49      //018BH
 1388       =2 #define     DMA_UR1T_VECTOR         50      //0193H
 1389       =2 #define     DMA_UR1R_VECTOR         51      //019BH
 1390       =2 #define     DMA_UR2T_VECTOR         52      //01A3H
 1391       =2 #define     DMA_UR2R_VECTOR         53      //01ABH
 1392       =2 #define     DMA_UR3T_VECTOR         54      //01B3H
 1393       =2 #define     DMA_UR3R_VECTOR         55      //01BBH
 1394       =2 #define     DMA_UR4T_VECTOR         56      //01C3H
 1395       =2 #define     DMA_UR4R_VECTOR         57      //01CBH
 1396       =2 #define     DMA_LCM_VECTOR          58      //01D3H
 1397       =2 #define     LCM_VECTOR              59      //01DBH
 1398       =2 #define     DMA_I2CT_VECTOR         60      //01E3H
 1399       =2 #define     DMA_I2CR_VECTOR         61      //01EBH
 1400       =2 #define     I2S_VECTOR              62      //01F3H
 1401       =2 #define     DMA_I2ST_VECTOR         63      //01FBH
 1402       =2 #define     DMA_I2SR_VECTOR         64      //0203H
 1403       =2 #define     DMA_QSPI_VECTOR         65      //020BH
 1404       =2 #define     QSPI_VECTOR             66      //0213H
 1405       =2 #define     TMR11_VECTOR            67      //021BH
 1406       =2 #define     DMA_PWMAT_VECTOR        72      //0243H
 1407       =2 #define     DMA_PWMAR_VECTOR        73      //024BH
 1408       =2 
 1409       =2 /////////////////////////////////////////////////
 1410       =2 
 1411       =2 #define EAXSFR()    EAXFR = 1   /* MOVX A,@DPTR/MOVX @DPTR,A指令的操作对象为扩展SFR(XSFR) */
 1412       =2 #define EAXRAM()    EAXFR = 0   /* MOVX A,@DPTR/MOVX @DPTR,A指令的操作对象为扩展RAM(XRAM) */
 1413       =2 
 1414       =2 /////////////////////////////////////////////////
 1415       =2 #define NOP1()  _nop_()
 1416       =2 #define NOP2()  NOP1(),NOP1()
 1417       =2 #define NOP3()  NOP2(),NOP1()
 1418       =2 #define NOP4()  NOP3(),NOP1()
 1419       =2 #define NOP5()  NOP4(),NOP1()
 1420       =2 #define NOP6()  NOP5(),NOP1()
 1421       =2 #define NOP7()  NOP6(),NOP1()
 1422       =2 #define NOP8()  NOP7(),NOP1()
 1423       =2 #define NOP9()  NOP8(),NOP1()
 1424       =2 #define NOP10() NOP9(),NOP1()
 1425       =2 #define NOP11() NOP10(),NOP1()
 1426       =2 #define NOP12() NOP11(),NOP1()
 1427       =2 #define NOP13() NOP12(),NOP1()
 1428       =2 #define NOP14() NOP13(),NOP1()
 1429       =2 #define NOP15() NOP14(),NOP1()
 1430       =2 #define NOP16() NOP15(),NOP1()
 1431       =2 #define NOP17() NOP16(),NOP1()
 1432       =2 #define NOP18() NOP17(),NOP1()
 1433       =2 #define NOP19() NOP18(),NOP1()
 1434       =2 #define NOP20() NOP19(),NOP1()
 1435       =2 #define NOP21() NOP20(),NOP1()
 1436       =2 #define NOP22() NOP21(),NOP1()
 1437       =2 #define NOP23() NOP22(),NOP1()
 1438       =2 #define NOP24() NOP23(),NOP1()
 1439       =2 #define NOP25() NOP24(),NOP1()
 1440       =2 #define NOP26() NOP25(),NOP1()
 1441       =2 #define NOP27() NOP26(),NOP1()
 1442       =2 #define NOP28() NOP27(),NOP1()
 1443       =2 #define NOP29() NOP28(),NOP1()
 1444       =2 #define NOP30() NOP29(),NOP1()
 1445       =2 #define NOP31() NOP30(),NOP1()
 1446       =2 #define NOP32() NOP31(),NOP1()
 1447       =2 #define NOP33() NOP32(),NOP1()
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 24  

 1448       =2 #define NOP34() NOP33(),NOP1()
 1449       =2 #define NOP35() NOP34(),NOP1()
 1450       =2 #define NOP36() NOP35(),NOP1()
 1451       =2 #define NOP37() NOP36(),NOP1()
 1452       =2 #define NOP38() NOP37(),NOP1()
 1453       =2 #define NOP39() NOP38(),NOP1()
 1454       =2 #define NOP40() NOP39(),NOP1()
 1455       =2 #define NOP(N)  NOP##N()
 1456       =2 
 1457       =2 
 1458       =2 /////////////////////////////////////////////////
 1459       =2 
 1460       =2 
 1461       =2 #endif
 1462       =2 
    7       =1 
    8       =1 #endif // !INC_MAIN_H_
    9          #include <stdio.h>
    1       =1 /*--------------------------------------------------------------------------
    2       =1 STDIO.H
    3       =1 
    4       =1 Prototypes for standard I/O functions for C251 Version 3.
    5       =1 Copyright (c) 1995-2001 Keil Elektronik GmbH and Keil Software, Inc.
    6       =1 All rights reserved.
    7       =1 --------------------------------------------------------------------------*/
    8       =1 
    9       =1 #pragma SAVE
   10       =1 #pragma PARM251
   11       =1 
   12       =1 #ifndef EOF
   13       =1  #define EOF -1
   14       =1 #endif
   15       =1 
   16       =1 #ifndef NULL
   17       =1  #define NULL ((void *) 0)
   18       =1 #endif
   19       =1 
   20       =1 #ifndef _SIZE_T
   21       =1  #define _SIZE_T
   22       =1  typedef unsigned int size_t;
   23       =1 #endif
   24       =1 
   25       =1 #if (__C251__ >= 200) 
   26       =1 #pragma SAVE
   27       =1 #pragma FUNCTIONS(STATIC)
   28       =1 /* only static functions available */
   29       =1 extern char _getkey  (void);
   30       =1 extern char getchar  (void);
   31       =1 extern char ungetchar(char);
   32       =1 extern char putchar  (char);
   33       =1 extern int  printf   (const char *, ...); 
   34       =1 extern char *gets    (char *, int n);
   35       =1 extern int  scanf    (const char *, ...);
   36       =1 extern int  vprintf  (const char *, char *);
   37       =1 extern int  puts     (const char *);
   38       =1 #pragma RESTORE
   39       =1 /* available as reentrant & non-reentrant version */
   40       =1 extern int  sprintf  (char *, const char *, ...);
   41       =1 extern int  vsprintf (char *, const char *, char *);
   42       =1 extern int  sscanf   (char *, const char *, ...);
   43       =1 #else
            =1 extern char _getkey (void);
            =1 extern char getchar (void);
            =1 extern char ungetchar (char);
            =1 extern char putchar (char);
            =1 extern int printf   (const char *, ...);
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 25  

            =1 extern int sprintf  (char *, const char *, ...);
            =1 extern int vprintf  (const char *, char *);
            =1 extern int vsprintf (char *, const char *, char *);
            =1 extern char *gets (char *, int n);
            =1 extern int scanf (const char *, ...);
            =1 extern int sscanf (char *, const char *, ...);
            =1 extern int puts (const char *);
            =1 #endif
   57       =1 
   58       =1 #pragma RESTORE
   10          //#define USE_ADC_INPUT      // will go right to application and ignore eeprom
   11          
   12          #include "nstdint.h"
    1       =1 #ifndef _NSTDINT_H
            =1 #define _NSTDINT_H
            =1 
            =1 typedef unsigned char uint8_t;
            =1 typedef unsigned int uint16_t;
            =1 typedef unsigned long uint32_t;
            =1 typedef char    int8_t;
            =1 typedef int     int16_t;
            =1 typedef long    int32_t;
            =1 
            =1 #endif // !_NSTDINT_H
   13          #include <stdlib.h>
    1       =1 /*--------------------------------------------------------------------------
    2       =1 STDLIB.H
    3       =1 
    4       =1 Standard functions for C251 Version 3.
    5       =1 Copyright (c) 1995-2001 Keil Elektronik GmbH and Keil Software, Inc.
    6       =1 All rights reserved.
    7       =1 --------------------------------------------------------------------------*/
    8       =1 
    9       =1 #pragma SAVE
   10       =1 #pragma PARM251
   11       =1 
   12       =1 #ifndef _SIZE_T
            =1  #define _SIZE_T
            =1  typedef unsigned int size_t;
            =1 #endif
   16       =1 
   17       =1 #ifndef NULL
            =1  #define NULL ((void *) 0L)
            =1 #endif
   20       =1 
   21       =1 #ifndef _WCHAR_T_DEFINED_
   22       =1 #define _WCHAR_T_DEFINED_
   23       =1 typedef char wchar_t;
   24       =1 #endif
   25       =1 
   26       =1 #ifndef RAND_MAX
   27       =1  #define RAND_MAX  32767u
   28       =1 #endif
   29       =1 
   30       =1 #if __C251__ >= 200
   31       =1 extern int     abs  (int   val) reentrant;
   32       =1 extern long   labs  (long  val) reentrant;
   33       =1 
   34       =1 extern double atof (char *s1) reentrant;
   35       =1 extern long   atol (char *s1) reentrant;
   36       =1 extern int    atoi (char *s1) reentrant;
   37       =1 extern int    rand ()         reentrant;
   38       =1 extern void   srand (int)     reentrant;
   39       =1 
   40       =1 #pragma SAVE
   41       =1 #pragma functions (static)
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 26  

   42       =1 #if (__MODEL__ == 3 || __MODEL__ == 4)   /* TINY & XTINY */
            =1 extern void near  *malloc        (unsigned int size);
            =1 extern void        free          (void near *p);
            =1 extern void        init_mempool  (void near *p, unsigned int size);
            =1 extern void near  *realloc       (void near *p, unsigned int size);
            =1 extern void near  *calloc        (unsigned int size, unsigned int len);
            =1 #else
   49       =1 extern void far   *malloc        (unsigned int size);
   50       =1 extern void        free          (void far *p);
   51       =1 extern void        init_mempool  (void far *p, unsigned int size);
   52       =1 extern void far   *realloc       (void far *p, unsigned int size);
   53       =1 extern void far   *calloc        (unsigned int size, unsigned int len);
   54       =1 #endif
   55       =1 
   56       =1 extern void far   *fmalloc       (unsigned int size);
   57       =1 extern void        ffree         (void far *p);
   58       =1 extern void        finit_mempool (void far *p, unsigned int size);
   59       =1 extern void far   *frealloc      (void far *p, unsigned int size);
   60       =1 extern void far   *fcalloc       (unsigned int size, unsigned int len);
   61       =1 
   62       =1 extern void xdata *xmalloc       (unsigned int size);
   63       =1 extern void        xfree         (void xdata *p);
   64       =1 extern void        xinit_mempool (void xdata *p, unsigned int size);
   65       =1 extern void xdata *xrealloc      (void xdata *p, unsigned int size);
   66       =1 extern void xdata *xcalloc       (unsigned int size, unsigned int len);
   67       =1 #pragma RESTORE
   68       =1 #else
            =1 extern int     abs  (int   val);
            =1 extern long   labs  (long  val);
            =1 
            =1 extern float  atof (char *s1);
            =1 extern long   atol (char *s1);
            =1 extern int    atoi (char *s1);
            =1 extern int    rand ();
            =1 extern void   srand (int);
            =1 
            =1 extern void *malloc      (unsigned int size);
            =1 extern void free         (void xdata *p);
            =1 extern void init_mempool (void xdata *p, unsigned int size);
            =1 extern void *realloc     (void xdata *p, unsigned int size);
            =1 extern void *calloc      (unsigned int size, unsigned int len);
            =1 #endif
   84       =1 
   85       =1 #pragma RESTORE
   14          #include <string.h>
    1       =1 /*--------------------------------------------------------------------------
    2       =1 STRING.H
    3       =1 
    4       =1 String functions for C251 Version 4.
    5       =1 Copyright (c) 1995-2007 Keil Elektronik GmbH and Keil Software, Inc.
    6       =1 All rights reserved.
    7       =1 --------------------------------------------------------------------------*/
    8       =1 
    9       =1 #pragma SAVE
   10       =1 #pragma PARM251
   11       =1 
   12       =1 #ifndef _SIZE_T
            =1  #define _SIZE_T
            =1  typedef unsigned int size_t;
            =1 #endif
   16       =1 
   17       =1 #ifndef NULL
            =1  #define NULL ((void *) 0L)
            =1 #endif
   20       =1 
   21       =1 #if (__C251__ >= 200) 
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 27  

   22       =1 extern char *strcat (char *s1, const char *s2) reentrant;
   23       =1 extern char *strncat (char *s1, const char *s2, size_t n) reentrant;
   24       =1 
   25       =1 extern char strcmp (const char *s1, const char *s2) reentrant;
   26       =1 extern char strncmp (const char *s1, const char *s2, size_t n) reentrant;
   27       =1 
   28       =1 extern char *strcpy (char *s1, const char *s2) reentrant;
   29       =1 extern char *strncpy (char *s1, const char *s2, size_t n) reentrant;
   30       =1 
   31       =1 extern size_t strlen (const char *) reentrant;
   32       =1 
   33       =1 extern char *strchr (const char *s, char c) reentrant;
   34       =1 extern int strpos (const char *s, char c) reentrant;
   35       =1 extern char *strrchr (const char *s, char c) reentrant;
   36       =1 extern int strrpos (const char *s, char c) reentrant;
   37       =1 
   38       =1 extern size_t strspn (const char *s, const char *set) reentrant;
   39       =1 extern size_t strcspn (const char *s, const char *set) reentrant;
   40       =1 extern char *strpbrk (const char *s, const char *set) reentrant;
   41       =1 extern char *strrpbrk (const char *s, const char *set) reentrant;
   42       =1 
   43       =1 extern char memcmp (const void *s1, const void *s2, size_t n) reentrant;
   44       =1 extern void *memcpy (void *s1, const void *s2, size_t n) reentrant;
   45       =1 extern void *memchr (const void *s, char val, size_t n) reentrant;
   46       =1 extern void *memccpy (void *s1, const void *s2, char val, size_t n) reentrant;
   47       =1 extern void *memmove (void *s1, const void *s2, size_t n) reentrant;
   48       =1 extern void *memset  (void *s, char val, size_t n) reentrant;
   49       =1 
   50       =1 extern void far   *fmemset  (void far *s,   char val, unsigned int n) reentrant;
   51       =1 extern void xdata *xmemset  (void xdata *s, char val, unsigned int n) reentrant;
   52       =1 extern void far   *fmemcpy  (void far *s1,  void far *s2, unsigned int n) reentrant;
   53       =1 extern void xdata *xmemcpy  (void xdata *s1, void xdata *s2, unsigned int n) reentrant;
   54       =1 
   55       =1 extern unsigned long hstrlen (const char huge *s)  reentrant;
   56       =1 extern          char hstrcmp (const char huge *s1, const char huge *s2)  reentrant;
   57       =1 extern    char huge *hstrcpy (char huge *s1, const char huge *s2)  reentrant;
   58       =1 
   59       =1 #pragma PARM4  // allow a maximum of 4 long as register parameters
   60       =1 extern char huge *hstrncpy (char huge *s1, const char huge *s2, unsigned long n) reentrant; 
   61       =1 
   62       =1 extern      char  hmemcmp (const void huge *s1, const void huge *s2, unsigned long len) reentrant;
   63       =1 extern void huge *hmemcpy (void huge *s1, const void huge *s2, unsigned long len) reentrant;
   64       =1 extern void huge *hmemchr (const void huge *ptr, char val, unsigned long len) reentrant;
   65       =1 extern char huge *hmemccpy (char huge *dest, const char huge *src, char val, unsigned long len) reentrant
             -;
   66       =1 extern void huge *hmemmove (void huge *s1, const void huge *s2, unsigned long len) reentrant;
   67       =1 extern void huge *hmemset (void huge *ptr, char val, unsigned long len) reentrant;
   68       =1 
   69       =1 #else
            =1 extern char *strcat (char *s1, char *s2);
            =1 extern char *strncat (char *s1, char *s2, int n);
            =1 
            =1 extern char strcmp (char *s1, char *s2);
            =1 extern char strncmp (char *s1, char *s2, int n);
            =1 
            =1 extern char *strcpy (char *s1, char *s2);
            =1 extern char *strncpy (char *s1, char *s2, int n);
            =1 
            =1 extern int strlen (char *);
            =1 
            =1 extern char *strchr (const char *s, char c);
            =1 extern int strpos (const char *s, char c);
            =1 extern char *strrchr (const char *s, char c);
            =1 extern int strrpos (const char *s, char c);
            =1 
            =1 extern int strspn (char *s, char *set);
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 28  

            =1 extern int strcspn (char *s, char *set);
            =1 extern char *strpbrk (char *s, char *set);
            =1 extern char *strrpbrk (char *s, char *set);
            =1 
            =1 extern char memcmp (void *s1, void *s2, int n);
            =1 extern void *memcpy (void *s1, void *s2, int n);
            =1 extern void *memchr (void *s, char val, int n);
            =1 extern void *memccpy (void *s1, void *s2, char val, int n);
            =1 extern void *memmove (void *s1, void *s2, int n);
            =1 extern void *memset  (void *s, char val, int n);
            =1 
            =1 #endif
   99       =1 
  100       =1 #pragma RESTORE
   15          #include "bootloader.h"
    1       =1 /*
    2       =1  * bootloader.h
    3       =1  *
    4       =1  *  Created on: Mar. 25, 2020
    5       =1  *      Author: Alka
    6       =1  */
    7       =1 #include "main.h"
    1       =2 #ifndef INC_MAIN_H_
            =2 #define INC_MAIN_H_
            =2 
            =2 #include "nstdint.h"
            =2 #include "intrins.h"
            =2 #include "STC8051U.H"
            =2 
            =2 #endif // !INC_MAIN_H_
    8       =1 
    9       =1 
   10       =1 #ifndef INC_BOOTLOADER_H_
   11       =1 #define INC_BOOTLOADER_H_
   12       =1 #endif /* INC_BOOTLOADER_H_ */
   13       =1 
   14       =1 #define   IAP_STANDBY() IAP_CMD = 0   
   15       =1 #define   IAP_READ()    IAP_CMD = 1   
   16       =1 #define   IAP_WRITE()   IAP_CMD = 2   
   17       =1 #define   IAP_ERASE()   IAP_CMD = 3   
   18       =1 
   19       =1 #define IAP_ENABLE()    IAPEN = 1
   20       =1 #define IAP_DISABLE()   IAP_CONTR = 0; IAP_CMD = 0; IAP_TRIG = 0; IAP_ADDRH = 0xFF; IAP_ADDRL = 0xFF
   21       =1 
   22       =1 void read_flash_bin(uint8_t*  dat , uint32_t add ,int  out_buff_len);
   23       =1 void save_flash_nolib(uint8_t *dat, int length, uint32_t add);
   16          
   17          #define STC32_FLASH_START 0x00000000
   18          #define FIRMWARE_RELATIVE_START 0x0000
   19          #define EEPROM_RELATIVE_START 0x0000
   20          
   21          uint8_t bootloader_version = BOOTLOADER_VERSION;
   22          
   23          typedef void (*pFunction)(void);
   24          
   25          #define APPLICATION_ADDRESS     (uint32_t)(STC32_FLASH_START + FIRMWARE_RELATIVE_START) // 4k
   26          
   27          #define EEPROM_START_ADD         (uint32_t)(STC32_FLASH_START + EEPROM_RELATIVE_START)
   28          #define FLASH_END_ADD           (uint32_t)(STC32_FLASH_START + 0xFFFF)               // 32 k
   29          
   30          
   31          #define CMD_RUN             0x00
   32          #define CMD_PROG_FLASH      0x01
   33          #define CMD_ERASE_FLASH     0x02
   34          #define CMD_READ_FLASH_SIL  0x03
   35          #define CMD_VERIFY_FLASH    0x03
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 29  

   36          #define CMD_VERIFY_FLASH_ARM 0x04
   37          #define CMD_READ_EEPROM     0x04
   38          #define CMD_PROG_EEPROM     0x05
   39          #define CMD_READ_SRAM       0x06
   40          #define CMD_READ_FLASH_ATM  0x07
   41          #define CMD_KEEP_ALIVE      0xFD
   42          #define CMD_SET_ADDRESS     0xFF
   43          #define CMD_SET_BUFFER      0xFE
   44          
   45          
   46          #ifdef USE_P01
   47          
   48          #define input_pin        P01
   49          #define input_port       P0
   50          #define PIN_NUMBER       0
   51          #define PORT_LETTER      0
   52          
   53          #endif
   54          
   55          #ifdef USE_PB4
               // #define input_pin       LL_GPIO_PIN_4
               // #define input_port        GPIOB
               // #define PIN_NUMBER        4
               // #define PORT_LETTER       1
               #endif
   61          
   62          
   63          uint16_t low_pin_count = 0;
   64          char receviedByte;
   65          int receivedCount;
   66          int count = 0;
   67          char messagereceived = 0;
   68          uint16_t invalid_command = 0;
   69          uint16_t address_expected_increment;
   70          int cmd = 0;
   71          char eeprom_req = 0;
   72          int received;
   73          uint8_t port_letter;
   74          
   75          
   76          uint8_t pin_code = 0;
   77          uint8_t deviceInfo[9] = { 0 };      // stm32 device info
   78          
   79          size_t str_len;
   80          char connected = 0;
   81          uint8_t rxBuffer[258];
   82          uint8_t payLoadBuffer[256];
   83          char rxbyte=0;
   84          uint32_t address;
   85          int tick = 0;
   86          
   87          typedef union {
   88              uint8_t bytes[2];
   89              uint16_t word;
   90          } uint8_16_u;
   91          uint16_t len;
   92          uint8_t received_crc_low_byte;
   93          uint8_t received_crc_high_byte;
   94          uint8_t calculated_crc_low_byte;
   95          uint8_t calculated_crc_high_byte;
   96          uint16_t payload_buffer_size;
   97          char incoming_payload_no_command = 0;
   98          
   99          char bootloaderactive = 1;
  100          
  101          uint32_t JumpAddress;
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 30  

  102          // pFunction JumpToApplication;
  103          #define JumpToApplication()   IAP_CONTR = 0x20
  104          
  105          
  106          void SystemClock_Config(void);
  107          //static void MX_GPIO_Init(void);
  108          static void PWMB_Timer_Init(void);
  109          
  110          /* USER CODE BEGIN PFP */
  111          static void GPIO_INPUT_INIT(void);
  112          
  113          void processmessage(void);
  114          void serialwriteChar(char dat);
  115          void sendString(uint8_t dat[], int len);
  116          void recieveBuffer();
  117          
  118          #define BAUDRATE              19200
  119          #define BITTIME          1000000/BAUDRATE
  120          #define HALFBITTIME       500000/BAUDRATE
  121          
  122          //寰癸浣跨ㄥ跺ㄥ寤舵跺芥帮
  123          void delayMicroseconds(uint32_t micros){
  124   1        // TIM2->CNT = 0;
  125   1        PWMB_CNTRH = 0x00;
  126   1        PWMB_CNTRL = 0x00;
  127   1        while (((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) < micros){
  128   2        }
  129   1      }
  130          
  131          void jump(){
  132   1      
  133   1        uint8_t value;
  134   1      
  135   1        EA = 0;
  136   1      
  137   1        IAP_ENABLE();                           //璁剧疆绛寰堕达璁IAP浣锛涓娆″氨澶
  138   1          IAP_READ();                             
  139   1      
  140   1        IAP_ADDRE = (uint8_t)(EEPROM_START_ADD >> 16); 
  141   1        IAP_ADDRH = (uint8_t)(EEPROM_START_ADD >> 8);  
  142   1        IAP_ADDRL = (uint8_t)EEPROM_START_ADD;         
  143   1        IAP_TRIG = 0x5A;
  144   1        IAP_TRIG = 0xA5;                   
  145   1        _nop_();   
  146   1        _nop_();
  147   1        _nop_();
  148   1        _nop_();
  149   1        while(CMD_FAIL);
  150   1      
  151   1        value = IAP_DATA;            //璇诲虹版寰
  152   1      
  153   1        IAP_DISABLE();
  154   1      
  155   1      #ifdef USE_ADC_INPUT
               #else
  157   1        if (value != 0x01){      // check first byte of eeprom to see if its programmed, if not do not jump
  158   2          invalid_command = 0;
  159   2          return;
  160   2        }
  161   1      #endif
  162   1         JumpToApplication();
  163   1      }
  164          
  165          
  166          void makeCrc(uint8_t* pBuff, uint16_t length){
  167   1        int i;
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 31  

  168   1        uint8_t xb;
  169   1        static uint8_16_u CRC_16;
  170   1        
  171   1        CRC_16.word=0;
  172   1        for(i = 0; i < length; i++) {
  173   2          uint8_t j;
  174   2          xb = pBuff[i];
  175   2          for ( j = 0; j < 8; j++)
  176   2          {
  177   3            if (((xb & 0x01) ^ (CRC_16.word & 0x0001)) !=0 ) {
  178   4              CRC_16.word = CRC_16.word >> 1;
  179   4              CRC_16.word = CRC_16.word ^ 0xA001;
  180   4            } else {
  181   4              CRC_16.word = CRC_16.word >> 1;
  182   4            }
  183   3            xb = xb >> 1;
  184   3          }
  185   2        }
  186   1        calculated_crc_low_byte = CRC_16.bytes[0];
  187   1        calculated_crc_high_byte = CRC_16.bytes[1];
  188   1      }
  189          
  190          char checkCrc(uint8_t* pBuff, uint16_t length){
  191   1      
  192   1        char received_crc_low_byte2 = pBuff[length];          // one higher than len in buffer
  193   1        char received_crc_high_byte2 = pBuff[length+1];
  194   1        makeCrc(pBuff,length);
  195   1        if((calculated_crc_low_byte==received_crc_low_byte2)   && (calculated_crc_high_byte==received_crc_high_b
             -yte2)){
  196   2          return 1;
  197   2        }else{
  198   2          return 0;
  199   2        }
  200   1      
  201   1      }
  202          
  203          //寰癸ユ跺濮锛涓杈
  204          void setReceive(void){
  205   1      
  206   1        GPIO_INPUT_INIT();
  207   1        received = 0;
  208   1      
  209   1      }
  210          //寰癸寮濮锛
  211          void setTransmit(void){
  212   1        // LL_GPIO_SetPinMode(input_port, input_pin, LL_GPIO_MODE_OUTPUT);       // set as reciever // clear bit
             -s and set receive bits..
  213   1        P0M0 |= 0x02; P0M1 &= ~0x02;  //ㄦ借
  214   1        P0PU &= ~0x02; P0PD &= ~0x02;   //涓涓
  215   1      }
  216          
  217          void send_ACK(void){
  218   1          setTransmit();
  219   1          serialwriteChar(0x30);             // good ack!
  220   1        setReceive();
  221   1      }
  222          
  223          void send_BAD_ACK(void){
  224   1        setTransmit();
  225   1        serialwriteChar(0xC1);                // bad command message.
  226   1        setReceive();
  227   1      }
  228          
  229          void send_BAD_CRC_ACK(){
  230   1          setTransmit();
  231   1        serialwriteChar(0xC2);                // bad command message.
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 32  

  232   1        setReceive();
  233   1      }
  234          
  235          void sendDeviceInfo(){
  236   1        setTransmit();
  237   1        sendString(deviceInfo,9);
  238   1        setReceive();
  239   1      }
  240          
  241          bool checkAddressWritable(uint32_t address) {
  242   1        return address >= APPLICATION_ADDRESS;
  243   1      }
  244          
  245          void decodeInput(){
  246   1        if(incoming_payload_no_command){
  247   2          len = payload_buffer_size;
  248   2        //  received_crc_low_byte = rxBuffer[len];          // one higher than len in buffer
  249   2        //  received_crc_high_byte = rxBuffer[len+1];
  250   2          if(checkCrc(rxBuffer,len)){
  251   3            int i;
  252   3            memset(payLoadBuffer, 0, sizeof(payLoadBuffer));             // reset buffer
  253   3      
  254   3            for(i = 0; i < len; i++){
  255   4              payLoadBuffer[i]= rxBuffer[i];
  256   4            }
  257   3            send_ACK();
  258   3            incoming_payload_no_command = 0;
  259   3            return;
  260   3          }else{
  261   3            send_BAD_CRC_ACK();
  262   3            return;
  263   3          }
  264   2        }
  265   1      
  266   1        cmd = rxBuffer[0];
  267   1      
  268   1        if(rxBuffer[16] == 0x7d){
  269   2          if(rxBuffer[8] == 13 && rxBuffer[9] == 66){
  270   3            sendDeviceInfo();
  271   3            rxBuffer[20]= 0;
  272   3      
  273   3          }
  274   2          return;
  275   2        }
  276   1      
  277   1        if(rxBuffer[20] == 0x7d){
  278   2          if(rxBuffer[12] == 13 && rxBuffer[13] == 66){
  279   3            sendDeviceInfo();
  280   3            rxBuffer[20]= 0;
  281   3            return;
  282   3          }
  283   2      
  284   2        }
  285   1        if(rxBuffer[40] == 0x7d){
  286   2          if(rxBuffer[32] == 13 && rxBuffer[33] == 66){
  287   3            sendDeviceInfo();
  288   3            rxBuffer[20]= 0;
  289   3            return;
  290   3          }
  291   2        }
  292   1      
  293   1        if(cmd == CMD_RUN){         // starts the main app
  294   2          if((rxBuffer[1] == 0) && (rxBuffer[2] == 0) && (rxBuffer[3] == 0)){
  295   3            invalid_command = 101;
  296   3          }
  297   2        }
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 33  

  298   1      
  299   1        if(cmd == CMD_PROG_FLASH){
  300   2          len = 2;
  301   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  302   3            send_BAD_CRC_ACK();
  303   3      
  304   3            return;
  305   3          }
  306   2      
  307   2          if (!checkAddressWritable(address)) {
  308   3            send_BAD_ACK();
  309   3      
  310   3            return;
  311   3          }
  312   2      
  313   2          save_flash_nolib((uint8_t*)payLoadBuffer, payload_buffer_size,address);
  314   2          send_ACK();
  315   2      
  316   2          return;
  317   2        }
  318   1      
  319   1        if(cmd == CMD_SET_ADDRESS){             //  command set addressinput format is: CMD, 00 , High byte addr
             -ess, Low byte address, crclb ,crchb
  320   2          len = 4;  // package without 2 byte crc
  321   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  322   3            send_BAD_CRC_ACK();
  323   3      
  324   3            return;
  325   3          }
  326   2      
  327   2      
  328   2            // will send Ack 0x30 and read input after transfer out callback
  329   2          invalid_command = 0;
  330   2          address = STC32_FLASH_START + (rxBuffer[2] << 8 | rxBuffer[3]);
  331   2          send_ACK();
  332   2      
  333   2          return;
  334   2        }
  335   1      
  336   1        if(cmd == CMD_SET_BUFFER){        // for writing buffer rx buffer 0 = command byte.  command set address
             -, input , format is CMD, 00 , 00 or 01 (if buffer is 256), buffer_size,
  337   2          len = 4;  // package without 2 byte crc
  338   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  339   3            send_BAD_CRC_ACK();
  340   3      
  341   3            return;
  342   3          }
  343   2      
  344   2              // no ack with command set buffer;
  345   2              if(rxBuffer[2] == 0x01){
  346   3                payload_buffer_size = 256;                          // if nothing in this buffer
  347   3              }else{
  348   3                payload_buffer_size = rxBuffer[3];
  349   3              }
  350   2            incoming_payload_no_command = 1;
  351   2            address_expected_increment = 256;
  352   2              setReceive();
  353   2      
  354   2              return;
  355   2        }
  356   1      
  357   1        if(cmd == CMD_KEEP_ALIVE){
  358   2          len = 2;
  359   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  360   3            send_BAD_CRC_ACK();
  361   3      
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 34  

  362   3            return;
  363   3          }
  364   2      
  365   2            setTransmit();
  366   2          serialwriteChar(0xC1);                // bad command message.
  367   2          setReceive();
  368   2      
  369   2          return;
  370   2        }
  371   1      
  372   1        if(cmd == CMD_ERASE_FLASH){
  373   2          len = 2;
  374   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  375   3            send_BAD_CRC_ACK();
  376   3      
  377   3            return;
  378   3          }
  379   2      
  380   2          if (!checkAddressWritable(address)) {
  381   3            send_BAD_ACK();
  382   3      
  383   3            return;
  384   3          }
  385   2      
  386   2          send_ACK();
  387   2          return;
  388   2        }
  389   1      
  390   1        if(cmd == CMD_READ_EEPROM){
  391   2          eeprom_req = 1;
  392   2        }
  393   1      
  394   1        if(cmd == CMD_READ_FLASH_SIL){     // for sending contents of flash memory at the memory location set in
             - bootloader.c need to still set memory with data from set mem command
  395   2          uint16_t out_buffer_size;
  396   2          uint8_t *read_data;
  397   2          len = 2;
  398   2          if (!checkCrc((uint8_t*)rxBuffer, len)) {
  399   3            send_BAD_CRC_ACK();
  400   3      
  401   3            return;
  402   3          }
  403   2      
  404   2          count++;
  405   2          out_buffer_size = rxBuffer[1];//
  406   2          if(out_buffer_size == 0){
  407   3            out_buffer_size = 256;
  408   3          }
  409   2          address_expected_increment = 128;
  410   2          read_data = (uint8_t*)malloc(out_buffer_size + 3);
  411   2          setTransmit();                            // make buffer 3 larger to fit CRC and ACK
  412   2          memset(read_data, 0, sizeof(read_data));
  413   2              //    read_flash((uint8_t*)read_data , address);                  // make sure read_flash reads t
             -wo less than buffer.
  414   2          read_flash_bin((uint8_t*)read_data , address, out_buffer_size);
  415   2      
  416   2              makeCrc(read_data,out_buffer_size);
  417   2              read_data[out_buffer_size] = calculated_crc_low_byte;
  418   2              read_data[out_buffer_size + 1] = calculated_crc_high_byte;
  419   2              read_data[out_buffer_size + 2] = 0x30;
  420   2              sendString(read_data, out_buffer_size+3);
  421   2      
  422   2          setReceive();
  423   2          free(read_data);
  424   2          return;
  425   2        }
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 35  

  426   1      
  427   1          setTransmit();
  428   1      
  429   1        serialwriteChar(0xC1);                // bad command message.
  430   1        invalid_command++;
  431   1        setReceive();
  432   1      }
  433          
  434          void serialreadChar()
  435          {
  436   1        int bits_to_read;
  437   1        rxbyte=0;
  438   1      
  439   1      
  440   1        PWMB_PSCRL = 0xBF; // set to 1/4mhz
  441   1        PWMB_CNTRH = 0x00;
  442   1        PWMB_CNTRL = 0x00;
  443   1        while(~(input_pin)){ // wait for rx to go high
  444   2          if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 50000){
  445   3              invalid_command = 101;
  446   3              return;
  447   3          }
  448   2        }
  449   1      
  450   1      
  451   1        PWMB_PSCRL = 0x2F; // set Buck to 1MHz
  452   1        PWMB_CNTRH = 0x00;
  453   1        PWMB_CNTRL = 0x00;
  454   1        while(input_pin){   // wait for it go go low
  455   2          if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 250 && messagereceived){
  456   3            return;
  457   3          }
  458   2        }
  459   1      
  460   1        delayMicroseconds(HALFBITTIME);//wait to get the center of bit time
  461   1      
  462   1        bits_to_read = 0;
  463   1        while (bits_to_read < 8) {
  464   2          delayMicroseconds(BITTIME);
  465   2          rxbyte = rxbyte | ((uint8_t)(input_pin) >> PIN_NUMBER) << bits_to_read;
  466   2        bits_to_read++;
  467   2        }
  468   1      
  469   1        delayMicroseconds(HALFBITTIME); //wait till the stop bit time begins
  470   1        messagereceived = 1;
  471   1        receviedByte = rxbyte;
  472   1        //return rxbyte;
  473   1      
  474   1      }
  475          
  476          void serialwriteChar(char dat)
  477          {
  478   1      
  479   1        //BRR 瀵瀛锛芥瑰绠¤舵涓轰靛钩锛瀵瑰瀛 绠¤瀵逛浣 1 稿
             -¤浼涓轰靛钩 0 ㄤ
  480   1        // input_port->BRR = input_pin;; //initiate start bit
  481   1        char bits_to_read = 0;
  482   1      
  483   1        input_pin = 0;          //initiate start bit
  484   1      
  485   1        
  486   1        while (bits_to_read < 8) {
  487   2      
  488   2          delayMicroseconds(BITTIME);
  489   2      
  490   2          if (dat & 0x01) {
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 36  

  491   3            // input_port->BSRR = input_pin;
  492   3            input_pin = 1;
  493   3          }else{
  494   3            // input_port->BRR = input_pin;
  495   3            input_pin = 0;
  496   3          }
  497   2          bits_to_read++;
  498   2          dat = dat >> 1;
  499   2        }
  500   1      
  501   1        delayMicroseconds(BITTIME);
  502   1      
  503   1        // input_port->BSRR = input_pin; //write the stop bit
  504   1      
  505   1      
  506   1        input_pin = 1;          //write the stop bit
  507   1      
  508   1      
  509   1        // if more than one byte a delay is needed after stop bit,
  510   1        //if its the only one no delay, the sendstring function adds delay after each bit
  511   1      
  512   1        //if(cmd == 255 || cmd == 254 || cmd == 1  || incoming_payload_no_command){
  513   1        //
  514   1        //}else{
  515   1        //  delayMicroseconds(BITTIME);
  516   1        //}
  517   1      }
  518          
  519          void sendString(uint8_t *dat, int len){
  520   1        int i;
  521   1        for(i = 0; i < len; i++){
  522   2          serialwriteChar(dat[i]);
  523   2          delayMicroseconds(BITTIME);
  524   2        }
  525   1      }
  526          
  527          void recieveBuffer(void){
  528   1      
  529   1        int i = 0;
  530   1        count = 0;
  531   1        messagereceived = 0;
  532   1        memset(rxBuffer, 0, sizeof(rxBuffer));
  533   1      
  534   1      
  535   1        for(i = 0; i < sizeof(rxBuffer); i++){
  536   2          serialreadChar();
  537   2          if(incoming_payload_no_command){
  538   3            if(count == payload_buffer_size+2){
  539   4              break;
  540   4            }
  541   3            rxBuffer[i] = rxbyte;
  542   3            count++;
  543   3          }else{
  544   3            if(((uint16_t)PWMB_CNTRH << 8 | PWMB_CNTRL) > 250){
  545   4            count = 0;
  546   4            break;
  547   4            }else{
  548   4            rxBuffer[i] = rxbyte;
  549   4            if(i == 257){
  550   5              invalid_command+=20;       // needs one hundred to trigger a jump but will be reset on next set addre
             -ss commmand
  551   5      
  552   5              }
  553   4            }
  554   3          }
  555   2        }
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 37  

  556   1        decodeInput();
  557   1      }
  558          
  559          void update_EEPROM(void){
  560   1        printf("update_EEPROM\n");
  561   1        read_flash_bin(rxBuffer , EEPROM_START_ADD , 48);
  562   1        if(BOOTLOADER_VERSION != rxBuffer[2]){
  563   2          if (rxBuffer[2] == 0xFF || rxBuffer[2] == 0x00){
  564   3            return;
  565   3          }
  566   2          rxBuffer[2] = BOOTLOADER_VERSION;
  567   2          save_flash_nolib(rxBuffer, 48, EEPROM_START_ADD);
  568   2        }
  569   1      }
  570          
  571          void checkForSignal(void){
  572   1        //uint8_t floating_or_signal= 0;
  573   1        // LL_GPIO_SetPinPull(input_port, input_pin, LL_GPIO_PULL_DOWN);
  574   1        int i;
  575   1      
  576   1        P0PU &= ~0x02; //抽涓甸
  577   1        P0PD |= 0x02; //寮涓甸
  578   1      
  579   1        delayMicroseconds(500);
  580   1      
  581   1        for(i = 0 ; i < 500; i ++){
  582   2      
  583   2          if(~input_pin){
  584   3            low_pin_count++;
  585   3          }else{
  586   3        //   high_pin_count++;
  587   3          }
  588   2          delayMicroseconds(10);
  589   2        }
  590   1      
  591   1        if(low_pin_count == 0){
  592   2          return;           // all high while pin is pulled low, bootloader signal
  593   2        }
  594   1      
  595   1        low_pin_count = 0;
  596   1      
  597   1        P0PU &= ~0x02; //抽涓甸
  598   1        P0PD &= ~0x02; //抽涓甸 
  599   1        // LL_GPIO_SetPinPull(input_port, input_pin, LL_GPIO_PULL_NO);
  600   1        delayMicroseconds(500);
  601   1      
  602   1        for(i = 0 ; i < 500; i ++){
  603   2          if(~input_pin){
  604   3            low_pin_count++;
  605   3          }
  606   2          delayMicroseconds(10);
  607   2        }
  608   1      
  609   1        if(low_pin_count == 0){
  610   2          return;            // when floated all
  611   2        }
  612   1      
  613   1        if(low_pin_count > 0){
  614   2          jump();
  615   2        }
  616   1      }
  617          
  618          
  619          void Uart1_Init(void) //921600bps@48MHz
  620          {
  621   1        SCON = 0x50;    //8浣版,娉㈢圭
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 38  

  622   1        AUXR |= 0x01;   //涓插1╁跺2涓烘尝圭
  623   1        AUXR |= 0x04;   //瀹跺ㄦ堕1T妯″
  624   1        T2L = 0xF3;     //璁剧疆瀹跺濮
  625   1        T2H = 0xFF;     //璁剧疆瀹跺濮
  626   1        AUXR |= 0x10;   //瀹跺2寮濮璁℃
  627   1      }
  628          
  629          
  630          
  631          int main(void)
  632          {
  633   1      
  634   1        //Prevent warnings
  635   1        (void)bootloader_version;
*** WARNING C138 IN LINE 635 OF Bootloader\src\main.c: expression with possibly no effect
  636   1      
  637   1        Uart1_Init();
  638   1      
  639   1        P3M0 |= 0x03; P3M1 &= ~0x03; 
  640   1        P2M0 |= 0x03; P2M1 &= ~0x03; 
  641   1      
  642   1        IAP_TPS = 48;
  643   1      
  644   1          SystemClock_Config();
  645   1        PWMB_Timer_Init();
  646   1      
  647   1          GPIO_INPUT_INIT();     // init the pin with a pulldown
  648   1      
  649   1          checkForSignal();
  650   1        
  651   1        P0PD &= ~0x02;
  652   1        P0PU |= 0x02;     //涓杈
  653   1      
  654   1      #ifdef USE_ADC_INPUT  // go right to application
                   jump();
               #endif
  657   1          deviceInfo[3] = pin_code;
  658   1          update_EEPROM();
  659   1      
  660   1      //  sendDeviceInfo();
  661   1          while (1)
  662   1          {
  663   2          
  664   2            recieveBuffer();
  665   2          printf("invalid_command: %u\n", invalid_command);
  666   2            if (invalid_command > 100){
  667   3              jump();
  668   3            printf("jump\n");
  669   3            }
  670   2          }
  671   1      }
  672          
  673          
  674          
  675          void SystemClock_Config(void)
  676          {
  677   1        EA = 0;
  678   1      
  679   1        CKCON = 0x00;           // 璁剧疆澶ㄦ版荤嚎涓烘蹇
  680   1        WTST = 1;                 // 璁剧疆绋搴浠ｇ绛寰帮璧间负0灏CPUц绋搴搴璁
             -缃涓烘蹇
  681   1        P_SW2 = 0x80;         // 寮规板璁块
  682   1      
  683   1        CLKDIV = 0x04;      //涓绘堕MCLK杈哄扮郴缁堕(SYSCLK)棰1
  684   1             
  685   1        IRTRIM = CHIPID12;        //ㄦ堕婧24M
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 39  

  686   1        HIRCSEL1 = 1;
  687   1        HIRCSEL0 = 0;       //27Mhz棰娈
  688   1      
  689   1        HIRCCR = 0x80;
  690   1      //  while (!(HIRCCR & 0x01));
  691   1        
  692   1        // MCLKOCR = 72;          //棰72,杈烘堕棰
  693   1      
  694   1        CLKSEL = 0x40;      //PLL,楂IO锛绯荤堕婧稿宠剧疆(╁IRC浣涓虹郴缁堕)
  695   1      
  696   1        USBCLK &= 0x0F;
  697   1        USBCLK |= 0xA0;
  698   1        NOP(5);         //绛寰堕绋冲
  699   1      
  700   1        //PLL浜х96Mhz堕
  701   1      
  702   1        CLKDIV = 0X01;      //涓绘堕MCLK杈哄扮郴缁堕(SYSCLK)棰1
  703   1      
  704   1        CLKSEL |= 0x08;     //MCLKPLL/2涓烘堕婧->48Mhz
  705   1      
  706   1        HSCLKDIV = 0x01;    //楂PWM,SPI,I2S,TFPU堕96MHz
  707   1      
  708   1        USBCKS = 1;       
  709   1        USBCKS2 = 0;      //USB堕48Mhz
  710   1      
  711   1        EA = 1;
  712   1      }
  713          
  714          
  715          static void PWMB_Timer_Init(void)
  716          {
  717   1      //变寮楂PWM浠PWMB堕婧涓48Mhz
  718   1      
  719   1        PWMB_ENO = 0x00;    //绂姝PWMBPWM杈
  720   1        PWMB_IOAUX = 0x00;    //绂姝PWMB
  721   1      
  722   1        PWMB_ARRH = 0xFF;
  723   1        PWMB_ARRL = 0xFF;   //璁剧疆PWMBㄦ涓65535
  724   1        PWMB_CNTRH = 0x00;
  725   1        PWMB_CNTRL = 0x00;    //娓惰℃板
  726   1        PWMB_PSCRH = 0x00;    
  727   1        PWMB_PSCRL = 23;    //PWMB堕婧棰1Mhz
  728   1        PWMB_IER = 0x00;    //绂姝PWMB涓
  729   1        PWMB_CR1 = 0x01;    //浣胯借℃板
  730   1      }
  731          
  732          
  733          
  734          static void GPIO_INPUT_INIT(void)
  735          {
  736   1      #ifdef USE_PB4
               #endif
  738   1      #ifdef USE_PA2
               #endif
  740   1      
  741   1          P0M0 &= ~0x02; 
  742   1        P0M1 |= 0x02;   
  743   1          P0NCS &= ~0x02; 
  744   1          P0IE |= 0x02; 
  745   1        P0PU |= 0x02; 
  746   1        //楂讳杈
  747   1      }
  748          
  749          
  750          #pragma FUNCTIONS (static)
  751          char putchar(char c)
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 40  

  752          {
  753   1        // serialwriteChar(c);
  754   1        SBUF = c;
  755   1        while (!TI);
  756   1        TI = 0;
  757   1        return c;
  758   1      }
  759          
  760          
  761          
  762          
  763          
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 41  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


;       FUNCTION delayMicroseconds?_ (BEGIN)
                                                ; SOURCE LINE # 123
000000 CA1B           PUSH     DR4
                                                ; SOURCE LINE # 125
000002 E4             CLR      A                ; A=R11
000003 7E34FEEE       MOV      WR6,#0FEEEH
000007 7E24007E       MOV      WR4,#07EH
00000B 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 126
00000E E4             CLR      A                ; A=R11
00000F 7E34FEEF       MOV      WR6,#0FEEFH
000013 7E24007E       MOV      WR4,#07EH
000017 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 127
                                                ; SOURCE LINE # 128
               ?C0001:
00001A 7E34FEEE       MOV      WR6,#0FEEEH
00001E 7E24007E       MOV      WR4,#07EH
000022 7E1B70         MOV      R7,@DR4
000025 0A07           MOVZ     WR0,R7
000027 7C01           MOV      R0,R1
000029 6C11           XRL      R1,R1
00002B 7E34FEEF       MOV      WR6,#0FEEFH
00002F 7E24007E       MOV      WR4,#07EH
000033 7E1B70         MOV      R7,@DR4
000036 0A17           MOVZ     WR2,R7
000038 4D10           ORL      WR2,WR0
00003A 6D00           XRL      WR0,WR0
00003C 693FFFFF       MOV      WR6,@DR60-0x1    ; micros
000040 692FFFFD       MOV      WR4,@DR60-0x3    ; micros
000044 BF01           CMP      DR0,DR4
000046 40D2           JC       ?C0001
                                                ; SOURCE LINE # 129
000048 1BFE           DEC      DR60,#04H
00004A 22             RET      
;       FUNCTION delayMicroseconds?_ (END)

;       FUNCTION jump?_ (BEGIN)
                                                ; SOURCE LINE # 131
000000 0BFC           INC      DR60,#01H
                                                ; SOURCE LINE # 135
000002 C3             CLR      C
000003 C2AF           CLR      EA
                                                ; SOURCE LINE # 137
000005 D3             SETB     C
000006 A9D7C7         SETB     IAPEN
                                                ; SOURCE LINE # 138
000009 7401           MOV      A,#01H           ; A=R11
00000B F5C5           MOV      IAP_CMD,A        ; A=R11
                                                ; SOURCE LINE # 140
00000D E4             CLR      A                ; A=R11
00000E F5F6           MOV      IAP_ADDRE,A      ; A=R11
                                                ; SOURCE LINE # 141
000010 E4             CLR      A                ; A=R11
000011 F5C3           MOV      IAP_ADDRH,A      ; A=R11
                                                ; SOURCE LINE # 142
000013 E4             CLR      A                ; A=R11
000014 F5C4           MOV      IAP_ADDRL,A      ; A=R11
                                                ; SOURCE LINE # 143
000016 745A           MOV      A,#05AH          ; A=R11
000018 F5C6           MOV      IAP_TRIG,A       ; A=R11
                                                ; SOURCE LINE # 144
00001A 74A5           MOV      A,#0A5H          ; A=R11
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 42  

00001C F5C6           MOV      IAP_TRIG,A       ; A=R11
                                                ; SOURCE LINE # 145
00001E 00             NOP      
                                                ; SOURCE LINE # 146
00001F 00             NOP      
                                                ; SOURCE LINE # 147
000020 00             NOP      
                                                ; SOURCE LINE # 148
000021 00             NOP      
                                                ; SOURCE LINE # 149
               ?C0005:
000022 A924C7FC       JB       CMD_FAIL,?C0005
                                                ; SOURCE LINE # 151
000026 E5C2           MOV      A,IAP_DATA       ; A=R11
000028 7AFBB0         MOV      @DR60,R11        ; value
                                                ; SOURCE LINE # 153
00002B E4             CLR      A                ; A=R11
00002C F5C7           MOV      IAP_CONTR,A      ; A=R11
00002E E4             CLR      A                ; A=R11
00002F F5C5           MOV      IAP_CMD,A        ; A=R11
000031 E4             CLR      A                ; A=R11
000032 F5C6           MOV      IAP_TRIG,A       ; A=R11
000034 74FF           MOV      A,#0FFH          ; A=R11
000036 F5C3           MOV      IAP_ADDRH,A      ; A=R11
000038 74FF           MOV      A,#0FFH          ; A=R11
00003A F5C4           MOV      IAP_ADDRL,A      ; A=R11
                                                ; SOURCE LINE # 157
00003C 7EFBB0         MOV      R11,@DR60        ; value
00003F BEB001         CMP      R11,#01H         ; A=R11
000042 6808           JE       ?C0009
                                                ; SOURCE LINE # 158
000044 6D33           XRL      WR6,WR6
000046 7A370000    R  MOV      invalid_command,WR6
                                                ; SOURCE LINE # 159
00004A 8004           SJMP     ?C0010
                                                ; SOURCE LINE # 160
               ?C0009:
                                                ; SOURCE LINE # 162
00004C 7420           MOV      A,#020H          ; A=R11
00004E F5C7           MOV      IAP_CONTR,A      ; A=R11
                                                ; SOURCE LINE # 163
               ?C0010:
000050 1BFC           DEC      DR60,#01H
000052 22             RET      
;       FUNCTION jump?_ (END)

;       FUNCTION makeCrc?_ (BEGIN)
                                                ; SOURCE LINE # 166
000000 CA39           PUSH     WR6
000002 CA0B           PUSH     DR0
000004 0BFE           INC      DR60,#04H
                                                ; SOURCE LINE # 171
000006 6D33           XRL      WR6,WR6
000008 7A370000    R  MOV      CRC_16,WR6
                                                ; SOURCE LINE # 172
00000C 6D33           XRL      WR6,WR6
00000E 793FFFFF       MOV      @DR60-0x1,WR6    ; i
000012 020000      R  LJMP     ?C0013
               ?C0014:
                                                ; SOURCE LINE # 174
000015 691FFFFF       MOV      WR2,@DR60-0x1    ; i
000019 693FFFFB       MOV      WR6,@DR60-0x5    ; pBuff
00001D 692FFFF9       MOV      WR4,@DR60-0x7    ; pBuff
000021 2D31           ADD      WR6,WR2
000023 7E1B70         MOV      R7,@DR4
000026 397FFFFE       MOV      @DR60-0x2,R7     ; xb
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 43  

                                                ; SOURCE LINE # 175
00002A E4             CLR      A                ; A=R11
00002B 39BFFFFD       MOV      @DR60-0x3,R11    ; j
00002F 8058           SJMP     ?C0018
               ?C0019:
                                                ; SOURCE LINE # 177
000031 6D22           XRL      WR4,WR4
000033 7E370000    R  MOV      WR6,CRC_16
000037 7E140001       MOV      WR2,#01H
00003B 5D13           ANL      WR2,WR6
00003D 296FFFFE       MOV      R6,@DR60-0x2     ; xb
000041 7E7001         MOV      R7,#01H
000044 5C76           ANL      R7,R6
000046 0A37           MOVZ     WR6,R7
000048 6D31           XRL      WR6,WR2
00004A BD32           CMP      WR6,WR4
00004C 681A           JE       ?C0021
                                                ; SOURCE LINE # 178
00004E 7E370000    R  MOV      WR6,CRC_16
000052 1E34           SRL      WR6
000054 7A370000    R  MOV      CRC_16,WR6
                                                ; SOURCE LINE # 179
000058 7E24A001       MOV      WR4,#0A001H
00005C 7E370000    R  MOV      WR6,CRC_16
000060 6D32           XRL      WR6,WR4
000062 7A370000    R  MOV      CRC_16,WR6
                                                ; SOURCE LINE # 180
000066 800A           SJMP     ?C0022
               ?C0021:
                                                ; SOURCE LINE # 181
000068 7E370000    R  MOV      WR6,CRC_16
00006C 1E34           SRL      WR6
00006E 7A370000    R  MOV      CRC_16,WR6
                                                ; SOURCE LINE # 182
               ?C0022:
                                                ; SOURCE LINE # 183
000072 297FFFFE       MOV      R7,@DR60-0x2     ; xb
000076 1E70           SRL      R7
000078 397FFFFE       MOV      @DR60-0x2,R7     ; xb
                                                ; SOURCE LINE # 184
00007C 296FFFFD       MOV      R6,@DR60-0x3     ; j
000080 7E7001         MOV      R7,#01H
000083 2C76           ADD      R7,R6
000085 397FFFFD       MOV      @DR60-0x3,R7     ; j
               ?C0018:
000089 29AFFFFD       MOV      R10,@DR60-0x3    ; j
00008D 7408           MOV      A,#08H           ; A=R11
00008F BCAB           CMP      R10,R11          ; A=R11
000091 409E           JC       ?C0019
                                                ; SOURCE LINE # 185
000093 692FFFFF       MOV      WR4,@DR60-0x1    ; i
000097 7E340001       MOV      WR6,#01H
00009B 2D32           ADD      WR6,WR4
00009D 793FFFFF       MOV      @DR60-0x1,WR6    ; i
               ?C0013:
0000A1 692FFFFF       MOV      WR4,@DR60-0x1    ; i
0000A5 693FFFF7       MOV      WR6,@DR60-0x9    ; length
0000A9 BD23           CMP      WR4,WR6
0000AB 5003        R  JNC      $ + 5H
0000AD 020000      R  LJMP     ?C0014
                                                ; SOURCE LINE # 186
0000B0 7E730000    R  MOV      R7,CRC_16
0000B4 7A730000    R  MOV      calculated_crc_low_byte,R7
                                                ; SOURCE LINE # 187
0000B8 7E730000    R  MOV      R7,CRC_16+1
0000BC 7A730000    R  MOV      calculated_crc_high_byte,R7
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 44  

                                                ; SOURCE LINE # 188
0000C0 9EF8000A       SUB      DR60,#0AH
0000C4 22             RET      
;       FUNCTION makeCrc?_ (END)

;       FUNCTION checkCrc?_ (BEGIN)
                                                ; SOURCE LINE # 190
000000 CA39           PUSH     WR6
000002 CA0B           PUSH     DR0
000004 0BFD           INC      DR60,#02H
                                                ; SOURCE LINE # 192
000006 691FFFF9       MOV      WR2,@DR60-0x7    ; length
00000A 693FFFFD       MOV      WR6,@DR60-0x3    ; pBuff
00000E 692FFFFB       MOV      WR4,@DR60-0x5    ; pBuff
000012 2D31           ADD      WR6,WR2
000014 7E1B70         MOV      R7,@DR4
000017 7AFB70         MOV      @DR60,R7         ; received_crc_low_byte2
                                                ; SOURCE LINE # 193
00001A 691FFFF9       MOV      WR2,@DR60-0x7    ; length
00001E 693FFFFD       MOV      WR6,@DR60-0x3    ; pBuff
000022 692FFFFB       MOV      WR4,@DR60-0x5    ; pBuff
000026 2D31           ADD      WR6,WR2
000028 0B34           INC      WR6,#01H
00002A 7E1B70         MOV      R7,@DR4
00002D 397FFFFF       MOV      @DR60-0x1,R7     ; received_crc_high_byte2
                                                ; SOURCE LINE # 194
000031 691FFFFD       MOV      WR2,@DR60-0x3    ; pBuff
000035 690FFFFB       MOV      WR0,@DR60-0x5    ; pBuff
000039 693FFFF9       MOV      WR6,@DR60-0x7    ; length
00003D 120000      R  LCALL    makeCrc?_
                                                ; SOURCE LINE # 195
000040 7EFB60         MOV      R6,@DR60         ; received_crc_low_byte2
000043 7E730000    R  MOV      R7,calculated_crc_low_byte
000047 BC76           CMP      R7,R6
000049 7810           JNE      ?C0023
00004B 296FFFFF       MOV      R6,@DR60-0x1     ; received_crc_high_byte2
00004F 7E730000    R  MOV      R7,calculated_crc_high_byte
000053 BC76           CMP      R7,R6
000055 7804           JNE      ?C0023
                                                ; SOURCE LINE # 196
000057 7401           MOV      A,#01H           ; A=R11
000059 8001           SJMP     ?C0024
                                                ; SOURCE LINE # 197
               ?C0023:
                                                ; SOURCE LINE # 198
00005B E4             CLR      A                ; A=R11
                                                ; SOURCE LINE # 199
                                                ; SOURCE LINE # 201
               ?C0024:
00005C 9EF80008       SUB      DR60,#08H
000060 22             RET      
;       FUNCTION checkCrc?_ (END)

;       FUNCTION setReceive?_ (BEGIN)
                                                ; SOURCE LINE # 204
                                                ; SOURCE LINE # 206
000000 120000      R  LCALL    GPIO_INPUT_INIT?_
                                                ; SOURCE LINE # 207
000003 6D33           XRL      WR6,WR6
000005 7A370000    R  MOV      received,WR6
                                                ; SOURCE LINE # 209
000009 22             RET      
;       FUNCTION setReceive?_ (END)

;       FUNCTION setTransmit?_ (BEGIN)
                                                ; SOURCE LINE # 211
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 45  

                                                ; SOURCE LINE # 213
000000 439402         ORL      P0M0,#02H
000003 5393FD         ANL      P0M1,#0FDH
                                                ; SOURCE LINE # 214
000006 74FD           MOV      A,#0FDH          ; A=R11
000008 7E14FE10       MOV      WR2,#0FE10H
00000C 7E04007E       MOV      WR0,#07EH
000010 7E0B70         MOV      R7,@DR0
000013 5C7B           ANL      R7,R11           ; A=R11
000015 7A0B70         MOV      @DR0,R7
000018 74FD           MOV      A,#0FDH          ; A=R11
00001A 7E14FE40       MOV      WR2,#0FE40H
00001E 7E04007E       MOV      WR0,#07EH
000022 7E0B70         MOV      R7,@DR0
000025 5C7B           ANL      R7,R11           ; A=R11
000027 7A0B70         MOV      @DR0,R7
                                                ; SOURCE LINE # 215
00002A 22             RET      
;       FUNCTION setTransmit?_ (END)

;       FUNCTION send_ACK?_ (BEGIN)
                                                ; SOURCE LINE # 217
                                                ; SOURCE LINE # 218
000000 120000      R  LCALL    setTransmit?_
                                                ; SOURCE LINE # 219
000003 7430           MOV      A,#030H          ; A=R11
000005 120000      R  LCALL    serialwriteChar?_
                                                ; SOURCE LINE # 220
000008 120000      R  LCALL    setReceive?_
                                                ; SOURCE LINE # 221
00000B 22             RET      
;       FUNCTION send_ACK?_ (END)

;       FUNCTION send_BAD_ACK?_ (BEGIN)
                                                ; SOURCE LINE # 223
                                                ; SOURCE LINE # 224
000000 120000      R  LCALL    setTransmit?_
                                                ; SOURCE LINE # 225
000003 74C1           MOV      A,#0C1H          ; A=R11
000005 120000      R  LCALL    serialwriteChar?_
                                                ; SOURCE LINE # 226
000008 120000      R  LCALL    setReceive?_
                                                ; SOURCE LINE # 227
00000B 22             RET      
;       FUNCTION send_BAD_ACK?_ (END)

;       FUNCTION send_BAD_CRC_ACK?_ (BEGIN)
                                                ; SOURCE LINE # 229
                                                ; SOURCE LINE # 230
000000 120000      R  LCALL    setTransmit?_
                                                ; SOURCE LINE # 231
000003 74C2           MOV      A,#0C2H          ; A=R11
000005 120000      R  LCALL    serialwriteChar?_
                                                ; SOURCE LINE # 232
000008 120000      R  LCALL    setReceive?_
                                                ; SOURCE LINE # 233
00000B 22             RET      
;       FUNCTION send_BAD_CRC_ACK?_ (END)

;       FUNCTION sendDeviceInfo?_ (BEGIN)
                                                ; SOURCE LINE # 235
                                                ; SOURCE LINE # 236
000000 120000      R  LCALL    setTransmit?_
                                                ; SOURCE LINE # 237
000003 7E000000    R  MOV      DR0,#WORD0 deviceInfo
000007 7E340009       MOV      WR6,#09H
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 46  

00000B 120000      R  LCALL    sendString?_
                                                ; SOURCE LINE # 238
00000E 120000      R  LCALL    setReceive?_
                                                ; SOURCE LINE # 239
000011 22             RET      
;       FUNCTION sendDeviceInfo?_ (END)

;       FUNCTION checkAddressWritable?_ (BEGIN)
                                                ; SOURCE LINE # 241
000000 CA1B           PUSH     DR4
                                                ; SOURCE LINE # 242
000002 693FFFFF       MOV      WR6,@DR60-0x1    ; address
000006 692FFFFD       MOV      WR4,@DR60-0x3    ; address
00000A BE180000       CMP      DR4,#00H
00000E 4003           JC       ?C0027
000010 D3             SETB     C
000011 8001           SJMP     ?C0028
               ?C0027:
000013 C3             CLR      C
               ?C0028:
                                                ; SOURCE LINE # 243
000014 1BFE           DEC      DR60,#04H
000016 22             RET      
;       FUNCTION checkAddressWritable?_ (END)

;       FUNCTION decodeInput?_ (BEGIN)
                                                ; SOURCE LINE # 245
000000 2EF80008       ADD      DR60,#08H
                                                ; SOURCE LINE # 246
000004 7EB30000    R  MOV      R11,incoming_payload_no_command
000008 BEB000         CMP      R11,#00H         ; A=R11
00000B 6871           JE       ?C0029
                                                ; SOURCE LINE # 247
00000D 7E370000    R  MOV      WR6,payload_buffer_size
000011 7A370000    R  MOV      len,WR6
                                                ; SOURCE LINE # 250
000015 7E000000    R  MOV      DR0,#WORD0 rxBuffer
000019 7E370000    R  MOV      WR6,len
00001D 120000      R  LCALL    checkCrc?_
000020 BEB000         CMP      R11,#00H         ; A=R11
000023 6853           JE       ?C0030
                                                ; SOURCE LINE # 252
000025 7E000000    R  MOV      DR0,#WORD0 payLoadBuffer
000029 7E340100       MOV      WR6,#0100H
00002D E4             CLR      A                ; A=R11
00002E 120000      E  LCALL    memset?_
                                                ; SOURCE LINE # 254
000031 6D33           XRL      WR6,WR6
000033 793FFFF9       MOV      @DR60-0x7,WR6    ; i
000037 8028           SJMP     ?C0033
               ?C0034:
                                                ; SOURCE LINE # 255
000039 692FFFF9       MOV      WR4,@DR60-0x7    ; i
00003D 7E340000    R  MOV      WR6,#WORD0 rxBuffer
000041 2D32           ADD      WR6,WR4
000043 7E3950         MOV      R5,@WR6
000046 691FFFF9       MOV      WR2,@DR60-0x7    ; i
00004A 7E340000    R  MOV      WR6,#WORD0 payLoadBuffer
00004E 2D31           ADD      WR6,WR2
000050 7A3950         MOV      @WR6,R5
                                                ; SOURCE LINE # 256
000053 692FFFF9       MOV      WR4,@DR60-0x7    ; i
000057 7E340001       MOV      WR6,#01H
00005B 2D32           ADD      WR6,WR4
00005D 793FFFF9       MOV      @DR60-0x7,WR6    ; i
               ?C0033:
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 47  

000061 692FFFF9       MOV      WR4,@DR60-0x7    ; i
000065 7E370000    R  MOV      WR6,len
000069 BD23           CMP      WR4,WR6
00006B 40CC           JC       ?C0034
                                                ; SOURCE LINE # 257
00006D 120000      R  LCALL    send_ACK?_
                                                ; SOURCE LINE # 258
000070 E4             CLR      A                ; A=R11
000071 7AB30000    R  MOV      incoming_payload_no_command,R11
                                                ; SOURCE LINE # 259
000075 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 260
               ?C0030:
                                                ; SOURCE LINE # 261
000078 120000      R  LCALL    send_BAD_CRC_ACK?_
                                                ; SOURCE LINE # 262
00007B 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 263
                                                ; SOURCE LINE # 264
               ?C0029:
                                                ; SOURCE LINE # 266
00007E 7E730000    R  MOV      R7,rxBuffer
000082 0A37           MOVZ     WR6,R7
000084 7A370000    R  MOV      cmd,WR6
                                                ; SOURCE LINE # 268
000088 7EB30000    R  MOV      R11,rxBuffer+16  ; A=R11
00008C BEB07D         CMP      R11,#07DH        ; A=R11
00008F 7823           JNE      ?C0038
                                                ; SOURCE LINE # 269
000091 7EB30000    R  MOV      R11,rxBuffer+8   ; A=R11
000095 BEB00D         CMP      R11,#0DH         ; A=R11
000098 6803        R  JE       $ + 5H
00009A 020000      R  LJMP     ?C0036
00009D 7EB30000    R  MOV      R11,rxBuffer+9   ; A=R11
0000A1 BEB042         CMP      R11,#042H        ; A=R11
0000A4 6803        R  JE       $ + 5H
0000A6 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 270
0000A9 120000      R  LCALL    sendDeviceInfo?_
                                                ; SOURCE LINE # 271
0000AC E4             CLR      A                ; A=R11
0000AD 7AB30000    R  MOV      rxBuffer+20,R11  ; A=R11
                                                ; SOURCE LINE # 273
                                                ; SOURCE LINE # 274
0000B1 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 275
               ?C0038:
                                                ; SOURCE LINE # 277
0000B4 7EB30000    R  MOV      R11,rxBuffer+20  ; A=R11
0000B8 BEB07D         CMP      R11,#07DH        ; A=R11
0000BB 781D           JNE      ?C0040
                                                ; SOURCE LINE # 278
0000BD 7EB30000    R  MOV      R11,rxBuffer+12  ; A=R11
0000C1 BEB00D         CMP      R11,#0DH         ; A=R11
0000C4 7814           JNE      ?C0040
0000C6 7EB30000    R  MOV      R11,rxBuffer+13  ; A=R11
0000CA BEB042         CMP      R11,#042H        ; A=R11
0000CD 780B           JNE      ?C0040
                                                ; SOURCE LINE # 279
0000CF 120000      R  LCALL    sendDeviceInfo?_
                                                ; SOURCE LINE # 280
0000D2 E4             CLR      A                ; A=R11
0000D3 7AB30000    R  MOV      rxBuffer+20,R11  ; A=R11
                                                ; SOURCE LINE # 281
0000D7 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 282
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 48  

               ?C0040:
                                                ; SOURCE LINE # 285
0000DA 7EB30000    R  MOV      R11,rxBuffer+40  ; A=R11
0000DE BEB07D         CMP      R11,#07DH        ; A=R11
0000E1 781D           JNE      ?C0042
                                                ; SOURCE LINE # 286
0000E3 7EB30000    R  MOV      R11,rxBuffer+32  ; A=R11
0000E7 BEB00D         CMP      R11,#0DH         ; A=R11
0000EA 7814           JNE      ?C0042
0000EC 7EB30000    R  MOV      R11,rxBuffer+33  ; A=R11
0000F0 BEB042         CMP      R11,#042H        ; A=R11
0000F3 780B           JNE      ?C0042
                                                ; SOURCE LINE # 287
0000F5 120000      R  LCALL    sendDeviceInfo?_
                                                ; SOURCE LINE # 288
0000F8 E4             CLR      A                ; A=R11
0000F9 7AB30000    R  MOV      rxBuffer+20,R11  ; A=R11
                                                ; SOURCE LINE # 289
0000FD 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 290
               ?C0042:
                                                ; SOURCE LINE # 293
000100 6D22           XRL      WR4,WR4
000102 7E370000    R  MOV      WR6,cmd
000106 BD32           CMP      WR6,WR4
000108 7823           JNE      ?C0044
                                                ; SOURCE LINE # 294
00010A 7EB30000    R  MOV      R11,rxBuffer+1   ; A=R11
00010E BEB000         CMP      R11,#00H         ; A=R11
000111 781A           JNE      ?C0044
000113 7EB30000    R  MOV      R11,rxBuffer+2   ; A=R11
000117 BEB000         CMP      R11,#00H         ; A=R11
00011A 7811           JNE      ?C0044
00011C 7EB30000    R  MOV      R11,rxBuffer+3   ; A=R11
000120 BEB000         CMP      R11,#00H         ; A=R11
000123 7808           JNE      ?C0044
                                                ; SOURCE LINE # 295
000125 7E340065       MOV      WR6,#065H
000129 7A370000    R  MOV      invalid_command,WR6
                                                ; SOURCE LINE # 296
               ?C0044:
                                                ; SOURCE LINE # 299
00012D 7E270000    R  MOV      WR4,cmd
000131 7E340001       MOV      WR6,#01H
000135 BD23           CMP      WR4,WR6
000137 7846           JNE      ?C0046
                                                ; SOURCE LINE # 300
000139 7E340002       MOV      WR6,#02H
00013D 7A370000    R  MOV      len,WR6
                                                ; SOURCE LINE # 301
000141 7E000000    R  MOV      DR0,#WORD0 rxBuffer
000145 7E370000    R  MOV      WR6,len
000149 120000      R  LCALL    checkCrc?_
00014C BEB000         CMP      R11,#00H         ; A=R11
00014F 7806           JNE      ?C0047
                                                ; SOURCE LINE # 302
000151 120000      R  LCALL    send_BAD_CRC_ACK?_
                                                ; SOURCE LINE # 304
000154 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 305
               ?C0047:
                                                ; SOURCE LINE # 307
000157 7E1F0000    R  MOV      DR4,address
00015B 120000      R  LCALL    checkAddressWritable?_
00015E 4006           JC       ?C0048
                                                ; SOURCE LINE # 308
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 49  

000160 120000      R  LCALL    send_BAD_ACK?_
                                                ; SOURCE LINE # 310
000163 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 311
               ?C0048:
                                                ; SOURCE LINE # 313
000166 7E1F0000    R  MOV      DR4,address
00016A CA1B           PUSH     DR4
00016C 7E370000    R  MOV      WR6,payload_buffer_size
000170 7E000000    R  MOV      DR0,#WORD0 payLoadBuffer
000174 120000      E  LCALL    save_flash_nolib?_
000177 1BFE           DEC      DR60,#04H
                                                ; SOURCE LINE # 314
000179 120000      R  LCALL    send_ACK?_
                                                ; SOURCE LINE # 316
00017C 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 317
               ?C0046:
                                                ; SOURCE LINE # 319
00017F 7E270000    R  MOV      WR4,cmd
000183 7E3400FF       MOV      WR6,#0FFH
000187 BD23           CMP      WR4,WR6
000189 7842           JNE      ?C0049
                                                ; SOURCE LINE # 320
00018B 7E340004       MOV      WR6,#04H
00018F 7A370000    R  MOV      len,WR6
                                                ; SOURCE LINE # 321
000193 7E000000    R  MOV      DR0,#WORD0 rxBuffer
000197 7E370000    R  MOV      WR6,len
00019B 120000      R  LCALL    checkCrc?_
00019E BEB000         CMP      R11,#00H         ; A=R11
0001A1 7806           JNE      ?C0050
                                                ; SOURCE LINE # 322
0001A3 120000      R  LCALL    send_BAD_CRC_ACK?_
                                                ; SOURCE LINE # 324
0001A6 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 325
               ?C0050:
                                                ; SOURCE LINE # 329
0001A9 6D33           XRL      WR6,WR6
0001AB 7A370000    R  MOV      invalid_command,WR6
                                                ; SOURCE LINE # 330
0001AF 7E730000    R  MOV      R7,rxBuffer+2
0001B3 0A27           MOVZ     WR4,R7
0001B5 7C45           MOV      R4,R5
0001B7 6C55           XRL      R5,R5
0001B9 7E730000    R  MOV      R7,rxBuffer+3
0001BD 0A37           MOVZ     WR6,R7
0001BF 4D32           ORL      WR6,WR4
0001C1 6D22           XRL      WR4,WR4
0001C3 7A1F0000    R  MOV      address,DR4
                                                ; SOURCE LINE # 331
0001C7 120000      R  LCALL    send_ACK?_
                                                ; SOURCE LINE # 333
0001CA 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 334
               ?C0049:
                                                ; SOURCE LINE # 336
0001CD 7E270000    R  MOV      WR4,cmd
0001D1 7E3400FE       MOV      WR6,#0FEH
0001D5 BD23           CMP      WR4,WR6
0001D7 784F           JNE      ?C0051
                                                ; SOURCE LINE # 337
0001D9 7E340004       MOV      WR6,#04H
0001DD 7A370000    R  MOV      len,WR6
                                                ; SOURCE LINE # 338
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 50  

0001E1 7E000000    R  MOV      DR0,#WORD0 rxBuffer
0001E5 7E370000    R  MOV      WR6,len
0001E9 120000      R  LCALL    checkCrc?_
0001EC BEB000         CMP      R11,#00H         ; A=R11
0001EF 7806           JNE      ?C0052
                                                ; SOURCE LINE # 339
0001F1 120000      R  LCALL    send_BAD_CRC_ACK?_
                                                ; SOURCE LINE # 341
0001F4 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 342
               ?C0052:
                                                ; SOURCE LINE # 345
0001F7 7EB30000    R  MOV      R11,rxBuffer+2   ; A=R11
0001FB BEB001         CMP      R11,#01H         ; A=R11
0001FE 780A           JNE      ?C0053
                                                ; SOURCE LINE # 346
000200 7E340100       MOV      WR6,#0100H
000204 7A370000    R  MOV      payload_buffer_size,WR6
                                                ; SOURCE LINE # 347
000208 800A           SJMP     ?C0054
               ?C0053:
                                                ; SOURCE LINE # 348
00020A 7E730000    R  MOV      R7,rxBuffer+3
00020E 0A37           MOVZ     WR6,R7
000210 7A370000    R  MOV      payload_buffer_size,WR6
                                                ; SOURCE LINE # 349
               ?C0054:
                                                ; SOURCE LINE # 350
000214 7401           MOV      A,#01H           ; A=R11
000216 7AB30000    R  MOV      incoming_payload_no_command,R11
                                                ; SOURCE LINE # 351
00021A 7E340100       MOV      WR6,#0100H
00021E 7A370000    R  MOV      address_expected_increment,WR6
                                                ; SOURCE LINE # 352
000222 120000      R  LCALL    setReceive?_
                                                ; SOURCE LINE # 354
000225 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 355
               ?C0051:
                                                ; SOURCE LINE # 357
000228 7E270000    R  MOV      WR4,cmd
00022C 7E3400FD       MOV      WR6,#0FDH
000230 BD23           CMP      WR4,WR6
000232 782C           JNE      ?C0055
                                                ; SOURCE LINE # 358
000234 7E340002       MOV      WR6,#02H
000238 7A370000    R  MOV      len,WR6
                                                ; SOURCE LINE # 359
00023C 7E000000    R  MOV      DR0,#WORD0 rxBuffer
000240 7E370000    R  MOV      WR6,len
000244 120000      R  LCALL    checkCrc?_
000247 BEB000         CMP      R11,#00H         ; A=R11
00024A 7806           JNE      ?C0056
                                                ; SOURCE LINE # 360
00024C 120000      R  LCALL    send_BAD_CRC_ACK?_
                                                ; SOURCE LINE # 362
00024F 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 363
               ?C0056:
                                                ; SOURCE LINE # 365
000252 120000      R  LCALL    setTransmit?_
                                                ; SOURCE LINE # 366
000255 74C1           MOV      A,#0C1H          ; A=R11
000257 120000      R  LCALL    serialwriteChar?_
                                                ; SOURCE LINE # 367
00025A 120000      R  LCALL    setReceive?_
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 51  

                                                ; SOURCE LINE # 369
00025D 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 370
               ?C0055:
                                                ; SOURCE LINE # 372
000260 7E270000    R  MOV      WR4,cmd
000264 7E340002       MOV      WR6,#02H
000268 BD23           CMP      WR4,WR6
00026A 7833           JNE      ?C0057
                                                ; SOURCE LINE # 373
00026C 7E340002       MOV      WR6,#02H
000270 7A370000    R  MOV      len,WR6
                                                ; SOURCE LINE # 374
000274 7E000000    R  MOV      DR0,#WORD0 rxBuffer
000278 7E370000    R  MOV      WR6,len
00027C 120000      R  LCALL    checkCrc?_
00027F BEB000         CMP      R11,#00H         ; A=R11
000282 7806           JNE      ?C0058
                                                ; SOURCE LINE # 375
000284 120000      R  LCALL    send_BAD_CRC_ACK?_
                                                ; SOURCE LINE # 377
000287 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 378
               ?C0058:
                                                ; SOURCE LINE # 380
00028A 7E1F0000    R  MOV      DR4,address
00028E 120000      R  LCALL    checkAddressWritable?_
000291 4006           JC       ?C0059
                                                ; SOURCE LINE # 381
000293 120000      R  LCALL    send_BAD_ACK?_
                                                ; SOURCE LINE # 383
000296 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 384
               ?C0059:
                                                ; SOURCE LINE # 386
000299 120000      R  LCALL    send_ACK?_
                                                ; SOURCE LINE # 387
00029C 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 388
               ?C0057:
                                                ; SOURCE LINE # 390
00029F 7E270000    R  MOV      WR4,cmd
0002A3 7E340004       MOV      WR6,#04H
0002A7 BD23           CMP      WR4,WR6
0002A9 7806           JNE      ?C0060
                                                ; SOURCE LINE # 391
0002AB 7401           MOV      A,#01H           ; A=R11
0002AD 7AB30000    R  MOV      eeprom_req,R11   ; A=R11
                                                ; SOURCE LINE # 392
               ?C0060:
                                                ; SOURCE LINE # 394
0002B1 7E270000    R  MOV      WR4,cmd
0002B5 7E340003       MOV      WR6,#03H
0002B9 BD23           CMP      WR4,WR6
0002BB 6803        R  JE       $ + 5H
0002BD 020000      R  LJMP     ?C0061
                                                ; SOURCE LINE # 397
0002C0 7E340002       MOV      WR6,#02H
0002C4 7A370000    R  MOV      len,WR6
                                                ; SOURCE LINE # 398
0002C8 7E000000    R  MOV      DR0,#WORD0 rxBuffer
0002CC 7E370000    R  MOV      WR6,len
0002D0 120000      R  LCALL    checkCrc?_
0002D3 BEB000         CMP      R11,#00H         ; A=R11
0002D6 7806           JNE      ?C0062
                                                ; SOURCE LINE # 399
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 52  

0002D8 120000      R  LCALL    send_BAD_CRC_ACK?_
                                                ; SOURCE LINE # 401
0002DB 020000      R  LJMP     ?C0036
                                                ; SOURCE LINE # 402
               ?C0062:
                                                ; SOURCE LINE # 404
0002DE 7E270000    R  MOV      WR4,count
0002E2 7E340001       MOV      WR6,#01H
0002E6 2D32           ADD      WR6,WR4
0002E8 7A370000    R  MOV      count,WR6
                                                ; SOURCE LINE # 405
0002EC 7E730000    R  MOV      R7,rxBuffer+1
0002F0 0A37           MOVZ     WR6,R7
0002F2 793FFFFF       MOV      @DR60-0x1,WR6    ; out_buffer_size
                                                ; SOURCE LINE # 406
0002F6 6D22           XRL      WR4,WR4
0002F8 693FFFFF       MOV      WR6,@DR60-0x1    ; out_buffer_size
0002FC BD32           CMP      WR6,WR4
0002FE 7808           JNE      ?C0063
                                                ; SOURCE LINE # 407
000300 7E340100       MOV      WR6,#0100H
000304 793FFFFF       MOV      @DR60-0x1,WR6    ; out_buffer_size
                                                ; SOURCE LINE # 408
               ?C0063:
                                                ; SOURCE LINE # 409
000308 7E340080       MOV      WR6,#080H
00030C 7A370000    R  MOV      address_expected_increment,WR6
                                                ; SOURCE LINE # 410
000310 692FFFFF       MOV      WR4,@DR60-0x1    ; out_buffer_size
000314 7E340003       MOV      WR6,#03H
000318 2D32           ADD      WR6,WR4
00031A 120000      E  LCALL    malloc
00031D 793FFFFD       MOV      @DR60-0x3,WR6    ; read_data
000321 792FFFFB       MOV      @DR60-0x5,WR4    ; read_data
                                                ; SOURCE LINE # 411
000325 120000      R  LCALL    setTransmit?_
                                                ; SOURCE LINE # 412
000328 691FFFFD       MOV      WR2,@DR60-0x3    ; read_data
00032C 690FFFFB       MOV      WR0,@DR60-0x5    ; read_data
000330 7E340004       MOV      WR6,#04H
000334 E4             CLR      A                ; A=R11
000335 120000      E  LCALL    memset?_
                                                ; SOURCE LINE # 414
000338 693FFFFF       MOV      WR6,@DR60-0x1    ; out_buffer_size
00033C CA39           PUSH     WR6
00033E 7E1F0000    R  MOV      DR4,address
000342 691FFFFB       MOV      WR2,@DR60-0x5    ; read_data
000346 690FFFF9       MOV      WR0,@DR60-0x7    ; read_data
00034A 120000      E  LCALL    read_flash_bin?_
00034D 1BFD           DEC      DR60,#02H
                                                ; SOURCE LINE # 416
00034F 691FFFFD       MOV      WR2,@DR60-0x3    ; read_data
000353 690FFFFB       MOV      WR0,@DR60-0x5    ; read_data
000357 693FFFFF       MOV      WR6,@DR60-0x1    ; out_buffer_size
00035B 120000      R  LCALL    makeCrc?_
                                                ; SOURCE LINE # 417
00035E 7E330000    R  MOV      R3,calculated_crc_low_byte
000362 690FFFFF       MOV      WR0,@DR60-0x1    ; out_buffer_size
000366 693FFFFD       MOV      WR6,@DR60-0x3    ; read_data
00036A 692FFFFB       MOV      WR4,@DR60-0x5    ; read_data
00036E 2D30           ADD      WR6,WR0
000370 7A1B30         MOV      @DR4,R3
                                                ; SOURCE LINE # 418
000373 7E330000    R  MOV      R3,calculated_crc_high_byte
000377 690FFFFF       MOV      WR0,@DR60-0x1    ; out_buffer_size
00037B 693FFFFD       MOV      WR6,@DR60-0x3    ; read_data
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 53  

00037F 692FFFFB       MOV      WR4,@DR60-0x5    ; read_data
000383 2D30           ADD      WR6,WR0
000385 0B34           INC      WR6,#01H
000387 7A1B30         MOV      @DR4,R3
                                                ; SOURCE LINE # 419
00038A 7430           MOV      A,#030H          ; A=R11
00038C 691FFFFF       MOV      WR2,@DR60-0x1    ; out_buffer_size
000390 693FFFFD       MOV      WR6,@DR60-0x3    ; read_data
000394 692FFFFB       MOV      WR4,@DR60-0x5    ; read_data
000398 2D31           ADD      WR6,WR2
00039A 0B35           INC      WR6,#02H
00039C 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 420
00039F 692FFFFF       MOV      WR4,@DR60-0x1    ; out_buffer_size
0003A3 7E340003       MOV      WR6,#03H
0003A7 2D32           ADD      WR6,WR4
0003A9 691FFFFD       MOV      WR2,@DR60-0x3    ; read_data
0003AD 690FFFFB       MOV      WR0,@DR60-0x5    ; read_data
0003B1 120000      R  LCALL    sendString?_
                                                ; SOURCE LINE # 422
0003B4 120000      R  LCALL    setReceive?_
                                                ; SOURCE LINE # 423
0003B7 691FFFFD       MOV      WR2,@DR60-0x3    ; read_data
0003BB 690FFFFB       MOV      WR0,@DR60-0x5    ; read_data
0003BF 120000      E  LCALL    free
                                                ; SOURCE LINE # 424
0003C2 8019           SJMP     ?C0036
                                                ; SOURCE LINE # 425
               ?C0061:
                                                ; SOURCE LINE # 427
0003C4 120000      R  LCALL    setTransmit?_
                                                ; SOURCE LINE # 429
0003C7 74C1           MOV      A,#0C1H          ; A=R11
0003C9 120000      R  LCALL    serialwriteChar?_
                                                ; SOURCE LINE # 430
0003CC 7E270000    R  MOV      WR4,invalid_command
0003D0 7E340001       MOV      WR6,#01H
0003D4 2D32           ADD      WR6,WR4
0003D6 7A370000    R  MOV      invalid_command,WR6
                                                ; SOURCE LINE # 431
0003DA 120000      R  LCALL    setReceive?_
                                                ; SOURCE LINE # 432
               ?C0036:
0003DD 9EF80008       SUB      DR60,#08H
0003E1 22             RET      
;       FUNCTION decodeInput?_ (END)

;       FUNCTION serialreadChar?_ (BEGIN)
                                                ; SOURCE LINE # 434
000000 0BFD           INC      DR60,#02H
                                                ; SOURCE LINE # 435
                                                ; SOURCE LINE # 437
000002 E4             CLR      A                ; A=R11
000003 7AB30000    R  MOV      rxbyte,R11       ; A=R11
                                                ; SOURCE LINE # 440
000007 74BF           MOV      A,#0BFH          ; A=R11
000009 7E34FEF1       MOV      WR6,#0FEF1H
00000D 7E24007E       MOV      WR4,#07EH
000011 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 441
000014 E4             CLR      A                ; A=R11
000015 7E34FEEE       MOV      WR6,#0FEEEH
000019 7E24007E       MOV      WR4,#07EH
00001D 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 442
000020 E4             CLR      A                ; A=R11
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 54  

000021 7E34FEEF       MOV      WR6,#0FEEFH
000025 7E24007E       MOV      WR4,#07EH
000029 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 443
00002C 8033           SJMP     ?C0064
               ?C0066:
                                                ; SOURCE LINE # 444
00002E 7E34FEEE       MOV      WR6,#0FEEEH
000032 7E24007E       MOV      WR4,#07EH
000036 7E1B70         MOV      R7,@DR4
000039 0A37           MOVZ     WR6,R7
00003B 7C67           MOV      R6,R7
00003D 6C77           XRL      R7,R7
00003F 7E14FEEF       MOV      WR2,#0FEEFH
000043 7E04007E       MOV      WR0,#07EH
000047 7E0B50         MOV      R5,@DR0
00004A 0A25           MOVZ     WR4,R5
00004C 4D23           ORL      WR4,WR6
00004E 7E34C350       MOV      WR6,#0C350H
000052 BD23           CMP      WR4,WR6
000054 280B           JLE      ?C0064
                                                ; SOURCE LINE # 445
000056 7E340065       MOV      WR6,#065H
00005A 7A370000    R  MOV      invalid_command,WR6
                                                ; SOURCE LINE # 446
00005E 020000      R  LJMP     ?C0069
                                                ; SOURCE LINE # 447
               ?C0064:
000061 A281           MOV      C,P01
000063 B3             CPL      C
000064 40C8           JC       ?C0066
                                                ; SOURCE LINE # 451
000066 742F           MOV      A,#02FH          ; A=R11
000068 7E34FEF1       MOV      WR6,#0FEF1H
00006C 7E24007E       MOV      WR4,#07EH
000070 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 452
000073 E4             CLR      A                ; A=R11
000074 7E34FEEE       MOV      WR6,#0FEEEH
000078 7E24007E       MOV      WR4,#07EH
00007C 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 453
00007F E4             CLR      A                ; A=R11
000080 7E34FEEF       MOV      WR6,#0FEEFH
000084 7E24007E       MOV      WR4,#07EH
000088 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 454
00008B 8031           SJMP     ?C0070
               ?C0072:
                                                ; SOURCE LINE # 455
00008D 7E34FEEE       MOV      WR6,#0FEEEH
000091 7E24007E       MOV      WR4,#07EH
000095 7E1B70         MOV      R7,@DR4
000098 0A37           MOVZ     WR6,R7
00009A 7C67           MOV      R6,R7
00009C 6C77           XRL      R7,R7
00009E 7E14FEEF       MOV      WR2,#0FEEFH
0000A2 7E04007E       MOV      WR0,#07EH
0000A6 7E0B50         MOV      R5,@DR0
0000A9 0A25           MOVZ     WR4,R5
0000AB 4D23           ORL      WR4,WR6
0000AD 7E3400FA       MOV      WR6,#0FAH
0000B1 BD23           CMP      WR4,WR6
0000B3 2809           JLE      ?C0070
0000B5 7EB30000    R  MOV      R11,messagereceived
0000B9 BEB000         CMP      R11,#00H         ; A=R11
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 55  

0000BC 7863           JNE      ?C0069
                                                ; SOURCE LINE # 456
                                                ; SOURCE LINE # 457
               ?C0070:
0000BE 2081CC         JB       P01,?C0072
                                                ; SOURCE LINE # 460
0000C1 7E18001A       MOV      DR4,#01AH
0000C5 120000      R  LCALL    delayMicroseconds?_
                                                ; SOURCE LINE # 462
0000C8 6D33           XRL      WR6,WR6
0000CA 793FFFFF       MOV      @DR60-0x1,WR6    ; bits_to_read
                                                ; SOURCE LINE # 463
0000CE 8030           SJMP     ?C0075
               ?C0077:
                                                ; SOURCE LINE # 464
0000D0 7E180034       MOV      DR4,#034H
0000D4 120000      R  LCALL    delayMicroseconds?_
                                                ; SOURCE LINE # 465
0000D7 A281           MOV      C,P01
0000D9 E4             CLR      A                ; A=R11
0000DA 33             RLC      A                ; A=R11
0000DB 7C6B           MOV      R6,R11           ; A=R11
0000DD 695FFFFF       MOV      WR10,@DR60-0x1   ; bits_to_read
0000E1 6005           JZ       ?C0133
               ?C0132:
0000E3 3E60           SLL      R6
0000E5 14             DEC      A                ; A=R11
0000E6 78FB           JNE      ?C0132
               ?C0133:
0000E8 7E730000    R  MOV      R7,rxbyte
0000EC 4C76           ORL      R7,R6
0000EE 7A730000    R  MOV      rxbyte,R7
                                                ; SOURCE LINE # 466
0000F2 692FFFFF       MOV      WR4,@DR60-0x1    ; bits_to_read
0000F6 7E340001       MOV      WR6,#01H
0000FA 2D32           ADD      WR6,WR4
0000FC 793FFFFF       MOV      @DR60-0x1,WR6    ; bits_to_read
                                                ; SOURCE LINE # 467
               ?C0075:
000100 692FFFFF       MOV      WR4,@DR60-0x1    ; bits_to_read
000104 7E340008       MOV      WR6,#08H
000108 BD23           CMP      WR4,WR6
00010A 48C4           JSL      ?C0077
                                                ; SOURCE LINE # 469
00010C 7E18001A       MOV      DR4,#01AH
000110 120000      R  LCALL    delayMicroseconds?_
                                                ; SOURCE LINE # 470
000113 7401           MOV      A,#01H           ; A=R11
000115 7AB30000    R  MOV      messagereceived,R11
                                                ; SOURCE LINE # 471
000119 7E730000    R  MOV      R7,rxbyte
00011D 7A730000    R  MOV      receviedByte,R7
                                                ; SOURCE LINE # 474
               ?C0069:
000121 1BFD           DEC      DR60,#02H
000123 22             RET      
;       FUNCTION serialreadChar?_ (END)

;       FUNCTION serialwriteChar?_ (BEGIN)
                                                ; SOURCE LINE # 476
000000 CAB8           PUSH     R11              ; A=R11
000002 0BFC           INC      DR60,#01H
                                                ; SOURCE LINE # 477
                                                ; SOURCE LINE # 481
000004 E4             CLR      A                ; A=R11
000005 7AFBB0         MOV      @DR60,R11        ; bits_to_read
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 56  

                                                ; SOURCE LINE # 483
000008 C3             CLR      C
000009 C281           CLR      P01
                                                ; SOURCE LINE # 486
00000B 802B           SJMP     ?C0079
               ?C0081:
                                                ; SOURCE LINE # 488
00000D 7E180034       MOV      DR4,#034H
000011 120000      R  LCALL    delayMicroseconds?_
                                                ; SOURCE LINE # 490
000014 29BFFFFF       MOV      R11,@DR60-0x1    ; dat
000018 30E005         JNB      ACC.0,?C0083
                                                ; SOURCE LINE # 492
00001B D3             SETB     C
00001C D281           SETB     P01
                                                ; SOURCE LINE # 493
00001E 8003           SJMP     ?C0084
               ?C0083:
                                                ; SOURCE LINE # 495
000020 C3             CLR      C
000021 C281           CLR      P01
                                                ; SOURCE LINE # 496
               ?C0084:
                                                ; SOURCE LINE # 497
000023 7EFB60         MOV      R6,@DR60         ; bits_to_read
000026 7E7001         MOV      R7,#01H
000029 2C76           ADD      R7,R6
00002B 7AFB70         MOV      @DR60,R7         ; bits_to_read
                                                ; SOURCE LINE # 498
00002E 297FFFFF       MOV      R7,@DR60-0x1     ; dat
000032 0E70           SRA      R7
000034 397FFFFF       MOV      @DR60-0x1,R7     ; dat
                                                ; SOURCE LINE # 499
               ?C0079:
000038 7EFBA0         MOV      R10,@DR60        ; bits_to_read
00003B 7408           MOV      A,#08H           ; A=R11
00003D BCAB           CMP      R10,R11          ; A=R11
00003F 48CC           JSL      ?C0081
                                                ; SOURCE LINE # 501
000041 7E180034       MOV      DR4,#034H
000045 120000      R  LCALL    delayMicroseconds?_
                                                ; SOURCE LINE # 506
000048 D3             SETB     C
000049 D281           SETB     P01
                                                ; SOURCE LINE # 517
00004B 1BFD           DEC      DR60,#02H
00004D 22             RET      
;       FUNCTION serialwriteChar?_ (END)

;       FUNCTION sendString?_ (BEGIN)
                                                ; SOURCE LINE # 519
000000 CA39           PUSH     WR6
000002 CA0B           PUSH     DR0
000004 0BFD           INC      DR60,#02H
                                                ; SOURCE LINE # 521
000006 6D33           XRL      WR6,WR6
000008 793FFFFF       MOV      @DR60-0x1,WR6    ; i
00000C 8029           SJMP     ?C0087
               ?C0088:
                                                ; SOURCE LINE # 522
00000E 691FFFFF       MOV      WR2,@DR60-0x1    ; i
000012 693FFFFD       MOV      WR6,@DR60-0x3    ; dat
000016 692FFFFB       MOV      WR4,@DR60-0x5    ; dat
00001A 2D31           ADD      WR6,WR2
00001C 7E1BB0         MOV      R11,@DR4         ; A=R11
00001F 120000      R  LCALL    serialwriteChar?_
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 57  

                                                ; SOURCE LINE # 523
000022 7E180034       MOV      DR4,#034H
000026 120000      R  LCALL    delayMicroseconds?_
                                                ; SOURCE LINE # 524
000029 692FFFFF       MOV      WR4,@DR60-0x1    ; i
00002D 7E340001       MOV      WR6,#01H
000031 2D32           ADD      WR6,WR4
000033 793FFFFF       MOV      @DR60-0x1,WR6    ; i
               ?C0087:
000037 692FFFF9       MOV      WR4,@DR60-0x7    ; len
00003B 693FFFFF       MOV      WR6,@DR60-0x1    ; i
00003F BD32           CMP      WR6,WR4
000041 48CB           JSL      ?C0088
                                                ; SOURCE LINE # 525
000043 9EF80008       SUB      DR60,#08H
000047 22             RET      
;       FUNCTION sendString?_ (END)

;       FUNCTION recieveBuffer?_ (BEGIN)
                                                ; SOURCE LINE # 527
000000 0BFD           INC      DR60,#02H
                                                ; SOURCE LINE # 529
000002 6D33           XRL      WR6,WR6
000004 793FFFFF       MOV      @DR60-0x1,WR6    ; i
                                                ; SOURCE LINE # 530
000008 6D33           XRL      WR6,WR6
00000A 7A370000    R  MOV      count,WR6
                                                ; SOURCE LINE # 531
00000E E4             CLR      A                ; A=R11
00000F 7AB30000    R  MOV      messagereceived,R11
                                                ; SOURCE LINE # 532
000013 7E000000    R  MOV      DR0,#WORD0 rxBuffer
000017 7E340102       MOV      WR6,#0102H
00001B E4             CLR      A                ; A=R11
00001C 120000      E  LCALL    memset?_
                                                ; SOURCE LINE # 535
00001F 6D33           XRL      WR6,WR6
000021 793FFFFF       MOV      @DR60-0x1,WR6    ; i
000025 020000      R  LJMP     ?C0092
               ?C0093:
                                                ; SOURCE LINE # 536
000028 120000      R  LCALL    serialreadChar?_
                                                ; SOURCE LINE # 537
00002B 7EB30000    R  MOV      R11,incoming_payload_no_command
00002F BEB000         CMP      R11,#00H         ; A=R11
000032 6836           JE       ?C0095
                                                ; SOURCE LINE # 538
000034 7E370000    R  MOV      WR6,payload_buffer_size
000038 7E240002       MOV      WR4,#02H
00003C 2D23           ADD      WR4,WR6
00003E 7E370000    R  MOV      WR6,count
000042 BD32           CMP      WR6,WR4
000044 7803        R  JNE      $ + 5H
000046 020000      R  LJMP     ?C0091
                                                ; SOURCE LINE # 539
                                                ; SOURCE LINE # 540
                                                ; SOURCE LINE # 541
000049 7E530000    R  MOV      R5,rxbyte
00004D 691FFFFF       MOV      WR2,@DR60-0x1    ; i
000051 7E340000    R  MOV      WR6,#WORD0 rxBuffer
000055 2D31           ADD      WR6,WR2
000057 7A3950         MOV      @WR6,R5
                                                ; SOURCE LINE # 542
00005A 7E270000    R  MOV      WR4,count
00005E 7E340001       MOV      WR6,#01H
000062 2D32           ADD      WR6,WR4
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 58  

000064 7A370000    R  MOV      count,WR6
                                                ; SOURCE LINE # 543
000068 805B           SJMP     ?C0090
               ?C0095:
                                                ; SOURCE LINE # 544
00006A 7E34FEEE       MOV      WR6,#0FEEEH
00006E 7E24007E       MOV      WR4,#07EH
000072 7E1B70         MOV      R7,@DR4
000075 0A37           MOVZ     WR6,R7
000077 7C67           MOV      R6,R7
000079 6C77           XRL      R7,R7
00007B 7E14FEEF       MOV      WR2,#0FEEFH
00007F 7E04007E       MOV      WR0,#07EH
000083 7E0B50         MOV      R5,@DR0
000086 0A25           MOVZ     WR4,R5
000088 4D23           ORL      WR4,WR6
00008A 7E3400FA       MOV      WR6,#0FAH
00008E BD23           CMP      WR4,WR6
000090 2808           JLE      ?C0098
                                                ; SOURCE LINE # 545
000092 6D33           XRL      WR6,WR6
000094 7A370000    R  MOV      count,WR6
                                                ; SOURCE LINE # 546
000098 8048           SJMP     ?C0091
                                                ; SOURCE LINE # 547
               ?C0098:
                                                ; SOURCE LINE # 548
00009A 7E530000    R  MOV      R5,rxbyte
00009E 691FFFFF       MOV      WR2,@DR60-0x1    ; i
0000A2 7E340000    R  MOV      WR6,#WORD0 rxBuffer
0000A6 2D31           ADD      WR6,WR2
0000A8 7A3950         MOV      @WR6,R5
                                                ; SOURCE LINE # 549
0000AB 692FFFFF       MOV      WR4,@DR60-0x1    ; i
0000AF 7E340101       MOV      WR6,#0101H
0000B3 BD23           CMP      WR4,WR6
0000B5 780E           JNE      ?C0090
                                                ; SOURCE LINE # 550
0000B7 7E240014       MOV      WR4,#014H
0000BB 7E370000    R  MOV      WR6,invalid_command
0000BF 2D32           ADD      WR6,WR4
0000C1 7A370000    R  MOV      invalid_command,WR6
                                                ; SOURCE LINE # 552
                                                ; SOURCE LINE # 554
                                                ; SOURCE LINE # 555
               ?C0090:
0000C5 692FFFFF       MOV      WR4,@DR60-0x1    ; i
0000C9 7E340001       MOV      WR6,#01H
0000CD 2D32           ADD      WR6,WR4
0000CF 793FFFFF       MOV      @DR60-0x1,WR6    ; i
               ?C0092:
0000D3 692FFFFF       MOV      WR4,@DR60-0x1    ; i
0000D7 7E340102       MOV      WR6,#0102H
0000DB BD23           CMP      WR4,WR6
0000DD 5803        R  JSGE     $ + 5H
0000DF 020000      R  LJMP     ?C0093
               ?C0091:
                                                ; SOURCE LINE # 556
0000E2 120000      R  LCALL    decodeInput?_
                                                ; SOURCE LINE # 557
0000E5 1BFD           DEC      DR60,#02H
0000E7 22             RET      
;       FUNCTION recieveBuffer?_ (END)

;       FUNCTION update_EEPROM?_ (BEGIN)
                                                ; SOURCE LINE # 559
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 59  

                                                ; SOURCE LINE # 560
000000 7E140000    R  MOV      WR2,#WORD0 ?SC_0027
000004 7E040000    R  MOV      WR0,#WORD2 ?SC_0027
000008 120000      E  LCALL    printf
                                                ; SOURCE LINE # 561
00000B 7E340030       MOV      WR6,#030H
00000F CA39           PUSH     WR6
000011 9F11           SUB      DR4,DR4
000013 7E000000    R  MOV      DR0,#WORD0 rxBuffer
000017 120000      E  LCALL    read_flash_bin?_
00001A 1BFD           DEC      DR60,#02H
                                                ; SOURCE LINE # 562
00001C 7EB30000    R  MOV      R11,rxBuffer+2   ; A=R11
000020 BEB00A         CMP      R11,#0AH         ; A=R11
000023 6829           JE       ?C0104
                                                ; SOURCE LINE # 563
000025 7EB30000    R  MOV      R11,rxBuffer+2   ; A=R11
000029 BEB0FF         CMP      R11,#0FFH        ; A=R11
00002C 6820           JE       ?C0104
00002E 7EB30000    R  MOV      R11,rxBuffer+2   ; A=R11
000032 BEB000         CMP      R11,#00H         ; A=R11
000035 6817           JE       ?C0104
                                                ; SOURCE LINE # 564
                                                ; SOURCE LINE # 565
                                                ; SOURCE LINE # 566
000037 740A           MOV      A,#0AH           ; A=R11
000039 7AB30000    R  MOV      rxBuffer+2,R11   ; A=R11
                                                ; SOURCE LINE # 567
00003D 9F11           SUB      DR4,DR4
00003F CA1B           PUSH     DR4
000041 7E000000    R  MOV      DR0,#WORD0 rxBuffer
000045 7E340030       MOV      WR6,#030H
000049 120000      E  LCALL    save_flash_nolib?_
00004C 1BFE           DEC      DR60,#04H
                                                ; SOURCE LINE # 568
               ?C0104:
00004E 22             RET      
;       FUNCTION update_EEPROM?_ (END)

;       FUNCTION checkForSignal?_ (BEGIN)
                                                ; SOURCE LINE # 571
000000 0BFD           INC      DR60,#02H
                                                ; SOURCE LINE # 576
000002 74FD           MOV      A,#0FDH          ; A=R11
000004 7E14FE10       MOV      WR2,#0FE10H
000008 7E04007E       MOV      WR0,#07EH
00000C 7E0B70         MOV      R7,@DR0
00000F 5C7B           ANL      R7,R11           ; A=R11
000011 7A0B70         MOV      @DR0,R7
                                                ; SOURCE LINE # 577
000014 7402           MOV      A,#02H           ; A=R11
000016 7E14FE40       MOV      WR2,#0FE40H
00001A 7E04007E       MOV      WR0,#07EH
00001E 7E0B70         MOV      R7,@DR0
000021 4C7B           ORL      R7,R11           ; A=R11
000023 7A0B70         MOV      @DR0,R7
                                                ; SOURCE LINE # 579
000026 7E1801F4       MOV      DR4,#01F4H
00002A 120000      R  LCALL    delayMicroseconds?_
                                                ; SOURCE LINE # 581
00002D 6D33           XRL      WR6,WR6
00002F 793FFFFF       MOV      @DR60-0x1,WR6    ; i
000033 8028           SJMP     ?C0107
               ?C0108:
                                                ; SOURCE LINE # 583
000035 A281           MOV      C,P01
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 60  

000037 B3             CPL      C
000038 500E           JNC      ?C0111
                                                ; SOURCE LINE # 584
00003A 7E270000    R  MOV      WR4,low_pin_count
00003E 7E340001       MOV      WR6,#01H
000042 2D32           ADD      WR6,WR4
000044 7A370000    R  MOV      low_pin_count,WR6
                                                ; SOURCE LINE # 585
                                                ; SOURCE LINE # 587
               ?C0111:
                                                ; SOURCE LINE # 588
000048 7E18000A       MOV      DR4,#0AH
00004C 120000      R  LCALL    delayMicroseconds?_
                                                ; SOURCE LINE # 589
00004F 692FFFFF       MOV      WR4,@DR60-0x1    ; i
000053 7E340001       MOV      WR6,#01H
000057 2D32           ADD      WR6,WR4
000059 793FFFFF       MOV      @DR60-0x1,WR6    ; i
               ?C0107:
00005D 692FFFFF       MOV      WR4,@DR60-0x1    ; i
000061 7E3401F4       MOV      WR6,#01F4H
000065 BD23           CMP      WR4,WR6
000067 48CC           JSL      ?C0108
                                                ; SOURCE LINE # 591
000069 6D22           XRL      WR4,WR4
00006B 7E370000    R  MOV      WR6,low_pin_count
00006F BD32           CMP      WR6,WR4
000071 7803        R  JNE      $ + 5H
000073 020000      R  LJMP     ?C0113
                                                ; SOURCE LINE # 592
                                                ; SOURCE LINE # 593
                                                ; SOURCE LINE # 595
000076 6D33           XRL      WR6,WR6
000078 7A370000    R  MOV      low_pin_count,WR6
                                                ; SOURCE LINE # 597
00007C 74FD           MOV      A,#0FDH          ; A=R11
00007E 7E14FE10       MOV      WR2,#0FE10H
000082 7E04007E       MOV      WR0,#07EH
000086 7E0B70         MOV      R7,@DR0
000089 5C7B           ANL      R7,R11           ; A=R11
00008B 7A0B70         MOV      @DR0,R7
                                                ; SOURCE LINE # 598
00008E 74FD           MOV      A,#0FDH          ; A=R11
000090 7E14FE40       MOV      WR2,#0FE40H
000094 7E04007E       MOV      WR0,#07EH
000098 7E0B70         MOV      R7,@DR0
00009B 5C7B           ANL      R7,R11           ; A=R11
00009D 7A0B70         MOV      @DR0,R7
                                                ; SOURCE LINE # 600
0000A0 7E1801F4       MOV      DR4,#01F4H
0000A4 120000      R  LCALL    delayMicroseconds?_
                                                ; SOURCE LINE # 602
0000A7 6D33           XRL      WR6,WR6
0000A9 793FFFFF       MOV      @DR60-0x1,WR6    ; i
0000AD 8028           SJMP     ?C0116
               ?C0117:
                                                ; SOURCE LINE # 603
0000AF A281           MOV      C,P01
0000B1 B3             CPL      C
0000B2 500E           JNC      ?C0119
                                                ; SOURCE LINE # 604
0000B4 7E270000    R  MOV      WR4,low_pin_count
0000B8 7E340001       MOV      WR6,#01H
0000BC 2D32           ADD      WR6,WR4
0000BE 7A370000    R  MOV      low_pin_count,WR6
                                                ; SOURCE LINE # 605
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 61  

               ?C0119:
                                                ; SOURCE LINE # 606
0000C2 7E18000A       MOV      DR4,#0AH
0000C6 120000      R  LCALL    delayMicroseconds?_
                                                ; SOURCE LINE # 607
0000C9 692FFFFF       MOV      WR4,@DR60-0x1    ; i
0000CD 7E340001       MOV      WR6,#01H
0000D1 2D32           ADD      WR6,WR4
0000D3 793FFFFF       MOV      @DR60-0x1,WR6    ; i
               ?C0116:
0000D7 692FFFFF       MOV      WR4,@DR60-0x1    ; i
0000DB 7E3401F4       MOV      WR6,#01F4H
0000DF BD23           CMP      WR4,WR6
0000E1 48CC           JSL      ?C0117
                                                ; SOURCE LINE # 609
0000E3 6D22           XRL      WR4,WR4
0000E5 7E370000    R  MOV      WR6,low_pin_count
0000E9 BD32           CMP      WR6,WR4
0000EB 680D           JE       ?C0113
                                                ; SOURCE LINE # 610
                                                ; SOURCE LINE # 611
                                                ; SOURCE LINE # 613
0000ED 6D22           XRL      WR4,WR4
0000EF 7E370000    R  MOV      WR6,low_pin_count
0000F3 BD32           CMP      WR6,WR4
0000F5 2803           JLE      ?C0113
                                                ; SOURCE LINE # 614
0000F7 120000      R  LCALL    jump?_
                                                ; SOURCE LINE # 615
               ?C0113:
0000FA 1BFD           DEC      DR60,#02H
0000FC 22             RET      
;       FUNCTION checkForSignal?_ (END)

;       FUNCTION Uart1_Init?_ (BEGIN)
                                                ; SOURCE LINE # 619
                                                ; SOURCE LINE # 621
000000 7450           MOV      A,#050H          ; A=R11
000002 F598           MOV      SCON,A           ; A=R11
                                                ; SOURCE LINE # 622
000004 438E01         ORL      AUXR,#01H
                                                ; SOURCE LINE # 623
000007 438E04         ORL      AUXR,#04H
                                                ; SOURCE LINE # 624
00000A 74F3           MOV      A,#0F3H          ; A=R11
00000C F5D7           MOV      T2L,A            ; A=R11
                                                ; SOURCE LINE # 625
00000E 74FF           MOV      A,#0FFH          ; A=R11
000010 F5D6           MOV      T2H,A            ; A=R11
                                                ; SOURCE LINE # 626
000012 438E10         ORL      AUXR,#010H
                                                ; SOURCE LINE # 627
000015 22             RET      
;       FUNCTION Uart1_Init?_ (END)

;       FUNCTION main (BEGIN)
                                                ; SOURCE LINE # 631
                                                ; SOURCE LINE # 635
                                                ; SOURCE LINE # 637
000000 120000      R  LCALL    Uart1_Init?_
                                                ; SOURCE LINE # 639
000003 43B203         ORL      P3M0,#03H
000006 53B1FC         ANL      P3M1,#0FCH
                                                ; SOURCE LINE # 640
000009 439603         ORL      P2M0,#03H
00000C 5395FC         ANL      P2M1,#0FCH
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 62  

                                                ; SOURCE LINE # 642
00000F 7430           MOV      A,#030H          ; A=R11
000011 F5F5           MOV      IAP_TPS,A        ; A=R11
                                                ; SOURCE LINE # 644
000013 120000      R  LCALL    SystemClock_Config?_
                                                ; SOURCE LINE # 645
000016 120000      R  LCALL    PWMB_Timer_Init?_
                                                ; SOURCE LINE # 647
000019 120000      R  LCALL    GPIO_INPUT_INIT?_
                                                ; SOURCE LINE # 649
00001C 120000      R  LCALL    checkForSignal?_
                                                ; SOURCE LINE # 651
00001F 74FD           MOV      A,#0FDH          ; A=R11
000021 7E14FE40       MOV      WR2,#0FE40H
000025 7E04007E       MOV      WR0,#07EH
000029 7E0B70         MOV      R7,@DR0
00002C 5C7B           ANL      R7,R11           ; A=R11
00002E 7A0B70         MOV      @DR0,R7
                                                ; SOURCE LINE # 652
000031 7402           MOV      A,#02H           ; A=R11
000033 7E14FE10       MOV      WR2,#0FE10H
000037 7E04007E       MOV      WR0,#07EH
00003B 7E0B70         MOV      R7,@DR0
00003E 4C7B           ORL      R7,R11           ; A=R11
000040 7A0B70         MOV      @DR0,R7
                                                ; SOURCE LINE # 657
000043 7E730000    R  MOV      R7,pin_code
000047 7A730000    R  MOV      deviceInfo+3,R7
                                                ; SOURCE LINE # 658
00004B 120000      R  LCALL    update_EEPROM?_
                                                ; SOURCE LINE # 661
               ?C0124:
                                                ; SOURCE LINE # 664
00004E 120000      R  LCALL    recieveBuffer?_
                                                ; SOURCE LINE # 665
000051 7E370000    R  MOV      WR6,invalid_command
000055 7A370000    E  MOV      ?printf?BYTE-2,WR6
000059 7E140000    R  MOV      WR2,#WORD0 ?SC_0006
00005D 7E040000    R  MOV      WR0,#WORD2 ?SC_0006
000061 120000      E  LCALL    printf
                                                ; SOURCE LINE # 666
000064 7E270000    R  MOV      WR4,invalid_command
000068 7E340064       MOV      WR6,#064H
00006C BD23           CMP      WR4,WR6
00006E 28DE           JLE      ?C0124
                                                ; SOURCE LINE # 667
000070 120000      R  LCALL    jump?_
                                                ; SOURCE LINE # 668
000073 7E140000    R  MOV      WR2,#WORD0 ?SC_0000
000077 7E040000    R  MOV      WR0,#WORD2 ?SC_0000
00007B 120000      E  LCALL    printf
                                                ; SOURCE LINE # 669
00007E 80CE           SJMP     ?C0124
                                                ; SOURCE LINE # 671
000080 22             RET      
;       FUNCTION main (END)

;       FUNCTION SystemClock_Config?_ (BEGIN)
                                                ; SOURCE LINE # 675
                                                ; SOURCE LINE # 677
000000 C3             CLR      C
000001 C2AF           CLR      EA
                                                ; SOURCE LINE # 679
000003 E4             CLR      A                ; A=R11
000004 F5EA           MOV      CKCON,A          ; A=R11
                                                ; SOURCE LINE # 680
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 63  

000006 7401           MOV      A,#01H           ; A=R11
000008 F5E9           MOV      WTST,A           ; A=R11
                                                ; SOURCE LINE # 681
00000A 7480           MOV      A,#080H          ; A=R11
00000C F5BA           MOV      P_SW2,A          ; A=R11
                                                ; SOURCE LINE # 683
00000E 7404           MOV      A,#04H           ; A=R11
000010 7E34FE01       MOV      WR6,#0FE01H
000014 7E24007E       MOV      WR4,#07EH
000018 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 685
00001B 7E34FDEC       MOV      WR6,#0FDECH
00001F 7E24007E       MOV      WR4,#07EH
000023 7E1BB0         MOV      R11,@DR4         ; A=R11
000026 F59F           MOV      IRTRIM,A         ; A=R11
                                                ; SOURCE LINE # 686
000028 D3             SETB     C
000029 A9D19D         SETB     HIRCSEL1
                                                ; SOURCE LINE # 687
00002C C3             CLR      C
00002D A9C09D         CLR      HIRCSEL0
                                                ; SOURCE LINE # 689
000030 7480           MOV      A,#080H          ; A=R11
000032 7E34FE02       MOV      WR6,#0FE02H
000036 7E24007E       MOV      WR4,#07EH
00003A 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 694
00003D 7440           MOV      A,#040H          ; A=R11
00003F 7E34FE00       MOV      WR6,#0FE00H
000043 7E24007E       MOV      WR4,#07EH
000047 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 696
00004A 53DC0F         ANL      USBCLK,#0FH
                                                ; SOURCE LINE # 697
00004D 43DCA0         ORL      USBCLK,#0A0H
                                                ; SOURCE LINE # 698
000050 00             NOP      
000051 00             NOP      
000052 00             NOP      
000053 00             NOP      
000054 00             NOP      
                                                ; SOURCE LINE # 702
000055 7401           MOV      A,#01H           ; A=R11
000057 7E34FE01       MOV      WR6,#0FE01H
00005B 7E24007E       MOV      WR4,#07EH
00005F 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 704
000062 7408           MOV      A,#08H           ; A=R11
000064 7E14FE00       MOV      WR2,#0FE00H
000068 7E04007E       MOV      WR0,#07EH
00006C 7E0B70         MOV      R7,@DR0
00006F 4C7B           ORL      R7,R11           ; A=R11
000071 7A0B70         MOV      @DR0,R7
                                                ; SOURCE LINE # 706
000074 7401           MOV      A,#01H           ; A=R11
000076 7E34FE0B       MOV      WR6,#0FE0BH
00007A 7E24007E       MOV      WR4,#07EH
00007E 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 708
000081 D3             SETB     C
000082 A9D79D         SETB     USBCKS
                                                ; SOURCE LINE # 709
000085 C3             CLR      C
000086 A9C69D         CLR      USBCKS2
                                                ; SOURCE LINE # 711
000089 D3             SETB     C
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 64  

00008A D2AF           SETB     EA
                                                ; SOURCE LINE # 712
00008C 22             RET      
;       FUNCTION SystemClock_Config?_ (END)

;       FUNCTION PWMB_Timer_Init?_ (BEGIN)
                                                ; SOURCE LINE # 715
                                                ; SOURCE LINE # 719
000000 E4             CLR      A                ; A=R11
000001 7E34FEB5       MOV      WR6,#0FEB5H
000005 7E24007E       MOV      WR4,#07EH
000009 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 720
00000C E4             CLR      A                ; A=R11
00000D 7E34FEB7       MOV      WR6,#0FEB7H
000011 7E24007E       MOV      WR4,#07EH
000015 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 722
000018 74FF           MOV      A,#0FFH          ; A=R11
00001A 7E34FEF2       MOV      WR6,#0FEF2H
00001E 7E24007E       MOV      WR4,#07EH
000022 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 723
000025 74FF           MOV      A,#0FFH          ; A=R11
000027 7E34FEF3       MOV      WR6,#0FEF3H
00002B 7E24007E       MOV      WR4,#07EH
00002F 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 724
000032 E4             CLR      A                ; A=R11
000033 7E34FEEE       MOV      WR6,#0FEEEH
000037 7E24007E       MOV      WR4,#07EH
00003B 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 725
00003E E4             CLR      A                ; A=R11
00003F 7E34FEEF       MOV      WR6,#0FEEFH
000043 7E24007E       MOV      WR4,#07EH
000047 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 726
00004A E4             CLR      A                ; A=R11
00004B 7E34FEF0       MOV      WR6,#0FEF0H
00004F 7E24007E       MOV      WR4,#07EH
000053 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 727
000056 7417           MOV      A,#017H          ; A=R11
000058 7E34FEF1       MOV      WR6,#0FEF1H
00005C 7E24007E       MOV      WR4,#07EH
000060 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 728
000063 E4             CLR      A                ; A=R11
000064 7E34FEE4       MOV      WR6,#0FEE4H
000068 7E24007E       MOV      WR4,#07EH
00006C 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 729
00006F 7401           MOV      A,#01H           ; A=R11
000071 7E34FEE0       MOV      WR6,#0FEE0H
000075 7E24007E       MOV      WR4,#07EH
000079 7A1BB0         MOV      @DR4,R11         ; A=R11
                                                ; SOURCE LINE # 730
00007C 22             RET      
;       FUNCTION PWMB_Timer_Init?_ (END)

;       FUNCTION GPIO_INPUT_INIT?_ (BEGIN)
                                                ; SOURCE LINE # 734
                                                ; SOURCE LINE # 741
000000 5394FD         ANL      P0M0,#0FDH
                                                ; SOURCE LINE # 742
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 65  

000003 439302         ORL      P0M1,#02H
                                                ; SOURCE LINE # 743
000006 74FD           MOV      A,#0FDH          ; A=R11
000008 7E14FE18       MOV      WR2,#0FE18H
00000C 7E04007E       MOV      WR0,#07EH
000010 7E0B70         MOV      R7,@DR0
000013 5C7B           ANL      R7,R11           ; A=R11
000015 7A0B70         MOV      @DR0,R7
                                                ; SOURCE LINE # 744
000018 7402           MOV      A,#02H           ; A=R11
00001A 7E14FE30       MOV      WR2,#0FE30H
00001E 7E04007E       MOV      WR0,#07EH
000022 7E0B70         MOV      R7,@DR0
000025 4C7B           ORL      R7,R11           ; A=R11
000027 7A0B70         MOV      @DR0,R7
                                                ; SOURCE LINE # 745
00002A 7402           MOV      A,#02H           ; A=R11
00002C 7E14FE10       MOV      WR2,#0FE10H
000030 7E04007E       MOV      WR0,#07EH
000034 7E0B70         MOV      R7,@DR0
000037 4C7B           ORL      R7,R11           ; A=R11
000039 7A0B70         MOV      @DR0,R7
                                                ; SOURCE LINE # 747
00003C 22             RET      
;       FUNCTION GPIO_INPUT_INIT?_ (END)

;       FUNCTION putchar (BEGIN)
                                                ; SOURCE LINE # 751
000000 7AB30000    R  MOV      c,R11            ; A=R11
                                                ; SOURCE LINE # 754
000004 F599           MOV      SBUF,A           ; A=R11
                                                ; SOURCE LINE # 755
               ?C0127:
000006 3099FD         JNB      TI,?C0127
                                                ; SOURCE LINE # 756
000009 C3             CLR      C
00000A C299           CLR      TI
                                                ; SOURCE LINE # 757
00000C 7EB30000    R  MOV      R11,c            ; A=R11
                                                ; SOURCE LINE # 758
000010 22             RET      
;       FUNCTION putchar (END)

C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 66  

Name                                    Class    Space Type   Offset   Size
---------------------------------------------------------------------------

uint32_t . . . . . . . . . . . . . . .  type           ulong  000000H  4
wchar_t. . . . . . . . . . . . . . . .  type           char   000000H  1
int8_t . . . . . . . . . . . . . . . .  type           char   000000H  1
uint8_t. . . . . . . . . . . . . . . .  type           uchar  000000H  1
pFunction. . . . . . . . . . . . . . .  type           ptr    000000H  2
uint8_16_u . . . . . . . . . . . . . .  type           union  000000H  2
  bytes. . . . . . . . . . . . . . . .  member         array  000000H  2
  word . . . . . . . . . . . . . . . .  member         uint   000000H  2
size_t . . . . . . . . . . . . . . . .  type           uint   000000H  2
int16_t. . . . . . . . . . . . . . . .  type           int    000000H  2
int32_t. . . . . . . . . . . . . . . .  type           long   000000H  4
uint16_t . . . . . . . . . . . . . . .  type           uint   000000H  2
P0M0 . . . . . . . . . . . . . . . . .  sfr      data  uchar  094H     1
PSW. . . . . . . . . . . . . . . . . .  sfr      data  uchar  0D0H     1
IRCBAND. . . . . . . . . . . . . . . .  sfr      data  uchar  09DH     1
AUXR2. . . . . . . . . . . . . . . . .  sfr      data  uchar  097H     1
IAP_TRIG . . . . . . . . . . . . . . .  sfr      data  uchar  0C6H     1
CKCON. . . . . . . . . . . . . . . . .  sfr      data  uchar  0EAH     1
IAPEN. . . . . . . . . . . . . . . . .  absbit   data  bit    0C7H.7   1
AUXINTIF . . . . . . . . . . . . . . .  sfr      data  uchar  0EFH     1
S4CON. . . . . . . . . . . . . . . . .  sfr      data  uchar  0FDH     1
S3CON. . . . . . . . . . . . . . . . .  sfr      data  uchar  0ACH     1
S2CON. . . . . . . . . . . . . . . . .  sfr      data  uchar  09AH     1
IPH. . . . . . . . . . . . . . . . . .  sfr      data  uchar  0B7H     1
SPSTAT . . . . . . . . . . . . . . . .  sfr      data  uchar  0CDH     1
T4T3M. . . . . . . . . . . . . . . . .  sfr      data  uchar  0DDH     1
IRTRIM . . . . . . . . . . . . . . . .  sfr      data  uchar  09FH     1
WDT_CONTR. . . . . . . . . . . . . . .  sfr      data  uchar  0C1H     1
IAP_DATA . . . . . . . . . . . . . . .  sfr      data  uchar  0C2H     1
WTST . . . . . . . . . . . . . . . . .  sfr      data  uchar  0E9H     1
CMD_FAIL . . . . . . . . . . . . . . .  absbit   data  bit    0C7H.4   1
T2L. . . . . . . . . . . . . . . . . .  sfr      data  uchar  0D7H     1
T2H. . . . . . . . . . . . . . . . . .  sfr      data  uchar  0D6H     1
USBCKS . . . . . . . . . . . . . . . .  absbit   data  bit    09DH.7   1
IP3. . . . . . . . . . . . . . . . . .  sfr      data  uchar  0DFH     1
USBCON . . . . . . . . . . . . . . . .  sfr      data  uchar  0F4H     1
IP2. . . . . . . . . . . . . . . . . .  sfr      data  uchar  0B5H     1
RSTCFG . . . . . . . . . . . . . . . .  sfr      data  uchar  0FFH     1
USBCLK . . . . . . . . . . . . . . . .  sfr      data  uchar  0DCH     1
IAP_CONTR. . . . . . . . . . . . . . .  sfr      data  uchar  0C7H     1
AUXR . . . . . . . . . . . . . . . . .  sfr      data  uchar  08EH     1
IE2. . . . . . . . . . . . . . . . . .  sfr      data  uchar  0AFH     1
HIRCSEL1 . . . . . . . . . . . . . . .  absbit   data  bit    09DH.1   1
HIRCSEL0 . . . . . . . . . . . . . . .  absbit   data  bit    09DH.0   1
TCON . . . . . . . . . . . . . . . . .  sfr      data  uchar  088H     1
TMOD . . . . . . . . . . . . . . . . .  sfr      data  uchar  089H     1
SCON . . . . . . . . . . . . . . . . .  sfr      data  uchar  098H     1
IAP_TPS. . . . . . . . . . . . . . . .  sfr      data  uchar  0F5H     1
P01. . . . . . . . . . . . . . . . . .  absbit   data  bit    080H.1   1
PCON . . . . . . . . . . . . . . . . .  sfr      data  uchar  087H     1
SBUF . . . . . . . . . . . . . . . . .  sfr      data  uchar  099H     1
ADC_CONTR. . . . . . . . . . . . . . .  sfr      data  uchar  0BCH     1
PSW1 . . . . . . . . . . . . . . . . .  sfr      data  uchar  0D1H     1
CMPCR2 . . . . . . . . . . . . . . . .  sfr      data  uchar  0E7H     1
CMPCR1 . . . . . . . . . . . . . . . .  sfr      data  uchar  0E6H     1
IAP_ADDRL. . . . . . . . . . . . . . .  sfr      data  uchar  0C4H     1
IAP_ADDRH. . . . . . . . . . . . . . .  sfr      data  uchar  0C3H     1
TI . . . . . . . . . . . . . . . . . .  absbit   data  bit    098H.1   1
IAP_ADDRE. . . . . . . . . . . . . . .  sfr      data  uchar  0F6H     1
ADCCFG . . . . . . . . . . . . . . . .  sfr      data  uchar  0DEH     1
IP . . . . . . . . . . . . . . . . . .  sfr      data  uchar  0B8H     1
INTCLKO. . . . . . . . . . . . . . . .  sfr      data  uchar  08FH     1
IP3H . . . . . . . . . . . . . . . . .  sfr      data  uchar  0EEH     1
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 67  

IP2H . . . . . . . . . . . . . . . . .  sfr      data  uchar  0B6H     1
IAP_CMD. . . . . . . . . . . . . . . .  sfr      data  uchar  0C5H     1
P_SW4. . . . . . . . . . . . . . . . .  sfr      data  uchar  0BFH     1
IE . . . . . . . . . . . . . . . . . .  sfr      data  uchar  0A8H     1
P_SW3. . . . . . . . . . . . . . . . .  sfr      data  uchar  0BBH     1
P_SW2. . . . . . . . . . . . . . . . .  sfr      data  uchar  0BAH     1
P_SW1. . . . . . . . . . . . . . . . .  sfr      data  uchar  0A2H     1
SPCTL. . . . . . . . . . . . . . . . .  sfr      data  uchar  0CEH     1
P7 . . . . . . . . . . . . . . . . . .  sfr      data  uchar  0F8H     1
EA . . . . . . . . . . . . . . . . . .  absbit   data  bit    0A8H.7   1
P6 . . . . . . . . . . . . . . . . . .  sfr      data  uchar  0E8H     1
P5 . . . . . . . . . . . . . . . . . .  sfr      data  uchar  0C8H     1
P4 . . . . . . . . . . . . . . . . . .  sfr      data  uchar  0C0H     1
WKTCH. . . . . . . . . . . . . . . . .  sfr      data  uchar  0ABH     1
P3 . . . . . . . . . . . . . . . . . .  sfr      data  uchar  0B0H     1
P2 . . . . . . . . . . . . . . . . . .  sfr      data  uchar  0A0H     1
P3M1 . . . . . . . . . . . . . . . . .  sfr      data  uchar  0B1H     1
P1 . . . . . . . . . . . . . . . . . .  sfr      data  uchar  090H     1
P2M1 . . . . . . . . . . . . . . . . .  sfr      data  uchar  095H     1
P3M0 . . . . . . . . . . . . . . . . .  sfr      data  uchar  0B2H     1
P0 . . . . . . . . . . . . . . . . . .  sfr      data  uchar  080H     1
P2M0 . . . . . . . . . . . . . . . . .  sfr      data  uchar  096H     1
USBCKS2. . . . . . . . . . . . . . . .  absbit   data  bit    09DH.6   1
P0M1 . . . . . . . . . . . . . . . . .  sfr      data  uchar  093H     1
memset?_ . . . . . . . . . . . . . . .  extern   code  funct  000000H  
printf . . . . . . . . . . . . . . . .  extern   code  funct  000000H  
save_flash_nolib?_ . . . . . . . . . .  extern   code  funct  000000H  
free . . . . . . . . . . . . . . . . .  extern   code  funct  000000H  
read_flash_bin?_ . . . . . . . . . . .  extern   code  funct  000000H  
malloc . . . . . . . . . . . . . . . .  extern   code  funct  000000H  
send_BAD_ACK?_ . . . . . . . . . . . .  public   code  funct  000000H  12
delayMicroseconds?_. . . . . . . . . .  public   code  funct  000000H  75
  micros . . . . . . . . . . . . . . .  param    edata ulong  -3       4
checkForSignal?_ . . . . . . . . . . .  public   code  funct  000000H  253
  i. . . . . . . . . . . . . . . . . .  auto     edata int    -1       2
checkAddressWritable?_ . . . . . . . .  public   code  funct  000000H  23
  address. . . . . . . . . . . . . . .  param    edata ulong  -3       4
sendDeviceInfo?_ . . . . . . . . . . .  public   code  funct  000000H  18
PWMB_Timer_Init?_. . . . . . . . . . .  static   code  funct  000000H  125
setReceive?_ . . . . . . . . . . . . .  public   code  funct  000000H  10
checkCrc?_ . . . . . . . . . . . . . .  public   code  funct  000000H  97
  pBuff. . . . . . . . . . . . . . . .  param    edata ptr    -5       4
  length . . . . . . . . . . . . . . .  param    edata uint   -7       2
  received_crc_low_byte2 . . . . . . .  auto     edata char   000000H  1
  received_crc_high_byte2. . . . . . .  auto     edata char   -1       1
serialreadChar?_ . . . . . . . . . . .  public   code  funct  000000H  292
  bits_to_read . . . . . . . . . . . .  auto     edata int    -1       2
setTransmit?_. . . . . . . . . . . . .  public   code  funct  000000H  43
main . . . . . . . . . . . . . . . . .  public   code  funct  000000H  129
sendString?_ . . . . . . . . . . . . .  public   code  funct  000000H  72
  dat. . . . . . . . . . . . . . . . .  param    edata ptr    -5       4
  len. . . . . . . . . . . . . . . . .  param    edata int    -7       2
  i. . . . . . . . . . . . . . . . . .  auto     edata int    -1       2
update_EEPROM?_. . . . . . . . . . . .  public   code  funct  000000H  79
SystemClock_Config?_ . . . . . . . . .  public   code  funct  000000H  141
serialwriteChar?_. . . . . . . . . . .  public   code  funct  000000H  78
  dat. . . . . . . . . . . . . . . . .  param    edata char   -1       1
  bits_to_read . . . . . . . . . . . .  auto     edata char   000000H  1
GPIO_INPUT_INIT?_. . . . . . . . . . .  static   code  funct  000000H  61
makeCrc?_. . . . . . . . . . . . . . .  public   code  funct  000000H  197
  pBuff. . . . . . . . . . . . . . . .  param    edata ptr    -7       4
  length . . . . . . . . . . . . . . .  param    edata uint   -9       2
  i. . . . . . . . . . . . . . . . . .  auto     edata int    -1       2
  xb . . . . . . . . . . . . . . . . .  auto     edata uchar  -2       1
  CRC_16 . . . . . . . . . . . . . . .  static   edata union  000237H  2
  j. . . . . . . . . . . . . . . . . .  auto     edata uchar  -3       1
C251 COMPILER V5.60.0,  main                                                               20/10/24  15:19:14  PAGE 68  

send_BAD_CRC_ACK?_ . . . . . . . . . .  public   code  funct  000000H  12
jump?_ . . . . . . . . . . . . . . . .  public   code  funct  000000H  83
  value. . . . . . . . . . . . . . . .  auto     edata uchar  000000H  1
Uart1_Init?_ . . . . . . . . . . . . .  public   code  funct  000000H  22
recieveBuffer?_. . . . . . . . . . . .  public   code  funct  000000H  232
  i. . . . . . . . . . . . . . . . . .  auto     edata int    -1       2
send_ACK?_ . . . . . . . . . . . . . .  public   code  funct  000000H  12
decodeInput?_. . . . . . . . . . . . .  public   code  funct  000000H  994
  out_buffer_size. . . . . . . . . . .  auto     edata uint   -1       2
  read_data. . . . . . . . . . . . . .  auto     edata ptr    -5       4
  i. . . . . . . . . . . . . . . . . .  auto     edata int    -7       2
putchar. . . . . . . . . . . . . . . .  public   code  funct  000000H  17
  c. . . . . . . . . . . . . . . . . .  param    edata char   000000H  1
calculated_crc_low_byte. . . . . . . .  public   edata uchar  000000H  1
received_crc_high_byte . . . . . . . .  public   edata uchar  000001H  1
deviceInfo . . . . . . . . . . . . . .  public   edata array  000002H  9
low_pin_count. . . . . . . . . . . . .  public   edata uint   00000BH  2
bootloader_version . . . . . . . . . .  public   edata uchar  00000DH  1
rxbyte . . . . . . . . . . . . . . . .  public   edata char   00000EH  1
incoming_payload_no_command. . . . . .  public   edata char   00000FH  1
count. . . . . . . . . . . . . . . . .  public   edata int    000010H  2
tick . . . . . . . . . . . . . . . . .  public   edata int    000012H  2
payLoadBuffer. . . . . . . . . . . . .  public   edata array  000014H  256
invalid_command. . . . . . . . . . . .  public   edata uint   000114H  2
received_crc_low_byte. . . . . . . . .  public   edata uchar  000116H  1
bootloaderactive . . . . . . . . . . .  public   edata char   000117H  1
cmd. . . . . . . . . . . . . . . . . .  public   edata int    000118H  2
eeprom_req . . . . . . . . . . . . . .  public   edata char   00011AH  1
messagereceived. . . . . . . . . . . .  public   edata char   00011BH  1
connected. . . . . . . . . . . . . . .  public   edata char   00011CH  1
port_letter. . . . . . . . . . . . . .  public   edata uchar  00011DH  1
len. . . . . . . . . . . . . . . . . .  public   edata uint   00011EH  2
pin_code . . . . . . . . . . . . . . .  public   edata uchar  000120H  1
rxBuffer . . . . . . . . . . . . . . .  public   edata array  000121H  258
received . . . . . . . . . . . . . . .  public   edata int    000223H  2
calculated_crc_high_byte . . . . . . .  public   edata uchar  000225H  1
address_expected_increment . . . . . .  public   edata uint   000226H  2
receivedCount. . . . . . . . . . . . .  public   edata int    000228H  2
receviedByte . . . . . . . . . . . . .  public   edata char   00022AH  1
JumpAddress. . . . . . . . . . . . . .  public   edata ulong  00022BH  4
address. . . . . . . . . . . . . . . .  public   edata ulong  00022FH  4
payload_buffer_size. . . . . . . . . .  public   edata uint   000233H  2
str_len. . . . . . . . . . . . . . . .  public   edata uint   000235H  2


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3077     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       570     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       125     ------
End of Module Information.


C251 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
